<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Solvers · TrajectoryOptimization</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">TrajectoryOptimization</span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Introduction</a></li><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="models.html">1. Setting up a Dynamics Model</a></li><li><a class="tocitem" href="costfunctions.html">2. Setting up an Objective</a></li><li><a class="tocitem" href="constraints.html">3. Creating Constraints</a></li><li><a class="tocitem" href="creating_problems.html">4. Setting up a Problem</a></li><li><a class="tocitem" href="solving.html">5. Solving the Problem</a></li></ul></li><li><span class="tocitem">Interfaces</span><ul><li><a class="tocitem" href="costfunction_interface.html">Cost Function Interface</a></li><li><a class="tocitem" href="constraint_interface.html">Constraint Interface</a></li><li><a class="tocitem" href="solver_interface.html">Solver Interface</a></li></ul></li><li><span class="tocitem">Documentation</span><ul><li><a class="tocitem" href="model_types.html">Model Types</a></li><li><a class="tocitem" href="discretization.html">Discretization</a></li><li><a class="tocitem" href="cost_api.html">Cost Functions and Objectives</a></li><li><a class="tocitem" href="constraint_api.html">Constraints</a></li><li><a class="tocitem" href="problem.html">Problem</a></li><li class="is-active"><a class="tocitem" href="solvers.html">Solvers</a><ul class="internal"><li><a class="tocitem" href="#Iterative-LQR-(iLQR)-1"><span>Iterative LQR (iLQR)</span></a></li><li><a class="tocitem" href="#Augmented-Lagrangian-Solver-1"><span>Augmented Lagrangian Solver</span></a></li><li><a class="tocitem" href="#ALTRO-1"><span>ALTRO</span></a></li><li><a class="tocitem" href="#Direct-Collocation-(DIRCOL)-1"><span>Direct Collocation (DIRCOL)</span></a></li><li><a class="tocitem" href="#Projected-Newton-1"><span>Projected Newton</span></a></li></ul></li><li><a class="tocitem" href="rotations.html">Rotations</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Documentation</a></li><li class="is-active"><a href="solvers.html">Solvers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="solvers.html">Solvers</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/master/docs/src/solvers.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Solvers-1"><a class="docs-heading-anchor" href="#Solvers-1">Solvers</a><a class="docs-heading-anchor-permalink" href="#Solvers-1" title="Permalink"></a></h1><ul><li><a href="solvers.html#Solvers-1">Solvers</a></li><ul><li><a href="solvers.html#Iterative-LQR-(iLQR)-1">Iterative LQR (iLQR)</a></li><li><a href="solvers.html#Augmented-Lagrangian-Solver-1">Augmented Lagrangian Solver</a></li><li><a href="solvers.html#ALTRO-1">ALTRO</a></li><li><a href="solvers.html#Direct-Collocation-(DIRCOL)-1">Direct Collocation (DIRCOL)</a></li><li><a href="solvers.html#Projected-Newton-1">Projected Newton</a></li></ul></ul><h2 id="Iterative-LQR-(iLQR)-1"><a class="docs-heading-anchor" href="#Iterative-LQR-(iLQR)-1">Iterative LQR (iLQR)</a><a class="docs-heading-anchor-permalink" href="#Iterative-LQR-(iLQR)-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="TrajectoryOptimization.iLQRSolver" href="#TrajectoryOptimization.iLQRSolver"><code>TrajectoryOptimization.iLQRSolver</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct iLQRSolver{T, I&lt;:QuadratureRule, L, O, n, n̄, m, L1, L2, D, F, E1, E2} &lt;: UnconstrainedSolver{T}</code></pre><p>iLQR is an unconstrained indirect method for trajectory optimization that parameterizes only the controls and enforces strict dynamics feasibility at every iteration by simulating forward the dynamics with an LQR feedback controller. The main algorithm consists of two parts:</p><ol><li>a backward pass that uses Differential Dynamic Programming to compute recursively a quadratic approximation of the cost-to-go, along with linear feedback and feed-forward gain matrices, <code>K</code> and <code>d</code>, respectively, for an LQR tracking controller, and</li><li>a forward pass that uses the gains <code>K</code> and <code>d</code> to simulate forward the full nonlinear dynamics with feedback.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/94c11c790b4a3af7e8c39aa5e8d5f45577fd6624/src/solvers/silqr/silqr_solver.jl#L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TrajectoryOptimization.iLQRSolverOptions" href="#TrajectoryOptimization.iLQRSolverOptions"><code>TrajectoryOptimization.iLQRSolverOptions</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct iLQRSolverOptions{T} &lt;: TrajectoryOptimization.AbstractSolverOptions{T}</code></pre><p>Solver options for the iterative LQR (iLQR) solver.</p><ul><li><p><code>verbose</code></p><p>Print summary at each iteration. Default: false</p></li><li><p><code>live_plotting</code></p><p>Live plotting. Default: :off</p></li><li><p><code>cost_tolerance</code></p><p>dJ &lt; ϵ, cost convergence criteria for unconstrained solve or to enter outerloop for constrained solve. Default: 0.0001</p></li><li><p><code>gradient_type</code></p><p>gradient type: :todorov, :feedforward. Default: :todorov</p></li><li><p><code>gradient_norm_tolerance</code></p><p>gradient_norm &lt; ϵ, gradient norm convergence criteria. Default: 1.0e-5</p></li><li><p><code>iterations</code></p><p>iLQR iterations. Default: 300</p></li><li><p><code>dJ_counter_limit</code></p><p>restricts the total number of times a forward pass fails, resulting in regularization, before exiting. Default: 10</p></li><li><p><code>square_root</code></p><p>use square root method backward pass for numerical conditioning. Default: false</p></li><li><p><code>line_search_lower_bound</code></p><p>forward pass approximate line search lower bound, 0 &lt; line<em>search</em>lower<em>bound &lt; line</em>search<em>upper</em>bound. Default: 1.0e-8</p></li><li><p><code>line_search_upper_bound</code></p><p>forward pass approximate line search upper bound, 0 &lt; line<em>search</em>lower<em>bound &lt; line</em>search<em>upper</em>bound &lt; ∞. Default: 10.0</p></li><li><p><code>iterations_linesearch</code></p><p>maximum number of backtracking steps during forward pass line search. Default: 20</p></li><li><p><code>bp_reg_initial</code></p><p>initial regularization. Default: 0.0</p></li><li><p><code>bp_reg_increase_factor</code></p><p>regularization scaling factor. Default: 1.6</p></li><li><p><code>bp_reg_max</code></p><p>maximum regularization value. Default: 1.0e8</p></li><li><p><code>bp_reg_min</code></p><p>minimum regularization value. Default: 1.0e-8</p></li><li><p><code>bp_reg_type</code></p><p>type of regularization- control: () + ρI, state: (S + ρI); see Synthesis and Stabilization of Complex Behaviors through Online Trajectory Optimization. Default: :control</p></li><li><p><code>bp_reg_fp</code></p><p>additive regularization when forward pass reaches max iterations. Default: 10.0</p></li><li><p><code>bp_sqrt_inv_type</code></p><p>type of matrix inversion for bp sqrt step. Default: :pseudo</p></li><li><p><code>bp_reg_sqrt_initial</code></p><p>initial regularization for square root method. Default: 1.0e-6</p></li><li><p><code>bp_reg_sqrt_increase_factor</code></p><p>regularization scaling factor for square root method. Default: 10.0</p></li><li><p><code>max_cost_value</code></p><p>maximum cost value, if exceded solve will error. Default: 1.0e8</p></li><li><p><code>max_state_value</code></p><p>maximum state value, evaluated during rollout, if exceded solve will error. Default: 1.0e8</p></li><li><p><code>max_control_value</code></p><p>maximum control value, evaluated during rollout, if exceded solve will error. Default: 1.0e8</p></li><li><p><code>log_level</code></p><p>Default: InnerLoop</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/2d5741174ce3e6a394010d2e470e4269ca54607f/base/#L0">source</a></section></article><h2 id="Augmented-Lagrangian-Solver-1"><a class="docs-heading-anchor" href="#Augmented-Lagrangian-Solver-1">Augmented Lagrangian Solver</a><a class="docs-heading-anchor-permalink" href="#Augmented-Lagrangian-Solver-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="TrajectoryOptimization.AugmentedLagrangianSolver" href="#TrajectoryOptimization.AugmentedLagrangianSolver"><code>TrajectoryOptimization.AugmentedLagrangianSolver</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct AugmentedLagrangianSolver &lt;: TrajectoryOptimization.AbstractSolver{T}</code></pre><p>Augmented Lagrangian (AL) is a standard tool for constrained optimization. For a trajectory optimization problem of the form:</p><div>\[\begin{aligned}
  \min_{x_{0:N},u_{0:N-1}} \quad &amp; \ell_f(x_N) + \sum_{k=0}^{N-1} \ell_k(x_k, u_k, dt) \\
  \textrm{s.t.}            \quad &amp; x_{k+1} = f(x_k, u_k), \\
                                 &amp; g_k(x_k,u_k) \leq 0, \\
                                 &amp; h_k(x_k,u_k) = 0.
\end{aligned}\]</div><p>AL methods form the following augmented Lagrangian function:</p><div>\[\begin{aligned}
    \ell_f(x_N) + &amp;λ_N^T c_N(x_N) + c_N(x_N)^T I_{\mu_N} c_N(x_N) \\
           &amp; + \sum_{k=0}^{N-1} \ell_k(x_k,u_k,dt) + λ_k^T c_k(x_k,u_k) + c_k(x_k,u_k)^T I_{\mu_k} c_k(x_k,u_k)
\end{aligned}\]</div><p>This function is then minimized with respect to the primal variables using any unconstrained minimization solver (e.g. iLQR).     After a local minima is found, the AL method updates the Lagrange multipliers λ and the penalty terms μ and repeats the unconstrained minimization.     AL methods have superlinear convergence as long as the penalty term μ is updated each iteration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/94c11c790b4a3af7e8c39aa5e8d5f45577fd6624/src/solvers/augmented_lagrangian/sal_solver.jl#L134-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TrajectoryOptimization.AugmentedLagrangianSolverOptions" href="#TrajectoryOptimization.AugmentedLagrangianSolverOptions"><code>TrajectoryOptimization.AugmentedLagrangianSolverOptions</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct AugmentedLagrangianSolverOptions{T} &lt;: TrajectoryOptimization.AbstractSolverOptions{T}</code></pre><p>Solver options for the augmented Lagrangian solver.</p><ul><li><p><code>verbose</code></p><p>Print summary at each iteration. Default: false</p></li><li><p><code>opts_uncon</code></p><p>unconstrained solver options. Default: iLQRSolverOptions{Float64}()</p></li><li><p><code>cost_tolerance</code></p><p>dJ &lt; ϵ, cost convergence criteria for unconstrained solve or to enter outerloop for constrained solve. Default: 0.0001</p></li><li><p><code>cost_tolerance_intermediate</code></p><p>dJ &lt; ϵ_int, intermediate cost convergence criteria to enter outerloop of constrained solve. Default: 0.001</p></li><li><p><code>gradient_norm_tolerance</code></p><p>gradient_norm &lt; ϵ, gradient norm convergence criteria. Default: 1.0e-5</p></li><li><p><code>gradient_norm_tolerance_intermediate</code></p><p>gradient<em>norm</em>int &lt; ϵ, gradient norm intermediate convergence criteria. Default: 1.0e-5</p></li><li><p><code>constraint_tolerance</code></p><p>max(constraint) &lt; ϵ, constraint convergence criteria. Default: 0.001</p></li><li><p><code>constraint_tolerance_intermediate</code></p><p>max(constraint) &lt; ϵ_int, intermediate constraint convergence criteria. Default: 0.001</p></li><li><p><code>iterations</code></p><p>maximum outerloop updates. Default: 30</p></li><li><p><code>dual_max</code></p><p>global maximum Lagrange multiplier. If NaN, use value from constraint Default: NaN</p></li><li><p><code>penalty_max</code></p><p>global maximum penalty term. If NaN, use value from constraint Default: NaN</p></li><li><p><code>penalty_initial</code></p><p>global initial penalty term. If NaN, use value from constraint Default: NaN</p></li><li><p><code>penalty_scaling</code></p><p>global penalty update multiplier; penalty_scaling &gt; 1. If NaN, use value from constraint Default: NaN</p></li><li><p><code>penalty_scaling_no</code></p><p>penalty update multiplier when μ should not be update, typically 1.0 (or 1.0 + ϵ). Default: 1.0</p></li><li><p><code>constraint_decrease_ratio</code></p><p>ratio of current constraint to previous constraint violation; 0 &lt; constraint<em>decrease</em>ratio &lt; 1. Default: 0.25</p></li><li><p><code>outer_loop_update_type</code></p><p>type of outer loop update (default, feedback). Default: :default</p></li><li><p><code>active_constraint_tolerance</code></p><p>numerical tolerance for constraint violation. Default: 0.0</p></li><li><p><code>kickout_max_penalty</code></p><p>terminal solve when maximum penalty is reached. Default: false</p></li><li><p><code>log_level</code></p><p>Default: OuterLoop</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/2d5741174ce3e6a394010d2e470e4269ca54607f/base/#L0">source</a></section></article><h2 id="ALTRO-1"><a class="docs-heading-anchor" href="#ALTRO-1">ALTRO</a><a class="docs-heading-anchor-permalink" href="#ALTRO-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="TrajectoryOptimization.ALTROSolver" href="#TrajectoryOptimization.ALTROSolver"><code>TrajectoryOptimization.ALTROSolver</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct ALTROSolver{T} &lt;: ConstrainedSolver{T}</code></pre><p>Augmented Lagrangian Trajectory Optimizer (ALTRO) is a solver developed by the Robotic Exploration Lab at Stanford University.     The solver is special-cased to solve Markov Decision Processes by leveraging the internal problem structure.</p><p>ALTRO consists of two &quot;phases&quot;:</p><ol><li>AL-iLQR: iLQR is used with an Augmented Lagrangian framework to solve the problem quickly to rough constraint satisfaction</li><li>Projected Newton: A collocation-flavored active-set solver projects the solution from AL-iLQR onto the feasible subspace to achieve machine-precision constraint satisfaction.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/94c11c790b4a3af7e8c39aa5e8d5f45577fd6624/src/solvers/altro/saltro_solver.jl#L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TrajectoryOptimization.ALTROSolverOptions" href="#TrajectoryOptimization.ALTROSolverOptions"><code>TrajectoryOptimization.ALTROSolverOptions</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct ALTROSolverOptions{T} &lt;: TrajectoryOptimization.AbstractSolverOptions{T}</code></pre><p>Solver options for the ALTRO solver.</p><ul><li><p><code>verbose</code></p><p>Default: false</p></li><li><p><code>opts_al</code></p><p>Augmented Lagrangian solver options. Default: AugmentedLagrangianSolverOptions{Float64}()</p></li><li><p><code>constraint_tolerance</code></p><p>constraint tolerance Default: 1.0e-5</p></li><li><p><code>infeasible</code></p><p>Use infeasible model (augment controls to make it fully actuated) Default: false</p></li><li><p><code>R_inf</code></p><p>regularization term for infeasible controls. Default: 1.0</p></li><li><p><code>dynamically_feasible_projection</code></p><p>project infeasible results to feasible space using TVLQR. Default: true</p></li><li><p><code>resolve_feasible_problem</code></p><p>resolve feasible problem after infeasible solve. Default: true</p></li><li><p><code>penalty_initial_infeasible</code></p><p>initial penalty term for infeasible controls. Default: 1.0</p></li><li><p><code>penalty_scaling_infeasible</code></p><p>penalty update rate for infeasible controls. Default: 10.0</p></li><li><p><code>projected_newton</code></p><p>finish with a projecte newton solve. Default: true</p></li><li><p><code>opts_pn</code></p><p>options for projected newton solver. Default: ProjectedNewtonSolverOptions{Float64}()</p></li><li><p><code>projected_newton_tolerance</code></p><p>constraint satisfaction tolerance that triggers the projected newton solver.     If set to a non-positive number it will kick out when the maximum penalty is reached. Default: 0.001</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/2d5741174ce3e6a394010d2e470e4269ca54607f/base/#L0">source</a></section></article><h2 id="Direct-Collocation-(DIRCOL)-1"><a class="docs-heading-anchor" href="#Direct-Collocation-(DIRCOL)-1">Direct Collocation (DIRCOL)</a><a class="docs-heading-anchor-permalink" href="#Direct-Collocation-(DIRCOL)-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="TrajectoryOptimization.DIRCOLSolver" href="#TrajectoryOptimization.DIRCOLSolver"><code>TrajectoryOptimization.DIRCOLSolver</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct DIRCOLSolver{Q&lt;:QuadratureRule, L, T, N, M, NM} &lt;: DirectSolver{T}</code></pre><p>Direct Collocation Solver. Uses a commerical NLP solver to solve the Trajectory Optimization problem. Uses the MathOptInterface to interface with the NLP.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/94c11c790b4a3af7e8c39aa5e8d5f45577fd6624/src/solvers/direct/static_moi.jl#L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TrajectoryOptimization.DIRCOLSolverOptions" href="#TrajectoryOptimization.DIRCOLSolverOptions"><code>TrajectoryOptimization.DIRCOLSolverOptions</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct DIRCOLSolverOptions{T} &lt;: TrajectoryOptimization.DirectSolverOptions{T}</code></pre><p>Solver options for the Direct Collocation solver. Most options are passed to the NLP through the <code>opts</code> dictionary</p><ul><li><p><code>nlp</code></p><p>NLP Solver to use. See MathOptInterface for available NLP solvers Default: Ipopt.Optimizer()</p></li><li><p><code>opts</code></p><p>Options dictionary for the nlp solver Default: Dict{Symbol, Any}()</p></li><li><p><code>verbose</code></p><p>Print output to console Default: true</p></li><li><p><code>feasibility_tolerance</code></p><p>Feasibility tolerance Default: -1.0</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/2d5741174ce3e6a394010d2e470e4269ca54607f/base/#L0">source</a></section></article><h2 id="Projected-Newton-1"><a class="docs-heading-anchor" href="#Projected-Newton-1">Projected Newton</a><a class="docs-heading-anchor-permalink" href="#Projected-Newton-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="TrajectoryOptimization.ProjectedNewtonSolver" href="#TrajectoryOptimization.ProjectedNewtonSolver"><code>TrajectoryOptimization.ProjectedNewtonSolver</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct ProjectedNewtonSolver{T, N, M, NM} &lt;: DirectSolver{T}</code></pre><p>Projected Newton Solver Direct method developed by the REx Lab at Stanford University Achieves machine-level constraint satisfaction by projecting onto the feasible subspace.     It can also take a full Newton step by solving the KKT system. This solver is to be used exlusively for solutions that are close to the optimal solution.     It is intended to be used as a &quot;solution polishing&quot; method for augmented Lagrangian methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/94c11c790b4a3af7e8c39aa5e8d5f45577fd6624/src/solvers/direct/static_pn.jl#L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TrajectoryOptimization.ProjectedNewtonSolverOptions" href="#TrajectoryOptimization.ProjectedNewtonSolverOptions"><code>TrajectoryOptimization.ProjectedNewtonSolverOptions</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct ProjectedNewtonSolverOptions{T} &lt;: TrajectoryOptimization.DirectSolverOptions{T}</code></pre><p>Solver options for the Projected Newton solver.</p><ul><li><p><code>verbose</code></p><p>Default: true</p></li><li><p><code>n_steps</code></p><p>Default: 1</p></li><li><p><code>solve_type</code></p><p>Default: :feasible</p></li><li><p><code>active_set_tolerance</code></p><p>Default: 0.001</p></li><li><p><code>feasibility_tolerance</code></p><p>Default: 1.0e-6</p></li><li><p><code>ρ</code></p><p>Default: 0.01</p></li><li><p><code>r_threshold</code></p><p>Default: 1.1</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/2d5741174ce3e6a394010d2e470e4269ca54607f/base/#L0">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="problem.html">« Problem</a><a class="docs-footer-nextpage" href="rotations.html">Rotations »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 3 January 2020 21:14">Friday 3 January 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
