var documenterSearchIndex = {"docs":
[{"location":"model_types.html#Model-Types-1","page":"Model Types","title":"Model Types","text":"","category":"section"},{"location":"model_types.html#","page":"Model Types","title":"Model Types","text":"This page provides details on specific sub-types of AbstractModel that are curently implemented in TrajectoryOptimization.jl.","category":"page"},{"location":"model_types.html#Rigid-Body-Models-1","page":"Model Types","title":"Rigid Body Models","text":"","category":"section"},{"location":"model_types.html#Infeasible-Models-1","page":"Model Types","title":"Infeasible Models","text":"","category":"section"},{"location":"model_types.html#","page":"Model Types","title":"Model Types","text":"InfeasibleModel","category":"page"},{"location":"model_types.html#TrajectoryOptimization.InfeasibleModel","page":"Model Types","title":"TrajectoryOptimization.InfeasibleModel","text":"struct InfeasibleModel{N, M, D<:AbstractModel} <: AbstractModel\n\nAn infeasible model is an augmented dynamics model that makes the system artifically fully actuated by augmenting the control vector with n additional controls. The dynamics are handled explicitly in discrete time:\n\nx_k+1 = f(x_ku_kdt) + w_k\n\nwhere w_k are the additional n-dimensional controls. In practice, these are constrained to be zero by the end of the solve.\n\nConstructors\n\nInfeasibleModel(model::AbstractModel)\n\n\n\n\n\n","category":"type"},{"location":"constraints.html#constraint_section-1","page":"3. Creating Constraints","title":"3. Creating Constraints","text":"","category":"section"},{"location":"constraints.html#","page":"3. Creating Constraints","title":"3. Creating Constraints","text":"CurrentModule = TrajectoryOptimization","category":"page"},{"location":"constraints.html#","page":"3. Creating Constraints","title":"3. Creating Constraints","text":"Pages = [\"constraints.md\"]","category":"page"},{"location":"constraints.html#Creating-Constraint-Sets-1","page":"3. Creating Constraints","title":"Creating Constraint Sets","text":"","category":"section"},{"location":"constraints.html#","page":"3. Creating Constraints","title":"3. Creating Constraints","text":"The easiest way to set up the constraints for your problem is through the ConstraintSet. This structure simply holds a vector of all the constraints in the trajectory optimization problem. The easiest way to start is to create an empty ConstraintSet:","category":"page"},{"location":"constraints.html#","page":"3. Creating Constraints","title":"3. Creating Constraints","text":"conSet = ConstraintSet(n,m,N)","category":"page"},{"location":"constraints.html#Adding-Constraints-1","page":"3. Creating Constraints","title":"Adding Constraints","text":"","category":"section"},{"location":"constraints.html#","page":"3. Creating Constraints","title":"3. Creating Constraints","text":"You can add any constraint (the list of currently implemented constraints is given in the following section) to the constraint set using the following method:","category":"page"},{"location":"constraints.html#","page":"3. Creating Constraints","title":"3. Creating Constraints","text":"add_constraint!","category":"page"},{"location":"constraints.html#TrajectoryOptimization.add_constraint!","page":"3. Creating Constraints","title":"TrajectoryOptimization.add_constraint!","text":"add_constraint!(conSet, conVal::ConstraintVals, idx=-1)\nadd_constraint!(conSet, con::AbstractConstraint, inds::UnitRange, idx=-1)\n\nAdd a constraint to the constraint set. You can directly add a ConstraintVals type, but when adding a normal AbstractConstraint you must specify the range of knotpoints to which the constraint applies.\n\nThe optional idx argument allows you to specify exactly where in the vector of constraints you'd like the constraint to be added. The ordering will effect the order in which the constraint appears in concatenated vectors of constraint values (that show up in direct methods), potentially effecting the band structure of the resultant Jacobian. See solvers for more details.\n\n\n\n\n\n","category":"function"},{"location":"constraints.html#Other-Methods-1","page":"3. Creating Constraints","title":"Other Methods","text":"","category":"section"},{"location":"constraints.html#","page":"3. Creating Constraints","title":"3. Creating Constraints","text":"There are a variety of methods defined on constraint sets, since they are the general interface that solvers work with when dealing with constraints.","category":"page"},{"location":"constraints.html#Information-Methods-1","page":"3. Creating Constraints","title":"Information Methods","text":"","category":"section"},{"location":"constraints.html#","page":"3. Creating Constraints","title":"3. Creating Constraints","text":"These methods provide or calculate information about the constraint set","category":"page"},{"location":"constraints.html#","page":"3. Creating Constraints","title":"3. Creating Constraints","text":"Base.size(::ConstraintSet)\nBase.length(::ConstraintSet)\nnum_constraints!\nnum_constraints","category":"page"},{"location":"constraints.html#Base.size-Tuple{ConstraintSet}","page":"3. Creating Constraints","title":"Base.size","text":"Get size of state and control dimensions\n\n\n\n\n\n","category":"method"},{"location":"constraints.html#Base.length-Tuple{ConstraintSet}","page":"3. Creating Constraints","title":"Base.length","text":"Get number of separate constraints (i.e. ConstraintVals) in the set\n\n\n\n\n\n","category":"method"},{"location":"constraints.html#TrajectoryOptimization.num_constraints!","page":"3. Creating Constraints","title":"TrajectoryOptimization.num_constraints!","text":"Re-calculate the number of constraints in the constraint set\n\n\n\n\n\n","category":"function"},{"location":"constraints.html#TrajectoryOptimization.num_constraints","page":"3. Creating Constraints","title":"TrajectoryOptimization.num_constraints","text":"num_constraints(::ConstraintSet)\nnum_constraints(::AbstractSolver)\nnum_constraints(::Problem)\n\nGet the total number of constraints at each time step\n\n\n\n\n\n","category":"function"},{"location":"constraints.html#Calculation-Methods-1","page":"3. Creating Constraints","title":"Calculation Methods","text":"","category":"section"},{"location":"constraints.html#","page":"3. Creating Constraints","title":"3. Creating Constraints","text":"These methods perform calculations on the constraint set","category":"page"},{"location":"constraints.html#","page":"3. Creating Constraints","title":"3. Creating Constraints","text":"max_violation\nmax_penalty\nevaluate!(::ConstraintSet, ::Traj)\njacobian!(::ConstraintSet, ::Traj)\nreset!(::ConstraintSet)","category":"page"},{"location":"constraints.html#TrajectoryOptimization.max_violation","page":"3. Creating Constraints","title":"TrajectoryOptimization.max_violation","text":"max_violation(conSet::ConstraintSet)\nmax_violation(conSet::ConstraintSet, Z::Traj)\nmax_violation(prob::Problem, Z=prob.Z)\nmax_violation(solver::AbstractSolver)\nmax_violation(solver::AbstractSolver, Z)\n\nCalculate the maximum constraint violation for the entire constraint set. \tIf the a trajectory is not passed in, the violation is computed from the currently \tstored constraint values; otherwise, the constraints are re-computed using the \ttrajectory passed in.\n\n\n\n\n\n","category":"function"},{"location":"constraints.html#TrajectoryOptimization.max_penalty","page":"3. Creating Constraints","title":"TrajectoryOptimization.max_penalty","text":"Calculate the maximum penalty parameter across all constraints\n\n\n\n\n\n","category":"function"},{"location":"constraints.html#TrajectoryOptimization.evaluate!-Tuple{ConstraintSet,AbstractArray{#s29,1} where #s29<:KnotPoint}","page":"3. Creating Constraints","title":"TrajectoryOptimization.evaluate!","text":"evaluate!(conSet::ConstraintSet, Z::Traj)\n\nCompute constraint values for all constraints for the entire trajectory\n\n\n\n\n\n","category":"method"},{"location":"constraints.html#TrajectoryOptimization.jacobian!-Tuple{ConstraintSet,AbstractArray{#s29,1} where #s29<:KnotPoint}","page":"3. Creating Constraints","title":"TrajectoryOptimization.jacobian!","text":"jacobian!(conSet::ConstraintSet, Z::Traj)\n\nCompute constraint Jacobians for all constraints for the entire trajectory\n\n\n\n\n\n","category":"method"},{"location":"constraints.html#TrajectoryOptimization.reset!-Tuple{ConstraintSet}","page":"3. Creating Constraints","title":"TrajectoryOptimization.reset!","text":"Reset all the Lagrange multipliers and constraint values to zero and \tpenalties the their initial value\n\n\n\n\n\n","category":"method"},{"location":"constraints.html#","page":"3. Creating Constraints","title":"3. Creating Constraints","text":"ConstraintSet supports indexing and iteration, which returns the ConstraintVals at that index. However, to avoid allocations, iteration directly on the .constraints field.","category":"page"},{"location":"constraints.html#","page":"3. Creating Constraints","title":"3. Creating Constraints","text":"Additionally, to avoid allocations when computing max_violation, you can call max_violation!(conSet) and then maximum(conSet.c_max) to perform the reduction in the scope where the result is stored (thereby avoiding an allocation).","category":"page"},{"location":"constraints.html#Defined-Constraints-1","page":"3. Creating Constraints","title":"Defined Constraints","text":"","category":"section"},{"location":"constraints.html#","page":"3. Creating Constraints","title":"3. Creating Constraints","text":"The following constraints are currently defined. See later sections on the constraint interface and how to add custom constraints.","category":"page"},{"location":"constraints.html#","page":"3. Creating Constraints","title":"3. Creating Constraints","text":"GoalConstraint\nBoundConstraint\nCircleConstraint\nSphereConstraint\nNormConstraint\nIndexedConstraint","category":"page"},{"location":"constraints.html#TrajectoryOptimization.GoalConstraint","page":"3. Creating Constraints","title":"TrajectoryOptimization.GoalConstraint","text":"struct GoalConstraint{T, P, N, L} <: TrajectoryOptimization.AbstractConstraint{Equality,State,P}\n\nConstraint of the form x_g = a, where x_g can be only part of the state vector.\n\nConstructors:\n\nGoalConstraint(xf::AbstractVector)\nGoalConstraint(xf::AbstractVector, inds)\n\nwhere xf is an n-dimensional goal state. If inds is provided, only xf[inds] will be used.\n\n\n\n\n\n","category":"type"},{"location":"constraints.html#TrajectoryOptimization.BoundConstraint","page":"3. Creating Constraints","title":"TrajectoryOptimization.BoundConstraint","text":"struct BoundConstraint{T, P, PN, NM, PNM} <: TrajectoryOptimization.AbstractConstraint{Inequality,Stage,P}\n\nLinear bound constraint on states and controls\n\nConstructors\n\nBoundConstraint(n, m; x_min, x_max, u_min, u_max)\n\nAny of the bounds can be ±∞. The bound can also be specifed as a single scalar, which applies the bound to all state/controls.\n\n\n\n\n\n","category":"type"},{"location":"constraints.html#TrajectoryOptimization.CircleConstraint","page":"3. Creating Constraints","title":"TrajectoryOptimization.CircleConstraint","text":"struct CircleConstraint{T, P} <: TrajectoryOptimization.AbstractConstraint{Inequality,State,P}\n\nConstraint of the form (x - x_c)^2 + (y - y_c)^2 leq r^2 where x, y are given by x[xi],x[yi], (x_cy_c) is the center of the circle, and r is the radius.\n\nConstructor: ```julia\n\nCircleConstraint(n, xc::SVector{P}, yc::SVector{P}, radius::SVector{P}, xi=1, yi=2) ```\n\n\n\n\n\n","category":"type"},{"location":"constraints.html#TrajectoryOptimization.SphereConstraint","page":"3. Creating Constraints","title":"TrajectoryOptimization.SphereConstraint","text":"struct SphereConstraint{T, P} <: TrajectoryOptimization.AbstractConstraint{Inequality,State,P}\n\nConstraint of the form (x - x_c)^2 + (y - y_c)^2 + (z - z_c)^2 leq r^2 where x, y, z are given by x[xi],x[yi],x[zi], (x_cy_cz_c) is the center of the sphere, and r is the radius.\n\nConstructor:\n\nSphereConstraint(n, xc::SVector{P}, yc::SVector{P}, zc::SVector{P},\n\tradius::SVector{P}, xi=1, yi=2, zi=3)\n\n\n\n\n\n","category":"type"},{"location":"constraints.html#TrajectoryOptimization.NormConstraint","page":"3. Creating Constraints","title":"TrajectoryOptimization.NormConstraint","text":"struct NormConstraint{S, W<:Union{Control, State}, T} <: TrajectoryOptimization.AbstractConstraint{S,W<:Union{Control, State},1}\n\nConstraint of the form norm(y)^2 leq val where y is either a state or a vector (but not both)\n\nConstructors:\n\nNormConstraint{S,State}(n,val)\nNormConstraint{S,Control}(m,val)\n\n\n\n\n\n","category":"type"},{"location":"constraints.html#TrajectoryOptimization.IndexedConstraint","page":"3. Creating Constraints","title":"TrajectoryOptimization.IndexedConstraint","text":"struct IndexedConstraint{S, W, P, N, M, NM, Bx, Bu, C} <: TrajectoryOptimization.AbstractConstraint{S,W,P}\n\nCompute a constraint on an arbitrary portion of either the state or control, or both. Useful for dynamics augmentation. e.g. you are controlling two models, and have individual constraints on each. You can define constraints as if they applied to the individual model, and then wrap it in an IndexedConstraint to apply it to the appropriate portion of the concatenated state. Assumes the indexed state portion is contiguous.\n\nType params:\n\nS - Inequality or Equality\nW - ConstraintType\nP - Constraint length\nN,M - original state and control dimensions\nNM - N+M\nBx - location of the first element in the state index\nBu - location of the first element in the control index\nC - type of original constraint\n\nConstructors:julia IndexedConstraint(n, m, con) IndexedConstraint(n, m, con, ix::SVector, iu::SVector) where the arguments n and m are the state and control dimensions of the new dynamics. ix and iu are the indices into the state and control vectors. If left out, they are assumed to start at the beginning of the vector.\n\nNOTE: Only part of this functionality has been tested. Use with caution!\n\n\n\n\n\n","category":"type"},{"location":"constraints.html#Constraint-Type-1","page":"3. Creating Constraints","title":"Constraint Type","text":"","category":"section"},{"location":"constraints.html#","page":"3. Creating Constraints","title":"3. Creating Constraints","text":"All constraints inherit from AbstractConstraint{S<:ConstraintSense,W<:ConstraintType,P}, where ConstraintSense specifies Inequality or Equality, ConstraintType specifies the \"bandedness\" of the constraint (will be discussed more later), and P is the dimension of the constraint. This allows the software to easily dispatch over the type of constraint. Each constraint type represents a vector-valued constraint. The intention is that each constraint type represent one line in the constraints of problem definition (where they may be vector or scalar-valued).","category":"page"},{"location":"constraints.html#","page":"3. Creating Constraints","title":"3. Creating Constraints","text":"TrajectoryOptimization.jl assumes equality constraints are of the form g(x) = 0 and inequality constraints are of the form h(x) leq 0.","category":"page"},{"location":"constraints.html#","page":"3. Creating Constraints","title":"3. Creating Constraints","text":"AbstractConstraint\nConstraintSense\nConstraintType","category":"page"},{"location":"constraints.html#TrajectoryOptimization.AbstractConstraint","page":"3. Creating Constraints","title":"TrajectoryOptimization.AbstractConstraint","text":"abstract type AbstractConstraint <: TrajectoryOptimization.GeneralConstraint\n\nAbstract vector-valued constraint of size P for a trajectory optimization problem. May be either inequality or equality (specified by S<:ConstraintSense), and be function of single, adjacent, or all knotpoints (specified by W<:ConstraintType).\n\nInterface: Any constraint type must implement the following interface:\n\nn = state_dim(::MyCon)\nm = control_dim(::MyCon)\np = Base.length(::MyCon)\nc = evaluate(::MyCon, args...)   # args determined by W\n∇c = jacobian(::MyCon, args...)  # args determined by W\n\nThe evaluate and jacobian (identical signatures) methods should have the following signatures\n\nW <: State: evaluate(::MyCon, x::SVector)\nW <: Control: evaluate(::MyCon, u::SVector)\nW <: Stage: evaluate(::MyCon, x, u)\nW <: Dynamical: evaluate(::MyCon, x′, x, u)\nW <: Coupled: evaluate(::MyCon, x′, u′ x, u)\n\nOr alternatively,\n\nW <: Stage: evaluate(::MyCon, z::KnotPoint)\nW <: Coupled: evaluate(::MyCon, z′::KnotPoint, z::KnotPoint)\n\nThe Jacobian method for State or Control is optional, since it will \tbe automatically computed using ForwardDiff. Automatic differentiation \tfor other types of constraints is not yet supported.\n\nFor W <: State, control_dim(::MyCon) doesn't need to be defined. Equivalently, for \tW <: Control, state_dim(::MyCon) doesn't need to be defined.\n\nFor W <: General, the more general evaluate and jacobian methods must be used\n\nevaluate!(vals::Vector{<:AbstractVector}, ::MyCon, Z::Traj, inds=1:length(Z)-1)\njacobian!(∇c::Vector{<:AbstractMatrix}, ::MyCon, Z::Traj, inds=1:length(Z)-1)\n\nThese methods can be specified for any constraint, instead of the not-in-place functions \tabove.\n\n\n\n\n\n","category":"type"},{"location":"constraints.html#TrajectoryOptimization.ConstraintSense","page":"3. Creating Constraints","title":"TrajectoryOptimization.ConstraintSense","text":"Specifies whether the constraint is an equality or inequality constraint. Valid subtypes are Equality, Inequality, and Null\n\n\n\n\n\n","category":"type"},{"location":"constraints.html#TrajectoryOptimization.ConstraintType","page":"3. Creating Constraints","title":"TrajectoryOptimization.ConstraintType","text":"Specifies the ``bandedness'' of the constraint. This ends up being the width of the constraint Jacobian, or the total number of input variables. This is important to reduce the size of arrays needed to store the Jacobian, as well as special-case the block matrix algebra.\n\nCurrent subtypes:\n\nStage\nState <: Stage\nControl <: Stage\nCoupled\nDynamical <: Coupled\nCoupledState <: Coupled\nCoupledControl <: Coupled\nGeneral\nGeneralState <: General\nGeneralControl <: General\n\n\n\n\n\n","category":"type"},{"location":"constraints.html#Methods-1","page":"3. Creating Constraints","title":"Methods","text":"","category":"section"},{"location":"constraints.html#","page":"3. Creating Constraints","title":"3. Creating Constraints","text":"The following methods are defined for all AbstractConstraints","category":"page"},{"location":"constraints.html#","page":"3. Creating Constraints","title":"3. Creating Constraints","text":"state_dims\ncontrol_dims\nevaluate!\njacobian!\ncontype\nsense\nwidth\nupper_bound\nlower_bound\nis_bound\ncheck_dims","category":"page"},{"location":"constraints.html#TrajectoryOptimization.state_dims","page":"3. Creating Constraints","title":"TrajectoryOptimization.state_dims","text":"Size of control vector\n\n\n\n\n\n","category":"function"},{"location":"constraints.html#TrajectoryOptimization.control_dims","page":"3. Creating Constraints","title":"TrajectoryOptimization.control_dims","text":"Size of state vector\n\n\n\n\n\n","category":"function"},{"location":"constraints.html#TrajectoryOptimization.evaluate!","page":"3. Creating Constraints","title":"TrajectoryOptimization.evaluate!","text":"evaluate!(vals::Vector{<:AbstractVector}, con::AbstractConstraint{S,W,P},\n\tZ, inds=1:length(Z)-1)\n\nEvaluate constraints for entire trajectory. This is the most general method used to evaluate \tconstraints, and should be the one used in other functions.\n\nFor W<:Stage this will loop over calls to evaluate(con,Z[k])\n\nFor W<:Coupled this will loop over calls to evaluate(con,Z[k+1],Z[k])\n\nFor W<:General,this must function must be explicitly defined. Other types may define it \tif desired.\n\n\n\n\n\nevaluate!(conSet::ConstraintSet, Z::Traj)\n\nCompute constraint values for all constraints for the entire trajectory\n\n\n\n\n\n","category":"function"},{"location":"constraints.html#TrajectoryOptimization.jacobian!","page":"3. Creating Constraints","title":"TrajectoryOptimization.jacobian!","text":"jacobian!(vals::Vector{<:AbstractVector}, con::AbstractConstraint{S,W,P},\n\tZ, inds=1:length(Z)-1)\n\nEvaluate constraint Jacobians for entire trajectory. This is the most general method used to \tevaluate constraint Jacobians, and should be the one used in other functions.\n\nFor W<:Stage this will loop over calls to jacobian(con,Z[k])\n\nFor W<:Coupled this will loop over calls to jacobian(con,Z[k+1],Z[k])\n\nFor W<:General,this must function must be explicitly defined. Other types may define it \tif desired.\n\n\n\n\n\njacobian!(conSet::ConstraintSet, Z::Traj)\n\nCompute constraint Jacobians for all constraints for the entire trajectory\n\n\n\n\n\n","category":"function"},{"location":"constraints.html#TrajectoryOptimization.contype","page":"3. Creating Constraints","title":"TrajectoryOptimization.contype","text":"Get type of constraint (bandedness)\n\n\n\n\n\n","category":"function"},{"location":"constraints.html#TrajectoryOptimization.sense","page":"3. Creating Constraints","title":"TrajectoryOptimization.sense","text":"Get constraint sense (Inequality vs Equality)\n\n\n\n\n\n","category":"function"},{"location":"constraints.html#TrajectoryOptimization.width","page":"3. Creating Constraints","title":"TrajectoryOptimization.width","text":"Returns the width of the constraint Jacobian, i.e. the total number of inputs to the constraint\n\n\n\n\n\n","category":"function"},{"location":"constraints.html#TrajectoryOptimization.upper_bound","page":"3. Creating Constraints","title":"TrajectoryOptimization.upper_bound","text":"Upper bound of the constraint, as a vector, which is 0 for all constraints (except bound constraints)\n\n\n\n\n\n","category":"function"},{"location":"constraints.html#TrajectoryOptimization.lower_bound","page":"3. Creating Constraints","title":"TrajectoryOptimization.lower_bound","text":"Upper bound of the constraint, as a vector, which is 0 equality and -Inf for inequality (except bound constraints)\n\n\n\n\n\n","category":"function"},{"location":"constraints.html#TrajectoryOptimization.is_bound","page":"3. Creating Constraints","title":"TrajectoryOptimization.is_bound","text":"Is the constraint a bound constraint or not\n\n\n\n\n\n","category":"function"},{"location":"constraints.html#TrajectoryOptimization.check_dims","page":"3. Creating Constraints","title":"TrajectoryOptimization.check_dims","text":"Check whether the constraint is consistent with the specified state and control dimensions\n\n\n\n\n\n","category":"function"},{"location":"constraints.html#Adding-a-New-Constraint-1","page":"3. Creating Constraints","title":"Adding a New Constraint","text":"","category":"section"},{"location":"constraints.html#","page":"3. Creating Constraints","title":"3. Creating Constraints","text":"See interface description in documentation for AbstractConstraint. The interface allows for a lot of flexibility, but let's do a simple example. Let's say we have a 2-norm constraint on the controls at each time step, e.g. u leq a. We can do this with just a few lines of code:","category":"page"},{"location":"constraints.html#","page":"3. Creating Constraints","title":"3. Creating Constraints","text":"struct ControlNorm{T} <: AbstractConstraint{Inequality,Control,1}\n  m::Int\n  a::T\nend\ncontrol_dim(con::ControlNorm) = con.m\nevaluate(con::ControlNorm, u::SVector) = @SVector [norm(u) - con.a] # needs to be a vector output\njacobian(con::ControlNorm, u::SVector) = u'/norm(u)  # optional","category":"page"},{"location":"constraints.html#","page":"3. Creating Constraints","title":"3. Creating Constraints","text":"Importantly, note that the inheritance specifies the constraint applies only to individual controls, the constraint in an inequality, and has dimension 1.","category":"page"},{"location":"constraints.html#","page":"3. Creating Constraints","title":"3. Creating Constraints","text":"Let's say the bound a varied by time-step. We could handle this easily by instead defining the methods operating on the entire trajectory:","category":"page"},{"location":"constraints.html#","page":"3. Creating Constraints","title":"3. Creating Constraints","text":"struct ControlNorm2{T} <: AbstractConstraint{Inequality,Control,1}\n  m::Int\n  a::Vector{T}\nend\ncontrol_dim(con::ControlNorm) = con.m\nfunction evaluate!(vals::Vector{<:AbstractVector}, con::ControlNorm,\n    Z, inds=1:length(Z)-1)\n  for (i,k) in enumerate(inds)\n    u = control(Z[k])\n    vals[i] = @SVector [norm(u) - con.a[k]]\n  end\nend\nfunction jacobian!(∇c::Vector{<:AbstractMatrix}, con::ControlNorm,\n    Z, inds=1:length(Z)-1)\n  for (i,k) in enumerate(inds)\n    u = control(Z[k])\n    ∇c[i] = u'/norm(u)\n  end\nend","category":"page"},{"location":"constraints.html#API-1","page":"3. Creating Constraints","title":"API","text":"","category":"section"},{"location":"constraints.html#","page":"3. Creating Constraints","title":"3. Creating Constraints","text":"ConstraintVals\nStage\nState\nControl\nCoupled\nDynamical\nCoupledState\nCoupledControl\nGeneral\nGeneralState\nGeneralControl","category":"page"},{"location":"constraints.html#TrajectoryOptimization.ConstraintVals","page":"3. Creating Constraints","title":"TrajectoryOptimization.ConstraintVals","text":"struct ConstraintVals{T, W, C, P, NM, PNM}\n\nStruct that stores all of the values associated with a particular constraint. Importantly, ConstraintVals stores the list of knotpoints to which the constraint is applied. This type should be fairly transparent to the user, and only needs to be directly dealt with when writing solvers or setting fine-tuned updates per constraint (via the .params field).\n\n\n\n\n\n","category":"type"},{"location":"constraints.html#TrajectoryOptimization.Stage","page":"3. Creating Constraints","title":"TrajectoryOptimization.Stage","text":"Only a function of states and controls at a single knotpoint\n\n\n\n\n\n","category":"type"},{"location":"constraints.html#TrajectoryOptimization.State","page":"3. Creating Constraints","title":"TrajectoryOptimization.State","text":"Only a function of states at a single knotpoint\n\n\n\n\n\n","category":"type"},{"location":"constraints.html#TrajectoryOptimization.Control","page":"3. Creating Constraints","title":"TrajectoryOptimization.Control","text":"Only a function of controls at a single knotpoint\n\n\n\n\n\n","category":"type"},{"location":"constraints.html#TrajectoryOptimization.Coupled","page":"3. Creating Constraints","title":"TrajectoryOptimization.Coupled","text":"Only a function of states and controls at two adjacent knotpoints\n\n\n\n\n\n","category":"type"},{"location":"constraints.html#TrajectoryOptimization.Dynamical","page":"3. Creating Constraints","title":"TrajectoryOptimization.Dynamical","text":"Only a function of states and two adjacent knotpoints, and the control at the previous knotpoint, i.e. f(x,u) - x′\n\n\n\n\n\n","category":"type"},{"location":"constraints.html#TrajectoryOptimization.CoupledState","page":"3. Creating Constraints","title":"TrajectoryOptimization.CoupledState","text":"Only a function of states at adjacent knotpoints\n\n\n\n\n\n","category":"type"},{"location":"constraints.html#TrajectoryOptimization.CoupledControl","page":"3. Creating Constraints","title":"TrajectoryOptimization.CoupledControl","text":"Only a function of controls at adjacent knotpoints\n\n\n\n\n\n","category":"type"},{"location":"constraints.html#TrajectoryOptimization.General","page":"3. Creating Constraints","title":"TrajectoryOptimization.General","text":"A function of all states and controls in the trajectory\n\n\n\n\n\n","category":"type"},{"location":"constraints.html#TrajectoryOptimization.GeneralState","page":"3. Creating Constraints","title":"TrajectoryOptimization.GeneralState","text":"A function of all states in the trajectory\n\n\n\n\n\n","category":"type"},{"location":"constraints.html#TrajectoryOptimization.GeneralControl","page":"3. Creating Constraints","title":"TrajectoryOptimization.GeneralControl","text":"A function of all controls in the trajectory\n\n\n\n\n\n","category":"type"},{"location":"models.html#model_section-1","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"","category":"section"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"CurrentModule = TrajectoryOptimization","category":"page"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"Pages = [\"models.md\"]","category":"page"},{"location":"models.html#Overview-1","page":"1. Setting up a Dynamics Model","title":"Overview","text":"","category":"section"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"The Model type holds information about the dynamics of the system. All dynamics are assumed to be state-space models of the system of the form dotx = f(xu) where dotx is the state derivative, x an n-dimensional state vector, and u in an m-dimensional control input vector. The function f can be any nonlinear function.","category":"page"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"TrajectoryOptimization.jl solves the trajectory optimization problem by discretizing the state and control trajectories, which requires discretizing the dynamics, i.e., turning the continuous time differential equation into a discrete time difference equation of the form xk+1 = f(xkuk), where k is the time step. There many methods of performing this discretization, and TrajectoryOptimization.jl offers several of the most common methods. See Model Discretization section for more information on discretizing dynamics, as well as how to define custom integration methods.","category":"page"},{"location":"models.html#Creating-a-New-Model-1","page":"1. Setting up a Dynamics Model","title":"Creating a New Model","text":"","category":"section"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"To create a new model of a dynamical system, you need to define a new type that inherits from AbstractModel. You will need to then define only a few methods on your type. Let's say we want to create a model of the canonical cartpole. We start by defining our type:","category":"page"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"struct Cartpole{T} <: AbstractModel\n    mc::T  # mass of the cart\n    mp::T  # mass of the pole\n    l::T   # length of the pole\n    g::T   # gravity\nend","category":"page"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"It's often convenient to store any model parameters inside the new type (make sure they're concrete types!). If you need to store vectors or matrices, we highly recommend using StaticArrays, which are extremely fast and avoid memory allocations. For models with lots of parameters, we recommend Parameters.jl that makes it easy to specify default parameters.","category":"page"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"We now just need to define two functions to complete the interface","category":"page"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"import TrajectoryOptimization: dynamics  # the dynamics function must be imported\n\nfunction dynamics(model::Cartpole, x, u)\n    mc = model.mc  # mass of the cart in kg (10)\n    mp = model.mp   # mass of the pole (point mass at the end) in kg\n    l = model.l   # length of the pole in m\n    g = model.g  # gravity m/s^2\n\n    q = x[ @SVector [1,2] ]\n    qd = x[ @SVector [3,4] ]\n\n    s = sin(q[2])\n    c = cos(q[2])\n\n    H = @SMatrix [mc+mp mp*l*c; mp*l*c mp*l^2]\n    C = @SMatrix [0 -mp*qd[2]*l*s; 0 0]\n    G = @SVector [0, mp*g*l*s]\n    B = @SVector [1, 0]\n\n    qdd = -H\\(C*qd + G - B*u[1])\n    return [qd; qdd]\nend\n\nBase.size(::Cartpole) = 4,1","category":"page"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"And voila! we have a new model.","category":"page"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"We now have a few methods automatically available to us:","category":"page"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"dynamics\njacobian","category":"page"},{"location":"models.html#TrajectoryOptimization.dynamics","page":"1. Setting up a Dynamics Model","title":"TrajectoryOptimization.dynamics","text":"ẋ = dynamics(model, z::KnotPoint)\n\nCompute the continuous dynamics of a dynamical system given a KnotPoint\n\n\n\n\n\n","category":"function"},{"location":"models.html#TrajectoryOptimization.jacobian","page":"1. Setting up a Dynamics Model","title":"TrajectoryOptimization.jacobian","text":"∇f = jacobian(model, z::KnotPoint)\n∇f = jacobian(model, z::SVector)\n\nCompute the Jacobian of the continuous-time dynamics using ForwardDiff. The input can be either a static vector of the concatenated state and control, or a KnotPoint. They must be concatenated to avoid unnecessary memory allocations.\n\n\n\n\n\n","category":"function"},{"location":"models.html#Time-varying-systems-(experimental)-1","page":"1. Setting up a Dynamics Model","title":"Time-varying systems (experimental)","text":"","category":"section"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"TrajectoryOptimization.jl also offers experimental support for time-varying systems. Let's say for some reason the mass of our cartpole is decreasing linearly with time. We can model this with a slight modification to the dynamics function signature:","category":"page"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"import TrajectoryOptimization: dynamics\n\nstruct CartpoleTimeVarying{T} <: AbstractModel\n    mc::T  # initial mass of the cart\n    mp::T  # mass of the pole\n    l::T   # length of the pole\n    g::T   # gravity\nend\n\nfunction dynamics(model::CartpoleTimeVarying, x, u, t)  # note extra time parameter\n    mc = model.mc  # mass of the cart in kg (10)\n    mp = model.mp   # mass of the pole (point mass at the end) in kg\n    l = model.l   # length of the pole in m\n    g = model.g  # gravity m/s^2\n\n    # Change the mass of the cart with time\n    mc = mc - 0.01*t\n\n    q = x[ @SVector [1,2] ]\n    qd = x[ @SVector [3,4] ]\n\n    s = sin(q[2])\n    c = cos(q[2])\n\n    H = @SMatrix [mc+mp mp*l*c; mp*l*c mp*l^2]\n    C = @SMatrix [0 -mp*qd[2]*l*s; 0 0]\n    G = @SVector [0, mp*g*l*s]\n    B = @SVector [1, 0]\n\n    qdd = -H\\(C*qd + G - B*u[1])\n    return [qd; qdd]\nend\n\nBase.size(::CartpoleTimeVarying) = 4,1","category":"page"},{"location":"models.html#Models-with-3D-Rotations-(experimental)-1","page":"1. Setting up a Dynamics Model","title":"Models with 3D Rotations (experimental)","text":"","category":"section"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"TrajectoryOptimization.jl offers experimental support for models with non-Euclidean state vectors, such as 3D rotations, which live in SO(3) instead of mathbb^4. See RigidBody section for more details.","category":"page"},{"location":"solvers.html#solver_section-1","page":"5. Pick a solver","title":"5. Pick a solver","text":"","category":"section"},{"location":"solvers.html#","page":"5. Pick a solver","title":"5. Pick a solver","text":"CurrentModule = TrajectoryOptimization","category":"page"},{"location":"solvers.html#","page":"5. Pick a solver","title":"5. Pick a solver","text":"Pages = [\"solvers.md\"]","category":"page"},{"location":"solvers.html#Creating-a-solver-1","page":"5. Pick a solver","title":"Creating a solver","text":"","category":"section"},{"location":"solvers.html#","page":"5. Pick a solver","title":"5. Pick a solver","text":"Any of the following solvers can be created using the following method:","category":"page"},{"location":"solvers.html#","page":"5. Pick a solver","title":"5. Pick a solver","text":"AbstractSolver(prob::Problem, opts::AbstractSolverOptions)","category":"page"},{"location":"solvers.html#","page":"5. Pick a solver","title":"5. Pick a solver","text":"where the opts argument is the solver options for the desired solver. You can also call the solver constructor directly with the same arguments as above, e.g.","category":"page"},{"location":"solvers.html#","page":"5. Pick a solver","title":"5. Pick a solver","text":"iLQRSolver(prob::Problem, opts::iLQRSolverOptions)","category":"page"},{"location":"solvers.html#","page":"5. Pick a solver","title":"5. Pick a solver","text":"If the solver type is known beforehand, it is recommended to use the specific constructor rather than the AbstractSolver constructor, for clarity. In this case, the options argument is optional. The first is provided simply for generality and easy multiple dispatch.","category":"page"},{"location":"solvers.html#","page":"5. Pick a solver","title":"5. Pick a solver","text":"All of the solver options types currently implemented use Parameters.jl, so can be initialized with the default constructor <opts::AbstractSolverOptions>(), e.g. iLQRSolverOptions(). The options can be set as keyword options in the constructor or specified afterwards.","category":"page"},{"location":"solvers.html#Solver-Interface-1","page":"5. Pick a solver","title":"Solver Interface","text":"","category":"section"},{"location":"solvers.html#","page":"5. Pick a solver","title":"5. Pick a solver","text":"Solvers are currently organized into the following type tree:","category":"page"},{"location":"solvers.html#","page":"5. Pick a solver","title":"5. Pick a solver","text":"AbstractSolver\nUnconstrainedSolver\nConstrainedSolver\nDirectSolver","category":"page"},{"location":"solvers.html#","page":"5. Pick a solver","title":"5. Pick a solver","text":"For creating a new solver, e.g. NewSolver, the user must define two new types:","category":"page"},{"location":"solvers.html#","page":"5. Pick a solver","title":"5. Pick a solver","text":"NewSolverOptions{T} <: AbstractSolverOptions{T}\nNewSolver{T} <: AbstractSolver{T}","category":"page"},{"location":"solvers.html#","page":"5. Pick a solver","title":"5. Pick a solver","text":"The solver options type is a lightweight container for all of the options the user can specify, such as tolerance values, printing verbosity (highly recommended), Boolean flags, etc. We highly suggest using Parameters.jl to create this and easily specify the default options. All solver options should be mutable (e.g. mutable struct NewSolverOptions{T} <: AbstractSolverOptions{T})","category":"page"},{"location":"solvers.html#","page":"5. Pick a solver","title":"5. Pick a solver","text":"The solver type, on the other hand, is meant to contain all of the variables needed for the solve, including the model, objective, constraints, and other information originally in the Problem. This information is \"duplicated\" in the solver since oftentimes the solver with perform modifications to these when setting up the solve. For example, the AugmentedLagrangianSolver creates an ALObjective and uses that as it's objective instead. Similarly, ALTRO may convert the model to an InfeasibleModel to leverage an initial state trajectory. Therefore, once the solver is created, the problem is solved by simply calling solve!(solver), which then runs the optimization.","category":"page"},{"location":"solvers.html#","page":"5. Pick a solver","title":"5. Pick a solver","text":"The interfaces for the abstract solvers are described below:","category":"page"},{"location":"solvers.html#Unconstrained-Solvers-1","page":"5. Pick a solver","title":"Unconstrained Solvers","text":"","category":"section"},{"location":"solvers.html#","page":"5. Pick a solver","title":"5. Pick a solver","text":"AbstractSolver\nUnconstrainedSolver\nstates\ncontrols\ninitial_trajectory!\ninitial_states!\ninitial_controls!\ncost\ncost_expansion!","category":"page"},{"location":"solvers.html#TrajectoryOptimization.AbstractSolver","page":"5. Pick a solver","title":"TrajectoryOptimization.AbstractSolver","text":"abstract type AbstractSolver <: MathOptInterface.AbstractNLPEvaluator\n\nAbstract solver for trajectory optimization problems\n\nAny type that inherits from AbstractSolver must define the following methods:\n\nmodel = get_model(::AbstractSolver)::AbstractModel\nobj = get_objective(::AbstractSolver)::AbstractObjective\nZ = get_trajectory(::AbstractSolver)::Traj\nn,m,N = Base.size(::AbstractSolver)\nx0 = get_initial_state(::AbstractSolver)::SVector\nsolve!(::AbstractSolver)\n\n\n\n\n\n","category":"type"},{"location":"solvers.html#TrajectoryOptimization.UnconstrainedSolver","page":"5. Pick a solver","title":"TrajectoryOptimization.UnconstrainedSolver","text":"abstract type UnconstrainedSolver <: TrajectoryOptimization.AbstractSolver{T}\n\nUnconstrained optimization solver. Will ignore any constraints in the problem\n\n\n\n\n\n","category":"type"},{"location":"solvers.html#TrajectoryOptimization.states","page":"5. Pick a solver","title":"TrajectoryOptimization.states","text":"states(::Problem)\nstates(::AbstractSolver)\nstates(::Traj)\nGet the state trajectory\n\n\n\n\n\n","category":"function"},{"location":"solvers.html#TrajectoryOptimization.controls","page":"5. Pick a solver","title":"TrajectoryOptimization.controls","text":"controls(::Problem)\ncontrols(::AbstractSolver)\ncontrols(::Traj)\nGet the control trajectory\n\n\n\n\n\n","category":"function"},{"location":"solvers.html#TrajectoryOptimization.initial_trajectory!","page":"5. Pick a solver","title":"TrajectoryOptimization.initial_trajectory!","text":"initial_trajectory!(::Problem, Z)\ninitial_trajectory!(::AbstractSolver, Z)\n\nCopy the trajectory \n\n\n\n\n\n","category":"function"},{"location":"solvers.html#TrajectoryOptimization.cost_expansion!","page":"5. Pick a solver","title":"TrajectoryOptimization.cost_expansion!","text":"cost_expansion!(E::Any, obj::Objective, Z::AbstractArray{#s29,1} where #s29<:KnotPoint)\n\n\nExpand cost for entire trajectory\n\n\n\n\n\n","category":"function"},{"location":"solvers.html#Constrained-Solvers-1","page":"5. Pick a solver","title":"Constrained Solvers","text":"","category":"section"},{"location":"solvers.html#","page":"5. Pick a solver","title":"5. Pick a solver","text":"ConstrainedSolver\nupdate_constraints!\nupdate_active_set!\nconstraint_jacobian!","category":"page"},{"location":"solvers.html#TrajectoryOptimization.ConstrainedSolver","page":"5. Pick a solver","title":"TrajectoryOptimization.ConstrainedSolver","text":"abstract type ConstrainedSolver <: TrajectoryOptimization.AbstractSolver{T}\n\nAbstract solver for constrained trajectory optimization problems\n\nIn addition to the methods required for AbstractSolver, all ConstrainedSolvers     must define the following method\n\nget_constraints(::ConstrainedSolver)::ConstrainSet\n\n\n\n\n\n","category":"type"},{"location":"solvers.html#TrajectoryOptimization.update_active_set!","page":"5. Pick a solver","title":"TrajectoryOptimization.update_active_set!","text":"update_active_set!(conSet::ConstraintSet, Z::Traj, ::Val{tol})\n\nCompute the active set for the current constraint values, with tolerance tol. \tUses a value type to avoid an allocation down the line.\n\n\n\n\n\n","category":"function"},{"location":"solvers.html#Direct-Solvers-1","page":"5. Pick a solver","title":"Direct Solvers","text":"","category":"section"},{"location":"solvers.html#","page":"5. Pick a solver","title":"5. Pick a solver","text":"Direct solvers often perform similar operations, so the following methods are provided that should work with any direct solver","category":"page"},{"location":"solvers.html#","page":"5. Pick a solver","title":"5. Pick a solver","text":"remove_bounds!\nremove_constraint_type!\nget_bounds\nadd_dynamics_constraints!\ngen_con_inds\nconstraint_jacobian_structure\ncopy_constraints!\ncopy_active_set!\ncopy_jacobian!\ncopy_jacobians!","category":"page"},{"location":"solvers.html#TrajectoryOptimization.remove_bounds!","page":"5. Pick a solver","title":"TrajectoryOptimization.remove_bounds!","text":"remove_bounds!(conSet)\n\n\nRemove bounds constraints from constraint set\n\n\n\n\n\n","category":"function"},{"location":"solvers.html#TrajectoryOptimization.remove_constraint_type!","page":"5. Pick a solver","title":"TrajectoryOptimization.remove_constraint_type!","text":"remove_constraint_type!(conSet, ?)\n\n\nRemove a type of constraint from constraint set\n\n\n\n\n\n","category":"function"},{"location":"solvers.html#TrajectoryOptimization.get_bounds","page":"5. Pick a solver","title":"TrajectoryOptimization.get_bounds","text":"get_bounds(conSet)\n\n\nRemove bounds from constraint set and return them as vectors\n\n\n\n\n\n","category":"function"},{"location":"solvers.html#TrajectoryOptimization.add_dynamics_constraints!","page":"5. Pick a solver","title":"TrajectoryOptimization.add_dynamics_constraints!","text":"add_dynamics_constraints!(prob::Problem)\n\nAdd dynamics constraints to the constraint set\n\n\n\n\n\n","category":"function"},{"location":"solvers.html#TrajectoryOptimization.gen_con_inds","page":"5. Pick a solver","title":"TrajectoryOptimization.gen_con_inds","text":"gen_con_inds(conSet)\ngen_con_inds(conSet, structure)\n\n\nGenerate the indices into the concatenated constraint vector for each constraint. Determines the bandedness of the Jacobian\n\n\n\n\n\n","category":"function"},{"location":"solvers.html#TrajectoryOptimization.constraint_jacobian_structure","page":"5. Pick a solver","title":"TrajectoryOptimization.constraint_jacobian_structure","text":"constraint_jacobian_structure(solver)\nconstraint_jacobian_structure(solver, structure)\n\n\nGet the constraint Jacobian structure as a sparse array, and fill in the linear indices used for filling a vector of the non-zero elements of the Jacobian\n\n\n\n\n\n","category":"function"},{"location":"solvers.html#TrajectoryOptimization.copy_constraints!","page":"5. Pick a solver","title":"TrajectoryOptimization.copy_constraints!","text":"Copy constraints to a single concatenated vector\n\n\n\n\n\n","category":"function"},{"location":"solvers.html#TrajectoryOptimization.copy_active_set!","page":"5. Pick a solver","title":"TrajectoryOptimization.copy_active_set!","text":"Copy active set to a single concatenated vector\n\n\n\n\n\n","category":"function"},{"location":"solvers.html#TrajectoryOptimization.copy_jacobian!","page":"5. Pick a solver","title":"TrajectoryOptimization.copy_jacobian!","text":"Copy constraint Jacobians to given indices in a sparse array Dispatches on bandedness of the constraint\n\n\n\n\n\nCopy constraint Jacobians to linear indices of a vector\n\n\n\n\n\n","category":"function"},{"location":"solvers.html#TrajectoryOptimization.copy_jacobians!","page":"5. Pick a solver","title":"TrajectoryOptimization.copy_jacobians!","text":"Copy all constraint Jacobians to a sparse matrix\n\n\n\n\n\nCopy all constraint Jacobians to linear indices of a vector\n\n\n\n\n\n","category":"function"},{"location":"solvers.html#","page":"5. Pick a solver","title":"5. Pick a solver","text":"The solver must also contain the following fields:","category":"page"},{"location":"solvers.html#","page":"5. Pick a solver","title":"5. Pick a solver","text":"opts: Solver options for the solver (e.g. opts::NewSolverOptions)\nstats::Dict{Symbol,Any}: Dictionary containing pertinent statistics for the solve, such as run time, final max constraint violation, final cost, optimality criteria, number of iterations, etc.","category":"page"},{"location":"solvers.html#Implemented-Solvers-1","page":"5. Pick a solver","title":"Implemented Solvers","text":"","category":"section"},{"location":"solvers.html#Iterative-LQR-(iLQR)-1","page":"5. Pick a solver","title":"Iterative LQR (iLQR)","text":"","category":"section"},{"location":"solvers.html#","page":"5. Pick a solver","title":"5. Pick a solver","text":"iLQRSolver\niLQRSolverOptions","category":"page"},{"location":"solvers.html#TrajectoryOptimization.iLQRSolver","page":"5. Pick a solver","title":"TrajectoryOptimization.iLQRSolver","text":"struct iLQRSolver{T, I<:QuadratureRule, L, O, n, n̄, m, L1, L2, D, F, E1, E2} <: TrajectoryOptimization.UnconstrainedSolver{T}\n\niLQR is an unconstrained indirect method for trajectory optimization that parameterizes only the controls and enforces strict dynamics feasibility at every iteration by simulating forward the dynamics with an LQR feedback controller. The main algorithm consists of two parts:\n\na backward pass that uses Differential Dynamic Programming to compute recursively a quadratic approximation of the cost-to-go, along with linear feedback and feed-forward gain matrices, K and d, respectively, for an LQR tracking controller, and\na forward pass that uses the gains K and d to simulate forward the full nonlinear dynamics with feedback.\n\n\n\n\n\n","category":"type"},{"location":"solvers.html#TrajectoryOptimization.iLQRSolverOptions","page":"5. Pick a solver","title":"TrajectoryOptimization.iLQRSolverOptions","text":"mutable struct iLQRSolverOptions{T} <: TrajectoryOptimization.AbstractSolverOptions{T}\n\nSolver options for the iterative LQR (iLQR) solver.\n\nverbose\nPrint summary at each iteration. Default: false\nlive_plotting\nLive plotting. Default: :off\ncost_tolerance\ndJ < ϵ, cost convergence criteria for unconstrained solve or to enter outerloop for constrained solve. Default: 0.0001\ngradient_type\ngradient type: :todorov, :feedforward. Default: :todorov\ngradient_norm_tolerance\ngradient_norm < ϵ, gradient norm convergence criteria. Default: 1.0e-5\niterations\niLQR iterations. Default: 300\ndJ_counter_limit\nrestricts the total number of times a forward pass fails, resulting in regularization, before exiting. Default: 10\nsquare_root\nuse square root method backward pass for numerical conditioning. Default: false\nline_search_lower_bound\nforward pass approximate line search lower bound, 0 < linesearchlowerbound < linesearchupperbound. Default: 1.0e-8\nline_search_upper_bound\nforward pass approximate line search upper bound, 0 < linesearchlowerbound < linesearchupperbound < ∞. Default: 10.0\niterations_linesearch\nmaximum number of backtracking steps during forward pass line search. Default: 20\nbp_reg_initial\ninitial regularization. Default: 0.0\nbp_reg_increase_factor\nregularization scaling factor. Default: 1.6\nbp_reg_max\nmaximum regularization value. Default: 1.0e8\nbp_reg_min\nminimum regularization value. Default: 1.0e-8\nbp_reg_type\ntype of regularization- control: () + ρI, state: (S + ρI); see Synthesis and Stabilization of Complex Behaviors through Online Trajectory Optimization. Default: :control\nbp_reg_fp\nadditive regularization when forward pass reaches max iterations. Default: 10.0\nbp_sqrt_inv_type\ntype of matrix inversion for bp sqrt step. Default: :pseudo\nbp_reg_sqrt_initial\ninitial regularization for square root method. Default: 1.0e-6\nbp_reg_sqrt_increase_factor\nregularization scaling factor for square root method. Default: 10.0\nmax_cost_value\nmaximum cost value, if exceded solve will error. Default: 1.0e8\nmax_state_value\nmaximum state value, evaluated during rollout, if exceded solve will error. Default: 1.0e8\nmax_control_value\nmaximum control value, evaluated during rollout, if exceded solve will error. Default: 1.0e8\nlog_level\nDefault: InnerLoop\n\n\n\n\n\n","category":"type"},{"location":"solvers.html#","page":"5. Pick a solver","title":"5. Pick a solver","text":"AugmentedLagrangianSolver\nAugmentedLagrangianSolverOptions","category":"page"},{"location":"solvers.html#TrajectoryOptimization.AugmentedLagrangianSolver","page":"5. Pick a solver","title":"TrajectoryOptimization.AugmentedLagrangianSolver","text":"struct AugmentedLagrangianSolver <: TrajectoryOptimization.AbstractSolver{T}\n\nAugmented Lagrangian (AL) is a standard tool for constrained optimization. For a trajectory optimization problem of the form:\n\nbeginequation*\nbeginaligned\n  min_x_0Nu_0N-1 quad  ell_f(x_N) + sum_k=0^N-1 ell_k(x_k u_k dt) \n  textrmst            quad  x_k+1 = f(x_k u_k) \n                                  g_k(x_ku_k) leq 0 \n                                  h_k(x_ku_k) = 0\nendaligned\nendequation*\n\nAL methods form the following augmented Lagrangian function:\n\nbeginalign*\n    ell_f(x_N) + λ_N^T c_N(x_N) + c_N(x_N)^T I_mu_N c_N(x_N) \n            + sum_k=0^N-1 ell_k(x_ku_kdt) + λ_k^T c_k(x_ku_k) + c_k(x_ku_k)^T I_mu_k c_k(x_ku_k)\nendalign*\n\nThis function is then minimized with respect to the primal variables using any unconstrained minimization solver (e.g. iLQR).     After a local minima is found, the AL method updates the Lagrange multipliers λ and the penalty terms μ and repeats the unconstrained minimization.     AL methods have superlinear convergence as long as the penalty term μ is updated each iteration.\n\n\n\n\n\n","category":"type"},{"location":"solvers.html#TrajectoryOptimization.AugmentedLagrangianSolverOptions","page":"5. Pick a solver","title":"TrajectoryOptimization.AugmentedLagrangianSolverOptions","text":"mutable struct AugmentedLagrangianSolverOptions{T} <: TrajectoryOptimization.AbstractSolverOptions{T}\n\nSolver options for the augmented Lagrangian solver.\n\nverbose\nPrint summary at each iteration. Default: false\nopts_uncon\nunconstrained solver options. Default: iLQRSolverOptions{Float64}()\ncost_tolerance\ndJ < ϵ, cost convergence criteria for unconstrained solve or to enter outerloop for constrained solve. Default: 0.0001\ncost_tolerance_intermediate\ndJ < ϵ_int, intermediate cost convergence criteria to enter outerloop of constrained solve. Default: 0.001\ngradient_norm_tolerance\ngradient_norm < ϵ, gradient norm convergence criteria. Default: 1.0e-5\ngradient_norm_tolerance_intermediate\ngradientnormint < ϵ, gradient norm intermediate convergence criteria. Default: 1.0e-5\nconstraint_tolerance\nmax(constraint) < ϵ, constraint convergence criteria. Default: 0.001\nconstraint_tolerance_intermediate\nmax(constraint) < ϵ_int, intermediate constraint convergence criteria. Default: 0.001\niterations\nmaximum outerloop updates. Default: 30\ndual_max\nglobal maximum Lagrange multiplier. If NaN, use value from constraint Default: NaN\npenalty_max\nglobal maximum penalty term. If NaN, use value from constraint Default: NaN\npenalty_initial\nglobal initial penalty term. If NaN, use value from constraint Default: NaN\npenalty_scaling\nglobal penalty update multiplier; penalty_scaling > 1. If NaN, use value from constraint Default: NaN\npenalty_scaling_no\npenalty update multiplier when μ should not be update, typically 1.0 (or 1.0 + ϵ). Default: 1.0\nconstraint_decrease_ratio\nratio of current constraint to previous constraint violation; 0 < constraintdecreaseratio < 1. Default: 0.25\nouter_loop_update_type\ntype of outer loop update (default, feedback). Default: :default\nactive_constraint_tolerance\nnumerical tolerance for constraint violation. Default: 0.0\nkickout_max_penalty\nterminal solve when maximum penalty is reached. Default: false\nlog_level\nDefault: OuterLoop\n\n\n\n\n\n","category":"type"},{"location":"solvers.html#ALTRO-1","page":"5. Pick a solver","title":"ALTRO","text":"","category":"section"},{"location":"solvers.html#","page":"5. Pick a solver","title":"5. Pick a solver","text":"ALTROSolver\nALTROSolverOptions","category":"page"},{"location":"solvers.html#TrajectoryOptimization.ALTROSolver","page":"5. Pick a solver","title":"TrajectoryOptimization.ALTROSolver","text":"struct ALTROSolver{T} <: TrajectoryOptimization.ConstrainedSolver{T}\n\nAugmented Lagrangian Trajectory Optimizer (ALTRO) is a solver developed by the Robotic Exploration Lab at Stanford University.     The solver is special-cased to solve Markov Decision Processes by leveraging the internal problem structure.\n\nALTRO consists of two \"phases\":\n\nAL-iLQR: iLQR is used with an Augmented Lagrangian framework to solve the problem quickly to rough constraint satisfaction\nProjected Newton: A collocation-flavored active-set solver projects the solution from AL-iLQR onto the feasible subspace to achieve machine-precision constraint satisfaction.\n\n\n\n\n\n","category":"type"},{"location":"solvers.html#TrajectoryOptimization.ALTROSolverOptions","page":"5. Pick a solver","title":"TrajectoryOptimization.ALTROSolverOptions","text":"mutable struct ALTROSolverOptions{T} <: TrajectoryOptimization.AbstractSolverOptions{T}\n\nSolver options for the ALTRO solver.\n\nverbose\nDefault: false\nopts_al\nAugmented Lagrangian solver options. Default: AugmentedLagrangianSolverOptions{Float64}()\nconstraint_tolerance\nconstraint tolerance Default: 1.0e-5\ninfeasible\nUse infeasible model (augment controls to make it fully actuated) Default: false\nR_inf\nregularization term for infeasible controls. Default: 1.0\ndynamically_feasible_projection\nproject infeasible results to feasible space using TVLQR. Default: true\nresolve_feasible_problem\nresolve feasible problem after infeasible solve. Default: true\npenalty_initial_infeasible\ninitial penalty term for infeasible controls. Default: 1.0\npenalty_scaling_infeasible\npenalty update rate for infeasible controls. Default: 10.0\nprojected_newton\nfinish with a projecte newton solve. Default: true\nopts_pn\noptions for projected newton solver. Default: ProjectedNewtonSolverOptions{Float64}()\nprojected_newton_tolerance\nconstraint satisfaction tolerance that triggers the projected newton solver.     If set to a non-positive number it will kick out when the maximum penalty is reached. Default: 0.001\n\n\n\n\n\n","category":"type"},{"location":"solvers.html#Direct-Collocation-(DIRCOL)-1","page":"5. Pick a solver","title":"Direct Collocation (DIRCOL)","text":"","category":"section"},{"location":"solvers.html#","page":"5. Pick a solver","title":"5. Pick a solver","text":"DIRCOLSolver\nDIRCOLSolverOptions","category":"page"},{"location":"solvers.html#TrajectoryOptimization.DIRCOLSolver","page":"5. Pick a solver","title":"TrajectoryOptimization.DIRCOLSolver","text":"struct DIRCOLSolver{Q<:QuadratureRule, L, T, N, M, NM} <: TrajectoryOptimization.DirectSolver{T}\n\nDirect Collocation Solver. Uses a commerical NLP solver to solve the Trajectory Optimization problem. Uses the MathOptInterface to interface with the NLP.\n\n\n\n\n\n","category":"type"},{"location":"solvers.html#TrajectoryOptimization.DIRCOLSolverOptions","page":"5. Pick a solver","title":"TrajectoryOptimization.DIRCOLSolverOptions","text":"mutable struct DIRCOLSolverOptions{T} <: TrajectoryOptimization.DirectSolverOptions{T}\n\nSolver options for the Direct Collocation solver. Most options are passed to the NLP through the opts dictionary\n\nnlp\nNLP Solver to use. See MathOptInterface for available NLP solvers Default: Ipopt.Optimizer()\nopts\nOptions dictionary for the nlp solver Default: Dict{Symbol, Any}()\nverbose\nPrint output to console Default: true\nfeasibility_tolerance\nFeasibility tolerance Default: -1.0\n\n\n\n\n\n","category":"type"},{"location":"solvers.html#Projected-Newton-1","page":"5. Pick a solver","title":"Projected Newton","text":"","category":"section"},{"location":"solvers.html#","page":"5. Pick a solver","title":"5. Pick a solver","text":"ProjectedNewtonSolver\nProjectedNewtonSolverOptions","category":"page"},{"location":"solvers.html#TrajectoryOptimization.ProjectedNewtonSolver","page":"5. Pick a solver","title":"TrajectoryOptimization.ProjectedNewtonSolver","text":"struct ProjectedNewtonSolver{T, N, M, NM} <: TrajectoryOptimization.DirectSolver{T}\n\nProjected Newton Solver Direct method developed by the REx Lab at Stanford University Achieves machine-level constraint satisfaction by projecting onto the feasible subspace.     It can also take a full Newton step by solving the KKT system. This solver is to be used exlusively for solutions that are close to the optimal solution.     It is intended to be used as a \"solution polishing\" method for augmented Lagrangian methods.\n\n\n\n\n\n","category":"type"},{"location":"solvers.html#TrajectoryOptimization.ProjectedNewtonSolverOptions","page":"5. Pick a solver","title":"TrajectoryOptimization.ProjectedNewtonSolverOptions","text":"mutable struct ProjectedNewtonSolverOptions{T} <: TrajectoryOptimization.DirectSolverOptions{T}\n\nSolver options for the Projected Newton solver.\n\nverbose\nDefault: true\nn_steps\nDefault: 1\nsolve_type\nDefault: :feasible\nactive_set_tolerance\nDefault: 0.001\nfeasibility_tolerance\nDefault: 1.0e-6\nρ\nDefault: 0.01\nr_threshold\nDefault: 1.1\n\n\n\n\n\n","category":"type"},{"location":"discretization.html#Discretizaation-1","page":"Discretizaation","title":"Discretizaation","text":"","category":"section"},{"location":"discretization.html#","page":"Discretizaation","title":"Discretizaation","text":"This page gives details on the methods for evaluating discretized dynamics, as well as instructions on how to define a custom integration method.","category":"page"},{"location":"discretization.html#Model-Discretization-1","page":"Discretizaation","title":"Model Discretization","text":"","category":"section"},{"location":"discretization.html#","page":"Discretizaation","title":"Discretizaation","text":"With a model defined, we can compute the discrete dynamics and discrete dynamics Jacobians for an Implicit integration rule with the following methods","category":"page"},{"location":"discretization.html#","page":"Discretizaation","title":"Discretizaation","text":"discrete_dynamics\ndiscrete_jacobian","category":"page"},{"location":"discretization.html#TrajectoryOptimization.discrete_dynamics","page":"Discretizaation","title":"TrajectoryOptimization.discrete_dynamics","text":"Compute the discretized dynamics of model using implicit integration scheme Q<:QuadratureRule.\n\nMethods:\n\nx′ = discrete_dynamics(model, model, z)  # uses RK3 as the default integration scheme\nx′ = discrete_dynamics(Q, model, x, u, t, dt)\nx′ = discrete_dynamics(Q, model, z::KnotPoint)\n\nThe default integration scheme is stored in TrajectoryOptimization.DEFAULT_Q\n\n\n\n\n\n","category":"function"},{"location":"discretization.html#TrajectoryOptimization.discrete_jacobian","page":"Discretizaation","title":"TrajectoryOptimization.discrete_jacobian","text":"Compute the discrete dynamics Jacobian of model using implicit integration scheme Q<:QuadratureRule\n\nMethods:\n\n∇f = discrete_dynamics(model, z::KnotPoint)  # uses RK3 as the default integration scheme\n∇f = discrete_jacobian(Q, model, z::KnotPoint)\n∇f = discrete_jacobian(Q, model, s::SVector{NM1}, t, ix::SVector{N}, iu::SVector{M})\n\nwhere s = [x; u; dt], t is the time, and ix and iu are the indices to extract the state and controls.\n\n\n\n\n\n","category":"function"},{"location":"discretization.html#Integration-Schemes-1","page":"Discretizaation","title":"Integration Schemes","text":"","category":"section"},{"location":"discretization.html#","page":"Discretizaation","title":"Discretizaation","text":"TrajectoryOptimization.jl has already defined a handful of integration schemes for computing discrete dynamics. The integration schemes are specified as abstract types, so that methods can efficiently dispatch based on the integration scheme selected. Here is the current set of implemented types:","category":"page"},{"location":"discretization.html#","page":"Discretizaation","title":"Discretizaation","text":"QuadratureRule\nImplicit\nRK3\nExplicit\nHermiteSimpson","category":"page"},{"location":"discretization.html#","page":"Discretizaation","title":"Discretizaation","text":"QuadratureRule\nImplicit\nRK3\nExplicit\nHermiteSimpson","category":"page"},{"location":"discretization.html#TrajectoryOptimization.QuadratureRule","page":"Discretizaation","title":"TrajectoryOptimization.QuadratureRule","text":"Integration rule for approximating the continuous integrals for the equations of motion\n\n\n\n\n\n","category":"type"},{"location":"discretization.html#TrajectoryOptimization.RK3","page":"Discretizaation","title":"TrajectoryOptimization.RK3","text":"Third-order Runge-Kutta method with zero-order-old on the controls\n\n\n\n\n\n","category":"type"},{"location":"discretization.html#TrajectoryOptimization.HermiteSimpson","page":"Discretizaation","title":"TrajectoryOptimization.HermiteSimpson","text":"Third-order Runge-Kutta method with first-order-hold on the controls\n\n\n\n\n\n","category":"type"},{"location":"discretization.html#Defining-a-New-Integration-Scheme-1","page":"Discretizaation","title":"Defining a New Integration Scheme","text":"","category":"section"},{"location":"discretization.html#Implicit-Methods-1","page":"Discretizaation","title":"Implicit Methods","text":"","category":"section"},{"location":"discretization.html#","page":"Discretizaation","title":"Discretizaation","text":"Implicit integration schemes are understandably simpler, since the output is not a function of itself, as is the case with explicit jschemes. As such, as a minimum, the user only needs to define the following method for a new rule MyQ:","category":"page"},{"location":"discretization.html#","page":"Discretizaation","title":"Discretizaation","text":"x′ = discrete_dynamics(::Type{MyQ}, model::AbstractModel, x, u, dt)","category":"page"},{"location":"discretization.html#Explicit-Methods-1","page":"Discretizaation","title":"Explicit Methods","text":"","category":"section"},{"location":"discretization.html#","page":"Discretizaation","title":"Discretizaation","text":"Explicit integration schemes are specified with a DynamicsConstraint. These methods are most efficiently computed when the entire trajectory is considered at once, thereby avoiding duplicate function evaluations. As a result, the user must define methods that deal with the entire trajectory at once:","category":"page"},{"location":"discretization.html#","page":"Discretizaation","title":"Discretizaation","text":"evaluate!(vals::Vector{<:AbstractVector}, con::DynamicsConstraint{MyQ},\n    Z::Traj, inds=1:length(Z)-1)","category":"page"},{"location":"discretization.html#","page":"Discretizaation","title":"Discretizaation","text":"Here vals is a Vector of Static Vectors, where the result of the calculation will be stored. con is a DynamicsConstraint that specifies the integration scheme, Z is the trajectory, and inds are the knotpoints where the constraint is applied (which should always be 1:N-1 if you have a single model for the entire trajectory). The method should compute","category":"page"},{"location":"discretization.html#","page":"Discretizaation","title":"Discretizaation","text":"vals[k] = x[k+1] - f(x[k],u[k],x[k+1],u[k+1])","category":"page"},{"location":"discretization.html#","page":"Discretizaation","title":"Discretizaation","text":"which is the amount of dynamic infeasibility between knotpoints. The method should obviously loop over the entire trajectory (see implementation for HermiteSimpson).","category":"page"},{"location":"discretization.html#Integrating-Cost-Functions-1","page":"Discretizaation","title":"Integrating Cost Functions","text":"","category":"section"},{"location":"discretization.html#","page":"Discretizaation","title":"Discretizaation","text":"Some methods, such as DIRCOL, apply the integration scheme to the cost function, as well. This can be done for a new integration rule by defining the following methods:","category":"page"},{"location":"discretization.html#","page":"Discretizaation","title":"Discretizaation","text":"cost(obj::Objective, dyn_con::DynamicsConstraint{MyQ}, Z::Traj)\ncost_gradient!(E::CostExpansion, obj::Objective, dyn_con::DynamicsConstraint{MyQ}, Z::Traj)","category":"page"},{"location":"problem.html#problem_section-1","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"","category":"section"},{"location":"problem.html#","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"CurrentModule = TrajectoryOptimization","category":"page"},{"location":"problem.html#","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"Pages = [\"problem.md\"]","category":"page"},{"location":"problem.html#Creating-a-Problem-1","page":"4. Setting up a Problem","title":"Creating a Problem","text":"","category":"section"},{"location":"problem.html#","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"Problem","category":"page"},{"location":"problem.html#TrajectoryOptimization.Problem","page":"4. Setting up a Problem","title":"TrajectoryOptimization.Problem","text":"struct Problem{Q<:QuadratureRule, T<:AbstractFloat}\n\nTrajectory Optimization Problem. Contains the full definition of a trajectory optimization problem, including:\n\ndynamics model (Model)\nobjective (Objective)\nconstraints (ConstraintSet)\ninitial and final states\nPrimal variables (state and control trajectories)\nDiscretization information: knot points (N), time step (dt), and total time (tf)\n\nConstructors:\n\nProblem(model, obj, constraints, x0, xf, Z, N, tf) # defaults to RK3 integration\nProblem{Q}(model, obj, constraints, x0, xf, Z, N, tf) where Q<:QuadratureRule\nProblem(model, obj, xf, tf; x0, constraints, N, X0, U0, dt, integration)\nProblem{Q}(prob::Problem)  # change integration\n\nwhere Z is a trajectory (Vector of KnotPoints)\n\nArguments\n\nmodel: Dynamics model. Can be either Discrete or Continuous\nobj: Objective\nX0: Initial state trajectory. If omitted it will be initialized with NaNs, to be later overwritten by the solver.\nU0: Initial control trajectory. If omitted it will be initialized with zeros.\nx0: Initial state. Defaults to zeros.\nxf: Final state. Defaults to zeros.\ndt: Time step\ntf: Final time. Set to zero to specify a time penalized problem.\nN: Number of knot points. Defaults to 51, unless specified by dt and tf.\nintegration: One of the defined integration types to discretize the continuous dynamics model. \n\nBoth X0 and U0 can be either a Matrix or a Vector{Vector}, but must be the same. At least 2 of dt, tf, and N need to be specified (or just 1 of dt and tf).\n\n\n\n\n\n","category":"type"},{"location":"problem.html#Methods-1","page":"4. Setting up a Problem","title":"Methods","text":"","category":"section"},{"location":"problem.html#","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"change_integration\ninitial_controls!\ninitial_states!\nBase.size(::Problem)\nBase.copy(::Problem)","category":"page"},{"location":"problem.html#TrajectoryOptimization.change_integration","page":"4. Setting up a Problem","title":"TrajectoryOptimization.change_integration","text":"change_integration(prob::Problem, Q<:QuadratureRule)\n\nChange dynamics integration for the problem\n\n\n\n\n\n","category":"function"},{"location":"problem.html#TrajectoryOptimization.initial_controls!","page":"4. Setting up a Problem","title":"TrajectoryOptimization.initial_controls!","text":"initial_controls!(::Union{Problem,AbstractSolver}, U0::Vector{<:AbstractVector})\ninitial_controls!(::Union{Problem,AbstractSolver}, U0::AbstractMatrx)\n\nCopy the control trajectory \n\n\n\n\n\n","category":"function"},{"location":"problem.html#TrajectoryOptimization.initial_states!","page":"4. Setting up a Problem","title":"TrajectoryOptimization.initial_states!","text":"initial_states!(::Union{Problem,AbstractSolver}, X0::Vector{<:AbstractVector})\ninitial_states!(::Union{Problem,AbstractSolver}, X0::AbstractMatrix)\n\nCopy the state trajectory \n\n\n\n\n\n","category":"function"},{"location":"problem.html#Base.size-Tuple{Problem}","page":"4. Setting up a Problem","title":"Base.size","text":"Get number of states, controls, and knot points\n\n\n\n\n\n","category":"method"},{"location":"problem.html#Base.copy-Tuple{Problem}","page":"4. Setting up a Problem","title":"Base.copy","text":"Copy the problem\n\n\n\n\n\n","category":"method"},{"location":"index.html#TrajectoryOptimization.jl-Documentation-1","page":"Introduction","title":"TrajectoryOptimization.jl Documentation","text":"","category":"section"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"CurrentModule = TrajectoryOptimization","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"Documentation for TrajectoryOptimization.jl","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"Pages = [\"index.md\"]","category":"page"},{"location":"index.html#Overview-1","page":"Introduction","title":"Overview","text":"","category":"section"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"This package is a testbed for state-of-the-art trajectory optimization algorithms. Trajectory optimization problems are of the form,","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"beginaligned\n  min_x_0Nu_0N-1 quad  ell_f(x_N) + sum_k=0^N-1 ell_k(x_k u_k dt) \n  textrmst            quad  x_k+1 = f(x_k u_k) \n                                  g_k(x_ku_k) leq 0 \n                                  h_k(x_ku_k) = 0\nendaligned","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"This package currently implements the following methods for solving trajectory optimization problems:","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"Iterative LQR (iLQR): indirect method based on Differential Dynamic Programming\nAL-iLQR: iLQR within an Augmented Lagrangian framework\nDirect Collocation: direct method that formulates the problem as an NLP and passes the problem off to a commercial NLP solver\nALTRO (Augmented Lagrangian Trajectory Optimizer): A novel algorithm developed by the Robotic Exploration Lab at Stanford University, which uses iLQR within an augmented Lagrangian framework combined with a \"Projected Newton\" direct method for solution polishing and enforcement of feasibility.","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"Key features include:","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"Support for general, per-timestep constraints\nForwardDiff for fast auto-differentiation of dynamics, cost functions, and constraints\nURDF parsing via [RigidBodyDynamics]","category":"page"},{"location":"index.html#Getting-Started-1","page":"Introduction","title":"Getting Started","text":"","category":"section"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"To set up and solve a trajectory optimization problem with TrajectoryOptimization.jl, the user will go through the following steps:","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"Create a Model\nCreate an Objective\n(Optionally) Add constraints\nInstantiate a Problem\nSelect a solver\nSolve the problem","category":"page"},{"location":"costfunctions.html#objective_section-1","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"","category":"section"},{"location":"costfunctions.html#","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"CurrentModule = TrajectoryOptimization","category":"page"},{"location":"costfunctions.html#","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"Pages = [\"costfunctions.md\"]","category":"page"},{"location":"costfunctions.html#Overview-1","page":"2. Setting up an Objective","title":"Overview","text":"","category":"section"},{"location":"costfunctions.html#","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"All trajectory optimization problems require a cost function at each stage of the trajectory. Cost functions must be scalar-valued. We assume general cost functions of the form,","category":"page"},{"location":"costfunctions.html#","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"ell_f(x_N) + sum_k=1^N-1 ell_k(x_ku_k) dt","category":"page"},{"location":"costfunctions.html#","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"It is very important to note that ell_k(x_ku_k) is ONLY a function of x_k and u_k, i.e. no coupling across time-steps is permitted. This is a requirement for Differential Dynamic Programming methods such as iLQR, but could be relaxed for methods that parameterize both states and controls, such as DIRCOL. In general, any coupling between adjacent time-steps can be resolved by augmenting the state and defining the appropriate dynamics (this is the method we use to solve minimum time problems).","category":"page"},{"location":"costfunctions.html#","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"In general, trajectory optimization will take a second order Taylor series approximation of the cost function, resulting in a quadratic cost function of the form","category":"page"},{"location":"costfunctions.html#","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"x_N^T Q_f x_N + q_f^T x_N + sum_k=1^N-1 x_k^T Q_k x_k + q_k^T x_k + u_k^T R_k u_k + r_k^T u_k + u_k^T H_k x_k","category":"page"},{"location":"costfunctions.html#","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"This type of quadratic cost is typical for trajectory optimization problems, especially when Q is positive semi-definite and R is positive definite, which is strictly convex. These problem behave well and reduce the computational requirements of taking second-order Taylor series expansions of the cost at each iteration.","category":"page"},{"location":"costfunctions.html#","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"In TrajectoryOptimization.jl we differentiate between the entire objective and the cost functions at each time step. We use Objective to describe the function that is being minimized, which typically consists of a sum of cost functions, with potentially some additional terms (as is the case with augmented Lagrangian objectives). Describing the Objective as a sum of individual functions allows the solvers to more efficiently compute the gradient and Hessian of the entire cost, which is block-diagonal given the Markovianity of the problem.","category":"page"},{"location":"costfunctions.html#Cost-functions-1","page":"2. Setting up an Objective","title":"Cost functions","text":"","category":"section"},{"location":"costfunctions.html#","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"There are several different cost function types that all inherit from CostFunction. The following sections detail the various methods for instantiating these cost function types.","category":"page"},{"location":"costfunctions.html#Quadratic-Costs-1","page":"2. Setting up an Objective","title":"Quadratic Costs","text":"","category":"section"},{"location":"costfunctions.html#","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"Quadratic costs are the most standard cost function and excellent place to start. Let's assume we are creating an LQR tracking cost of the form","category":"page"},{"location":"costfunctions.html#","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"(x_N - x_f)^T Q_f (x_N - x_f) + sum_k=1^N-1 (x_k - x_f)^T Q (x_k - x_f) + u_k^T R u_k","category":"page"},{"location":"costfunctions.html#","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"for the simple pendulum with the goal of doing a swing-up. To do this we have very convenient constructors LQRCost and LQRCostTerminal:","category":"page"},{"location":"costfunctions.html#","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"using LinearAlgebra\nn,m = 2,1\nQ = Diagonal(0.1I,n)\nR = Diagonal(0.1I,m)\nQf = Diagonal(1000I,n)\nxf = [π,0]\ncostfun = LQRCost(Q,R,Qf)\ncostfun_term = LQRCostTerminal(Qf,xf)","category":"page"},{"location":"costfunctions.html#","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"It is HIGHLY recommended to specify any special structure, such as Diagonal, especially since these matrices are almost always diagonal.","category":"page"},{"location":"costfunctions.html#","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"This constructor actually does a simple conversion to turn our cost function into a generic quadratic cost function. We could do this ourselves:","category":"page"},{"location":"costfunctions.html#","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"H = zeros(m,n)\nq = -Q*xf\nr = zeros(m)\nc = xf'Q*xf/2\nqf = -Qf*xf\ncf = xf'Qf*xf/2\ncostfun      = QuadraticCost(Q, R, H, q, r, c)\ncostfun_term = QuadraticCost(Qf, R*0, H, qf, r*0, cf)","category":"page"},{"location":"costfunctions.html#","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"The QuadraticCost constructor also supports keyword arguments and one that allows for only Q,q and c.:","category":"page"},{"location":"costfunctions.html#","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"costfun      = QuadraticCost(Q, R, q=q, c=c)\ncostfun_term = QuadraticCost(Q, q, c)","category":"page"},{"location":"costfunctions.html#","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"Once we have defined the cost function, we can create an objective for our problem by simply copying over all time steps (except for the terminal).","category":"page"},{"location":"costfunctions.html#","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"# Create an objective from a single cost function\nN = 51\nobj = Objective(costfun, costfun_term, N)","category":"page"},{"location":"costfunctions.html#","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"There's also a convenient constructor that builds an LQRObjective","category":"page"},{"location":"costfunctions.html#","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"obj = LQRObjective(Q, R, Qf, xf, N)","category":"page"},{"location":"costfunctions.html#QuadraticCost-API-1","page":"2. Setting up an Objective","title":"QuadraticCost API","text":"","category":"section"},{"location":"costfunctions.html#","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"QuadraticCost\nLQRCost\nLQRCostTerminal\nLQRObjective","category":"page"},{"location":"costfunctions.html#TrajectoryOptimization.QuadraticCost","page":"2. Setting up an Objective","title":"TrajectoryOptimization.QuadraticCost","text":"mutable struct QuadraticCost{TQ, TR, TH, Tq, Tr, T} <: CostFunction\n\nCost function of the form     1/2xₙᵀ Qf xₙ + qfᵀxₙ +  ∫ ( 1/2xᵀQx + 1/2uᵀRu + xᵀHu + q⁠ᵀx  rᵀu ) dt from 0 to tf R must be positive definite, Q and Qf must be positive semidefinite\n\nConstructor use any of the following constructors:\n\nQuadraticCost(Q, R, H, q, r, c)\nQuadraticCost(Q, R; H, q, r, c)\nQuadraticCost(Q, q, c)\n\nAny optional or omitted values will be set to zero(s).\n\n\n\n\n\n","category":"type"},{"location":"costfunctions.html#TrajectoryOptimization.LQRCost","page":"2. Setting up an Objective","title":"TrajectoryOptimization.LQRCost","text":"LQRCost(Q, R, xf)\n\n\nCost function of the form (x-x_f)^T Q (x_x_f) + u^T R u R must be positive definite, Q must be positive semidefinite\n\n\n\n\n\n","category":"function"},{"location":"costfunctions.html#TrajectoryOptimization.LQRCostTerminal","page":"2. Setting up an Objective","title":"TrajectoryOptimization.LQRCostTerminal","text":"LQRCostTerminal(Qf, xf)\n\n\nCost function of the form (x-x_f)^T Q (x_x_f) Q must be positive semidefinite\n\n\n\n\n\n","category":"function"},{"location":"costfunctions.html#TrajectoryOptimization.LQRObjective","page":"2. Setting up an Objective","title":"TrajectoryOptimization.LQRObjective","text":"LQRObjective(Q, R, Qf, xf, N)\n\nCreate an objective of the form (x_N - x_f)^T Q_f (x_N - x_f) + sum_k=0^N-1 (x_k-x_f)^T Q (x_k-x_f) + u_k^T R u_k\n\n\n\n\n\n","category":"function"},{"location":"costfunctions.html#Cost-Function-Interface-1","page":"2. Setting up an Objective","title":"Cost Function Interface","text":"","category":"section"},{"location":"costfunctions.html#","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"All cost functions are required to define the following methods","category":"page"},{"location":"costfunctions.html#","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"n = state_dim(cost)\nm = control_dim(cost)\nJ = stage_cost(cost, x, u)\nJ = stage_cost(cost, xN)\nQx,Qu = gradient(cost, x, u)\nQxx,Quu,Qux = hessian(cost, x, u)","category":"page"},{"location":"costfunctions.html#","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"and inherit from CostFunction.","category":"page"},{"location":"costfunctions.html#CostExpansion-Type-1","page":"2. Setting up an Objective","title":"CostExpansion Type","text":"","category":"section"},{"location":"costfunctions.html#","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"The CostExpansion type stores the pieces of the second order Taylor expansion of the cost for the entire trajectory, stored as vectors of Static Vectors or Static Matrices. e.g. to get the Hessian with respect to x at knotpoint 5 you would use E.xx[5].","category":"page"},{"location":"costfunctions.html#Objectives-1","page":"2. Setting up an Objective","title":"Objectives","text":"","category":"section"},{"location":"costfunctions.html#Constructors-1","page":"2. Setting up an Objective","title":"Constructors","text":"","category":"section"},{"location":"costfunctions.html#","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"Objectives can be created by copying a single cost function over all time steps","category":"page"},{"location":"costfunctions.html#","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"Objective(cost::CostFunction, N::Int)","category":"page"},{"location":"costfunctions.html#","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"or uniquely specifying the terminal cost function","category":"page"},{"location":"costfunctions.html#","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"Objective(cost::CostFunction, cost_terminal::CostFunction, N::Int)","category":"page"},{"location":"costfunctions.html#","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"or by explicitly specifying a list of cost functions","category":"page"},{"location":"costfunctions.html#","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"Objective(costfuns::Vector{<:CostFunction})","category":"page"},{"location":"costfunctions.html#Methods-1","page":"2. Setting up an Objective","title":"Methods","text":"","category":"section"},{"location":"costfunctions.html#","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"Constraints extends the methods on CostFunction to the whole trajectory","category":"page"},{"location":"costfunctions.html#","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"cost(obj, Z)\ncost_expansion!(E::CostExpansion, obj, Z)","category":"page"},{"location":"costfunctions.html#","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"where Z is a Trajectory (e.g. Vector of KnotPoints)","category":"page"},{"location":"costfunctions.html#API-1","page":"2. Setting up an Objective","title":"API","text":"","category":"section"},{"location":"costfunctions.html#","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"cost\nstage_cost\nget_J\ncost_gradient\ncost_gradient!\ncost_hessian\ncost_hessian!","category":"page"},{"location":"costfunctions.html#TrajectoryOptimization.cost","page":"2. Setting up an Objective","title":"TrajectoryOptimization.cost","text":"cost(obj::Objective, Z::Traj)::Float64\ncost(obj::Objective, dyn_con::DynamicsConstraint{Q}, Z::Traj)\n\nEvaluate the cost for a trajectory. Calculate the cost gradient for an entire trajectory. If a dynamics constraint is given,     use the appropriate integration rule, if defined.\n\n\n\n\n\ncost(::Problem)\ncost(::AbstractSolver)\n\nCompute the cost for the current trajectory\n\n\n\n\n\n","category":"function"},{"location":"costfunctions.html#TrajectoryOptimization.stage_cost","page":"2. Setting up an Objective","title":"TrajectoryOptimization.stage_cost","text":"stage_cost(cost::CostFunction, z::KnotPoint) -> Any\n\n\nEvaluate the cost at a knot point\n\n\n\n\n\n","category":"function"},{"location":"costfunctions.html#TrajectoryOptimization.get_J","page":"2. Setting up an Objective","title":"TrajectoryOptimization.get_J","text":"Get the vector of costs at each knot point. sum(get_J(obj)) is equal to the cost\n\n\n\n\n\n","category":"function"},{"location":"costfunctions.html#TrajectoryOptimization.cost_gradient","page":"2. Setting up an Objective","title":"TrajectoryOptimization.cost_gradient","text":"Qx,Qu = cost_gradient(cost::CostFunction, z::KnotPoint)\n\nGet Qx, Qu pieces of gradient of cost function, multiplied by dt\n\n\n\n\n\n","category":"function"},{"location":"costfunctions.html#TrajectoryOptimization.cost_gradient!","page":"2. Setting up an Objective","title":"TrajectoryOptimization.cost_gradient!","text":"cost_gradient!(E::CostExpansion, obj::Objective, Z::Traj)\ncost_gradient!(E::CostExpansion, obj::Objective, dyn_con::DynamicsConstraint{Q}, Z::Traj)\n\nCalculate the cost gradient for an entire trajectory. If a dynamics constraint is given,     use the appropriate integration rule, if defined.\n\n\n\n\n\n","category":"function"},{"location":"costfunctions.html#TrajectoryOptimization.cost_hessian","page":"2. Setting up an Objective","title":"TrajectoryOptimization.cost_hessian","text":"Qxx,Quu,Qux = cost_hessian(cost::CostFunction, z::KnotPoint)\n\nGet Qxx, Quu, Qux pieces of Hessian of cost function, multiplied by dt\n\n\n\n\n\n","category":"function"},{"location":"costfunctions.html#TrajectoryOptimization.cost_hessian!","page":"2. Setting up an Objective","title":"TrajectoryOptimization.cost_hessian!","text":"cost_hessian!(E::CostExpansion, obj::Objective, Z::Traj)\n\nCalculate the cost Hessian for an entire trajectory\n\n\n\n\n\n","category":"function"}]
}
