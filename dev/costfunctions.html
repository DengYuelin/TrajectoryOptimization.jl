<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>2. Setting up an Objective · TrajectoryOptimization</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">TrajectoryOptimization</span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Introduction</a></li><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="models.html">1. Setting up a Dynamics Model</a></li><li class="is-active"><a class="tocitem" href="costfunctions.html">2. Setting up an Objective</a><ul class="internal"><li><a class="tocitem" href="#Overview-1"><span>Overview</span></a></li><li><a class="tocitem" href="#Cost-functions-1"><span>Cost functions</span></a></li><li><a class="tocitem" href="#Objectives-1"><span>Objectives</span></a></li><li><a class="tocitem" href="#API-1"><span>API</span></a></li></ul></li><li><a class="tocitem" href="constraints.html">3. Creating Constraints</a></li><li><a class="tocitem" href="problem.html">4. Setting up a Problem</a></li></ul></li><li><span class="tocitem">Documentation</span><ul><li><a class="tocitem" href="discretization.html">Discretizaation</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Getting Started</a></li><li class="is-active"><a href="costfunctions.html">2. Setting up an Objective</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="costfunctions.html">2. Setting up an Objective</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/master/docs/src/costfunctions.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="objective_section-1"><a class="docs-heading-anchor" href="#objective_section-1">2. Setting up an Objective</a><a class="docs-heading-anchor-permalink" href="#objective_section-1" title="Permalink"></a></h1><ul><li><a href="costfunctions.html#objective_section-1">2. Setting up an Objective</a></li><ul><li><a href="costfunctions.html#Overview-1">Overview</a></li><li><a href="costfunctions.html#Cost-functions-1">Cost functions</a></li><li><a href="costfunctions.html#Objectives-1">Objectives</a></li><li><a href="costfunctions.html#API-1">API</a></li></ul></ul><h2 id="Overview-1"><a class="docs-heading-anchor" href="#Overview-1">Overview</a><a class="docs-heading-anchor-permalink" href="#Overview-1" title="Permalink"></a></h2><p>All trajectory optimization problems require a cost function at each stage of the trajectory. Cost functions must be scalar-valued. We assume general cost functions of the form,</p><div>\[\ell_f(x_N) + \sum_{k=1}^{N-1} \ell_k(x_k,u_k) dt\]</div><p>It is very important to note that <span>$\ell_k(x_k,u_k)$</span> is ONLY a function of <span>$x_k$</span> and <span>$u_k$</span>, i.e. no coupling across time-steps is permitted. This is a requirement for Differential Dynamic Programming methods such as iLQR, but could be relaxed for methods that parameterize both states and controls, such as DIRCOL. In general, any coupling between adjacent time-steps can be resolved by augmenting the state and defining the appropriate dynamics (this is the method we use to solve minimum time problems).</p><p>In general, trajectory optimization will take a second order Taylor series approximation of the cost function, resulting in a quadratic cost function of the form</p><div>\[x_N^T Q_f x_N + q_f^T x_N + \sum_{k=1}^{N-1} x_k^T Q_k x_k + q_k^T x_k + u_k^T R_k u_k + r_k^T u_k + u_k^T H_k x_k\]</div><p>This type of quadratic cost is typical for trajectory optimization problems, especially when Q is positive semi-definite and R is positive definite, which is strictly convex. These problem behave well and reduce the computational requirements of taking second-order Taylor series expansions of the cost at each iteration.</p><p>In TrajectoryOptimization.jl we differentiate between the entire objective and the cost functions at each time step. We use <code>Objective</code> to describe the function that is being minimized, which typically consists of a sum of cost functions, with potentially some additional terms (as is the case with augmented Lagrangian objectives). Describing the Objective as a sum of individual functions allows the solvers to more efficiently compute the gradient and Hessian of the entire cost, which is block-diagonal given the Markovianity of the problem.</p><h2 id="Cost-functions-1"><a class="docs-heading-anchor" href="#Cost-functions-1">Cost functions</a><a class="docs-heading-anchor-permalink" href="#Cost-functions-1" title="Permalink"></a></h2><p>There are several different cost function types that all inherit from <code>CostFunction</code>. The following sections detail the various methods for instantiating these cost function types.</p><h3 id="Quadratic-Costs-1"><a class="docs-heading-anchor" href="#Quadratic-Costs-1">Quadratic Costs</a><a class="docs-heading-anchor-permalink" href="#Quadratic-Costs-1" title="Permalink"></a></h3><p><a href="costfunctions.html#TrajectoryOptimization.QuadraticCost"><code>Quadratic costs</code></a> are the most standard cost function and excellent place to start. Let&#39;s assume we are creating an LQR tracking cost of the form</p><div>\[(x_N - x_f)^T Q_f (x_N - x_f) + \sum_{k=1}^{N-1} (x_k - x_f)^T Q (x_k - x_f) + u_k^T R u_k\]</div><p>for the simple pendulum with the goal of doing a swing-up. To do this we have very convenient constructors <a href="costfunctions.html#TrajectoryOptimization.LQRCost"><code>LQRCost</code></a> and <a href="costfunctions.html#TrajectoryOptimization.LQRCostTerminal"><code>LQRCostTerminal</code></a>:</p><pre><code class="language-julia">using LinearAlgebra
n,m = 2,1
Q = Diagonal(0.1I,n)
R = Diagonal(0.1I,m)
Qf = Diagonal(1000I,n)
xf = [π,0]
costfun = LQRCost(Q,R,Qf)
costfun_term = LQRCostTerminal(Qf,xf)</code></pre><p>It is HIGHLY recommended to specify any special structure, such as <code>Diagonal</code>, especially since these matrices are almost always diagonal.</p><p>This constructor actually does a simple conversion to turn our cost function into a generic quadratic cost function. We could do this ourselves:</p><pre><code class="language-julia">H = zeros(m,n)
q = -Q*xf
r = zeros(m)
c = xf&#39;Q*xf/2
qf = -Qf*xf
cf = xf&#39;Qf*xf/2
costfun      = QuadraticCost(Q, R, H, q, r, c)
costfun_term = QuadraticCost(Qf, R*0, H, qf, r*0, cf)</code></pre><p>The <code>QuadraticCost</code> constructor also supports keyword arguments and one that allows for only <code>Q,q</code> and <code>c</code>.:</p><pre><code class="language-julia">costfun      = QuadraticCost(Q, R, q=q, c=c)
costfun_term = QuadraticCost(Q, q, c)</code></pre><p>Once we have defined the cost function, we can create an objective for our problem by simply copying over all time steps (except for the terminal).</p><pre><code class="language-julia"># Create an objective from a single cost function
N = 51
obj = Objective(costfun, costfun_term, N)</code></pre><p>There&#39;s also a convenient constructor that builds an <a href="costfunctions.html#TrajectoryOptimization.LQRObjective"><code>LQRObjective</code></a></p><pre><code class="language-julia">obj = LQRObjective(Q, R, Qf, xf, N)</code></pre><h4 id="QuadraticCost-API-1"><a class="docs-heading-anchor" href="#QuadraticCost-API-1">QuadraticCost API</a><a class="docs-heading-anchor-permalink" href="#QuadraticCost-API-1" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="TrajectoryOptimization.QuadraticCost" href="#TrajectoryOptimization.QuadraticCost"><code>TrajectoryOptimization.QuadraticCost</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct QuadraticCost{TQ, TR, TH, Tq, Tr, T} &lt;: CostFunction</code></pre><p>Cost function of the form     1/2xₙᵀ Qf xₙ + qfᵀxₙ +  ∫ ( 1/2xᵀQx + 1/2uᵀRu + xᵀHu + q⁠ᵀx  rᵀu ) dt from 0 to tf R must be positive definite, Q and Qf must be positive semidefinite</p><p>Constructor use any of the following constructors:</p><pre><code class="language-julia">QuadraticCost(Q, R, H, q, r, c)
QuadraticCost(Q, R; H, q, r, c)
QuadraticCost(Q, q, c)</code></pre><p>Any optional or omitted values will be set to zero(s).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/ae02c158963ecff96629bd5bc9acf5ec71f69261/src/costfunctions.jl#L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TrajectoryOptimization.LQRCost" href="#TrajectoryOptimization.LQRCost"><code>TrajectoryOptimization.LQRCost</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">LQRCost(Q, R, xf)
</code></pre><p>Cost function of the form <span>$(x-x_f)^T Q (x_x_f) + u^T R u$</span> R must be positive definite, Q must be positive semidefinite</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/ae02c158963ecff96629bd5bc9acf5ec71f69261/src/costfunctions.jl#L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TrajectoryOptimization.LQRCostTerminal" href="#TrajectoryOptimization.LQRCostTerminal"><code>TrajectoryOptimization.LQRCostTerminal</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">LQRCostTerminal(Qf, xf)
</code></pre><p>Cost function of the form <span>$(x-x_f)^T Q (x_x_f)$</span> Q must be positive semidefinite</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/ae02c158963ecff96629bd5bc9acf5ec71f69261/src/costfunctions.jl#L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TrajectoryOptimization.LQRObjective" href="#TrajectoryOptimization.LQRObjective"><code>TrajectoryOptimization.LQRObjective</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">LQRObjective(Q, R, Qf, xf, N)</code></pre><p>Create an objective of the form <span>$(x_N - x_f)^T Q_f (x_N - x_f) + \sum_{k=0}^{N-1} (x_k-x_f)^T Q (x_k-x_f) + u_k^T R u_k$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/ae02c158963ecff96629bd5bc9acf5ec71f69261/src/objective.jl#L86-L92">source</a></section></article><h3 id="Cost-Function-Interface-1"><a class="docs-heading-anchor" href="#Cost-Function-Interface-1">Cost Function Interface</a><a class="docs-heading-anchor-permalink" href="#Cost-Function-Interface-1" title="Permalink"></a></h3><p>All cost functions are required to define the following methods</p><pre><code class="language-julia">n = state_dim(cost)
m = control_dim(cost)
J = stage_cost(cost, x, u)
J = stage_cost(cost, xN)
Qx,Qu = gradient(cost, x, u)
Qxx,Quu,Qux = hessian(cost, x, u)</code></pre><p>and inherit from <code>CostFunction</code>.</p><h3 id="CostExpansion-Type-1"><a class="docs-heading-anchor" href="#CostExpansion-Type-1">CostExpansion Type</a><a class="docs-heading-anchor-permalink" href="#CostExpansion-Type-1" title="Permalink"></a></h3><p>The <code>CostExpansion</code> type stores the pieces of the second order Taylor expansion of the cost for the entire trajectory, stored as vectors of Static Vectors or Static Matrices. e.g. to get the Hessian with respect to <code>x</code> at knotpoint 5 you would use <code>E.xx[5]</code>.</p><h2 id="Objectives-1"><a class="docs-heading-anchor" href="#Objectives-1">Objectives</a><a class="docs-heading-anchor-permalink" href="#Objectives-1" title="Permalink"></a></h2><h3 id="Constructors-1"><a class="docs-heading-anchor" href="#Constructors-1">Constructors</a><a class="docs-heading-anchor-permalink" href="#Constructors-1" title="Permalink"></a></h3><p>Objectives can be created by copying a single cost function over all time steps</p><pre><code class="language-julia">Objective(cost::CostFunction, N::Int)</code></pre><p>or uniquely specifying the terminal cost function</p><pre><code class="language-julia">Objective(cost::CostFunction, cost_terminal::CostFunction, N::Int)</code></pre><p>or by explicitly specifying a list of cost functions</p><pre><code class="language-julia">Objective(costfuns::Vector{&lt;:CostFunction})</code></pre><h3 id="Methods-1"><a class="docs-heading-anchor" href="#Methods-1">Methods</a><a class="docs-heading-anchor-permalink" href="#Methods-1" title="Permalink"></a></h3><p><code>Constraints</code> extends the methods on <code>CostFunction</code> to the whole trajectory</p><pre><code class="language-julia">cost(obj, Z)
cost_expansion!(E::CostExpansion, obj, Z)</code></pre><p>where <code>Z</code> is a Trajectory (e.g. Vector of <code>KnotPoint</code>s)</p><h2 id="API-1"><a class="docs-heading-anchor" href="#API-1">API</a><a class="docs-heading-anchor-permalink" href="#API-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="TrajectoryOptimization.cost" href="#TrajectoryOptimization.cost"><code>TrajectoryOptimization.cost</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">cost(obj::Objective, Z::Traj)::Float64
cost(obj::Objective, dyn_con::DynamicsConstraint{Q}, Z::Traj)</code></pre><p>Evaluate the cost for a trajectory. Calculate the cost gradient for an entire trajectory. If a dynamics constraint is given,     use the appropriate integration rule, if defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/ae02c158963ecff96629bd5bc9acf5ec71f69261/src/cost.jl#L17-L25">source</a></section><section><div><pre><code class="language-julia">cost(::Problem)
cost(::AbstractSolver)</code></pre><p>Compute the cost for the current trajectory</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/ae02c158963ecff96629bd5bc9acf5ec71f69261/src/static_problem.jl#L153-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TrajectoryOptimization.stage_cost" href="#TrajectoryOptimization.stage_cost"><code>TrajectoryOptimization.stage_cost</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">stage_cost(cost::CostFunction, z::KnotPoint) -&gt; Any
</code></pre><p>Evaluate the cost at a knot point</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/ae02c158963ecff96629bd5bc9acf5ec71f69261/src/cost.jl#L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TrajectoryOptimization.get_J" href="#TrajectoryOptimization.get_J"><code>TrajectoryOptimization.get_J</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Get the vector of costs at each knot point. <code>sum(get_J(obj))</code> is equal to the cost</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/ae02c158963ecff96629bd5bc9acf5ec71f69261/src/objective.jl#L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TrajectoryOptimization.cost_gradient" href="#TrajectoryOptimization.cost_gradient"><code>TrajectoryOptimization.cost_gradient</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Qx,Qu = cost_gradient(cost::CostFunction, z::KnotPoint)</code></pre><p>Get Qx, Qu pieces of gradient of cost function, multiplied by dt</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/ae02c158963ecff96629bd5bc9acf5ec71f69261/src/cost.jl#L43-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TrajectoryOptimization.cost_gradient!" href="#TrajectoryOptimization.cost_gradient!"><code>TrajectoryOptimization.cost_gradient!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">cost_gradient!(E::CostExpansion, obj::Objective, Z::Traj)
cost_gradient!(E::CostExpansion, obj::Objective, dyn_con::DynamicsConstraint{Q}, Z::Traj)</code></pre><p>Calculate the cost gradient for an entire trajectory. If a dynamics constraint is given,     use the appropriate integration rule, if defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/ae02c158963ecff96629bd5bc9acf5ec71f69261/src/cost.jl#L80-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TrajectoryOptimization.cost_hessian" href="#TrajectoryOptimization.cost_hessian"><code>TrajectoryOptimization.cost_hessian</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Qxx,Quu,Qux = cost_hessian(cost::CostFunction, z::KnotPoint)</code></pre><p>Get Qxx, Quu, Qux pieces of Hessian of cost function, multiplied by dt</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/ae02c158963ecff96629bd5bc9acf5ec71f69261/src/cost.jl#L59-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TrajectoryOptimization.cost_hessian!" href="#TrajectoryOptimization.cost_hessian!"><code>TrajectoryOptimization.cost_hessian!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">cost_hessian!(E::CostExpansion, obj::Objective, Z::Traj)</code></pre><p>Calculate the cost Hessian for an entire trajectory</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/ae02c158963ecff96629bd5bc9acf5ec71f69261/src/cost.jl#L97-L101">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="models.html">« 1. Setting up a Dynamics Model</a><a class="docs-footer-nextpage" href="constraints.html">3. Creating Constraints »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 24 December 2019 13:07">Tuesday 24 December 2019</span>. Using Julia version 1.2.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
