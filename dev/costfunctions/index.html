<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>2. Setting up a Cost Function · TrajectoryOptimization</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>TrajectoryOptimization</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">TrajectoryOptimization.jl</a></li><li><a class="toctext" href="../models/">1. Setting up a Dynamics Model</a></li><li class="current"><a class="toctext" href>2. Setting up a Cost Function</a><ul class="internal"><li class="toplevel"><a class="toctext" href="#Overview-1">Overview</a></li><li class="toplevel"><a class="toctext" href="#Creating-a-Cost-function-1">Creating a Cost function</a></li><li><a class="toctext" href="#Quadratic-Costs-1">Quadratic Costs</a></li><li><a class="toctext" href="#Generic-Costs-1">Generic Costs</a></li></ul></li><li><a class="toctext" href="../constraints/">4. Add Constraints</a></li><li><a class="toctext" href="../problem/">Setting up a Problem</a></li><li><a class="toctext" href="../solvers/">Solvers</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>2. Setting up a Cost Function</a></li></ul><a class="edit-page" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/master/docs/src/costfunctions.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>2. Setting up a Cost Function</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id=".-Setting-up-a-Cost-Function-1" href="#.-Setting-up-a-Cost-Function-1">2. Setting up a Cost Function</a></h1><ul><li><a href="#.-Setting-up-a-Cost-Function-1">2. Setting up a Cost Function</a></li><li><a href="#Overview-1">Overview</a></li><li><a href="#Creating-a-Cost-function-1">Creating a Cost function</a></li><ul><li><a href="#Quadratic-Costs-1">Quadratic Costs</a></li><li><a href="#Generic-Costs-1">Generic Costs</a></li></ul></ul><h1><a class="nav-anchor" id="Overview-1" href="#Overview-1">Overview</a></h1><p>All trajectory optimization problems require a cost function at each stage of the trajectory. Cost functions must be scalar-valued. We assume general cost functions of the form,</p><div>\[\ell_f(x_N) + \sum_{k=1}^{N-1} \ell_k(x_k,u_k)\]</div><p>It is very important to note that <span>$\ell_k(x_k,u_k)$</span> is ONLY a function of <span>$x_k$</span> and <span>$u_k$</span>, i.e. no coupling across time-steps is permitted. This is a requirement for Differential Dynamic Programming methods such as iLQR, but could be relaxed for methods that parameterize both states and controls, such as DIRCOL (although this is currently not supported). In general, any coupling between adjacent time-steps can be resolved by augmenting the state and defining the appropriate dynamics (this is the method we use to solve minimum time problems).</p><p>In general, trajectory optimization will take a second order Taylor series approximation of the cost function, resulting in a quadratic cost function of the form</p><div>\[x_N^T Q_f x_N + q_f^T x_N + \sum_{k=1}^{N-1} x_k^T Q_k x_k + q_k^T x_k + u_k^T R_k u_k + r_k^T u_k + u_k^T H_k x_k\]</div><p>This type of quadratic cost is typical for trajectory optimization problems, especially when Q is positive semi-definite and R is positive definite, which is strictly convex. These problem behave well and reduce the computational requirements of taking second-order Taylor series expansions of the cost at each iteration.</p><h1><a class="nav-anchor" id="Creating-a-Cost-function-1" href="#Creating-a-Cost-function-1">Creating a Cost function</a></h1><p>There are several different cost function types that all inherit from <code>CostFunction</code>. The following sections detail the various methods for instantiating these cost function types.</p><h2><a class="nav-anchor" id="Quadratic-Costs-1" href="#Quadratic-Costs-1">Quadratic Costs</a></h2><p>Quadratic costs are the most standard cost function and excellent place to start. Let&#39;s assume we are creating an LQR tracking cost of the form</p><div>\[(x_N - x_f)^T Q_f (x_N - x_f) + \sum_{k=1}^{N-1} (x_k - x_f)^T Q (x_k - x_f) + u_k^T R u_k\]</div><p>for the simple pendulum with the goal of doing a swing-up. To do this we have a very convenient constructor</p><pre><code class="language-julia">using LinearAlgebra
n,m = 2,1
Q = Diagonal(0.1I,n)
R = Diagonal(0.1I,m)
Qf = Diagonal(1000I,n)
xf = [π,0]
costfun = LQRCost(Q,R,Qf,xf)</code></pre><p>It is HIGHLY recommended to specify any special structure, such as <code>Diagonal</code>, especially since these matrices are almost always diagonal.</p><p>This constructor actually does a simple conversion to turn our cost function into a generic quadratic cost function. We could do this ourselves:</p><pre><code class="language-julia">H = zeros(m,n)
q = -Q*xf
r = zeros(m)
c = xf&#39;Q*xf/2
qf = -Qf*xf
cf = xf&#39;Qf*xf/2
costfun = QuadraticCost(Q, R, H, q, r, c, Qf, qf, cf)</code></pre><pre><code class="language-none">QuadraticCost</code></pre><h2><a class="nav-anchor" id="Generic-Costs-1" href="#Generic-Costs-1">Generic Costs</a></h2><p>For general, non-linear cost functions use <a href="@ref">GenericCost</a>. Generic cost functions must define their second-order Taylor series expansion, either automatically using <code>ForwardDiff</code> or analytically.</p><p>Let&#39;s say we wanted to use the nonlinear objective for the pendulum</p><div>\[cos(\theta_N) + \omega_N^2 \sum_{k=1}^{N-1} cos(\theta_k) + u_k^T R + u_k + Q ω^2\]</div><p>which is small when θ = π, encouraging swing-up.</p><p>We define the cost function by defining ℓ(x,u) and <span>$\ell_f(x)$</span></p><pre><code class="language-julia"># Define the stage and terminal cost functions
function mycost(x,u)
    R = Diagonal(0.1I,1)
    Q = 0.1
    return cos(x[1] + u&#39;R*u + Q*x[2]^2)
end
function mycost(xN)
    return cos(xN[1]) + xN[2]^2
end

# Create the nonlinear cost function
nlcost = GenericCost(mycost,mycost,n,m)</code></pre><p>This will use <code>ForwardDiff</code> to generate the gradient and Hessian needed for the 2nd order expansion.</p><p>Performance-wise, it will be faster to specify the Jacobian analytically (which could also use <code>ForwardDiff</code> for part of it). We just need to define the following functions</p><ul><li><code>hess</code>: multiple-dispatch function of the form,   <code>Q,R,H = hess(x,u)</code> with sizes (n,n), (m,m), (m,n)   <code>Qf = hess(xN)</code> with size (n,n)</li><li><code>grad</code>: multiple-dispatch function of the form,   <code>q,r = grad(x,u)</code> with sizes (n,), (m,)   <code>qf = grad(x,u)</code> with size (n,)</li></ul><p>Here&#39;s an example for the nonlinear cost function we used before</p><pre><code class="language-julia"># Define the gradient and Hessian functions
R = Diagonal(0.1I,m)
Q = 0.1
function hess(x,u)
    n,m = length(x),length(u)
    Qexp = Diagonal([-cos(x[1]), 2Q])
    Rexp = 2R
    H = zeros(m,n)
    return Qexp,Rexp,Hexp
end
function hess(x)
    return Diagonal([-cos(x[1]), 2])
end
function grad(x,u)
    q = [-sin(x[1]), 2Q*x[2]]
    r = 2R*u
    return q,r
end
function grad(x)
    return [-sin(x[1]), 2*x[2]]
end

# Create the cost function
nlcost = GenericCost(mycost, mycost, grad, hess, n, m)</code></pre><footer><hr/><a class="previous" href="../models/"><span class="direction">Previous</span><span class="title">1. Setting up a Dynamics Model</span></a><a class="next" href="../constraints/"><span class="direction">Next</span><span class="title">4. Add Constraints</span></a></footer></article></body></html>
