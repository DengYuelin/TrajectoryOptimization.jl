<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>2. Setting up an Objective · TrajectoryOptimization</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>TrajectoryOptimization</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">TrajectoryOptimization.jl Documentation</a></li><li><a class="toctext" href="../models/">1. Setting up a Dynamics Model</a></li><li class="current"><a class="toctext" href>2. Setting up an Objective</a><ul class="internal"><li><a class="toctext" href="#Overview-1">Overview</a></li><li><a class="toctext" href="#Cost-functions-1">Cost functions</a></li><li><a class="toctext" href="#Objectives-1">Objectives</a></li><li><a class="toctext" href="#API-1">API</a></li></ul></li><li><a class="toctext" href="../constraints/">3. Creating Constraints</a></li><li><a class="toctext" href="../problem/">4. Setting up a Problem</a></li><li><a class="toctext" href="../solvers/">Solvers</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>2. Setting up an Objective</a></li></ul><a class="edit-page" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/master/docs/src/costfunctions.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>2. Setting up an Objective</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="objective_section-1" href="#objective_section-1">2. Setting up an Objective</a></h1><ul><li><a href="#objective_section-1">2. Setting up an Objective</a></li><ul><li><a href="#Overview-1">Overview</a></li><li><a href="#Cost-functions-1">Cost functions</a></li><li><a href="#Objectives-1">Objectives</a></li><li><a href="#API-1">API</a></li></ul></ul><h2><a class="nav-anchor" id="Overview-1" href="#Overview-1">Overview</a></h2><p>All trajectory optimization problems require a cost function at each stage of the trajectory. Cost functions must be scalar-valued. We assume general cost functions of the form,</p><div>\[\ell_f(x_N) + \sum_{k=1}^{N-1} \ell_k(x_k,u_k)\]</div><p>It is very important to note that <span>$\ell_k(x_k,u_k)$</span> is ONLY a function of <span>$x_k$</span> and <span>$u_k$</span>, i.e. no coupling across time-steps is permitted. This is a requirement for Differential Dynamic Programming methods such as iLQR, but could be relaxed for methods that parameterize both states and controls, such as DIRCOL. In general, any coupling between adjacent time-steps can be resolved by augmenting the state and defining the appropriate dynamics (this is the method we use to solve minimum time problems).</p><p>In general, trajectory optimization will take a second order Taylor series approximation of the cost function, resulting in a quadratic cost function of the form</p><div>\[x_N^T Q_f x_N + q_f^T x_N + \sum_{k=1}^{N-1} x_k^T Q_k x_k + q_k^T x_k + u_k^T R_k u_k + r_k^T u_k + u_k^T H_k x_k\]</div><p>This type of quadratic cost is typical for trajectory optimization problems, especially when Q is positive semi-definite and R is positive definite, which is strictly convex. These problem behave well and reduce the computational requirements of taking second-order Taylor series expansions of the cost at each iteration.</p><p>In TrajectoryOptimization.jl we differentiate between the entire objective and the cost functions at each time step. We use <code>Objective</code> to describe the function that is being minimized, which typically consists of a sum of cost functions, with potentially some additional terms (as is the case with augmented Lagrangian objectives). Describing the Objective as a sum of individual functions allows the solvers to more efficiently compute the gradient and Hessian of the entire cost, which is block-diagonal given the Markovianity of the problem.</p><h2><a class="nav-anchor" id="Cost-functions-1" href="#Cost-functions-1">Cost functions</a></h2><p>There are several different cost function types that all inherit from <code>CostFunction</code>. The following sections detail the various methods for instantiating these cost function types.</p><h3><a class="nav-anchor" id="Quadratic-Costs-1" href="#Quadratic-Costs-1">Quadratic Costs</a></h3><p><a href="#TrajectoryOptimization.QuadraticCost"><code>Quadratic costs</code></a> are the most standard cost function and excellent place to start. Let&#39;s assume we are creating an LQR tracking cost of the form</p><div>\[(x_N - x_f)^T Q_f (x_N - x_f) + \sum_{k=1}^{N-1} (x_k - x_f)^T Q (x_k - x_f) + u_k^T R u_k\]</div><p>for the simple pendulum with the goal of doing a swing-up. To do this we have very convenient constructors <a href="#TrajectoryOptimization.LQRCost"><code>LQRCost</code></a> and <a href="#TrajectoryOptimization.LQRCostTerminal"><code>LQRCostTerminal</code></a>:</p><pre><code class="language-julia">using LinearAlgebra
n,m = 2,1
Q = Diagonal(0.1I,n)
R = Diagonal(0.1I,m)
Qf = Diagonal(1000I,n)
xf = [π,0]
costfun = LQRCost(Q,R,Qf)
costfun_term = LQRCostTerminal(Qf,xf)</code></pre><p>It is HIGHLY recommended to specify any special structure, such as <code>Diagonal</code>, especially since these matrices are almost always diagonal.</p><p>This constructor actually does a simple conversion to turn our cost function into a generic quadratic cost function. We could do this ourselves:</p><pre><code class="language-julia">H = zeros(m,n)
q = -Q*xf
r = zeros(m)
c = xf&#39;Q*xf/2
qf = -Qf*xf
cf = xf&#39;Qf*xf/2
costfun      = QuadraticCost(Q, R, H, q, r, c)
costfun_term = QuadraticCost(Qf, R*0, H, qf, r*0, cf)</code></pre><p>The <code>QuadraticCost</code> constructor also supports keyword arguments and one that allows for only <code>Q,q</code> and <code>c</code>.:</p><pre><code class="language-julia">costfun      = QuadraticCost(Q, R, q=q, c=c)
costfun_term = QuadraticCost(Q, q, c)</code></pre><p>Once we have defined the cost function, we can create an objective for our problem by simply copying over all time steps (except for the terminal).</p><pre><code class="language-julia"># Create an objective from a single cost function
N = 51
obj = Objective(costfun, costfun_term, N)</code></pre><p>There&#39;s also a convenient constructor that builds an <a href="#TrajectoryOptimization.LQRObjective"><code>LQRObjective</code></a></p><pre><code class="language-julia">obj = LQRObjective(Q, R, Qf, xf, N)</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrajectoryOptimization.QuadraticCost" href="#TrajectoryOptimization.QuadraticCost"><code>TrajectoryOptimization.QuadraticCost</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">mutable struct QuadraticCost{T} &lt;: TrajectoryOptimization.CostFunction</code></pre><p>Cost function of the form     1/2xₙᵀ Qf xₙ + qfᵀxₙ +  ∫ ( 1/2xᵀQx + 1/2uᵀRu + xᵀHu + q⁠ᵀx  rᵀu ) dt from 0 to tf R must be positive definite, Q and Qf must be positive semidefinite</p><p>Constructor use any of the following constructors:</p><pre><code class="language-julia">QuadraticCost(Q, R, H, q, r, c)
QuadraticCost(Q, R; H, q, r, c)
QuadraticCost(Q, q, c)</code></pre><p>Any optional or omitted values will be set to zero(s).</p></div></div><a class="source-link" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/2ea839be5a504992bf02865f34a4c376ca18e2a3/src/cost.jl#L96">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrajectoryOptimization.LQRCost" href="#TrajectoryOptimization.LQRCost"><code>TrajectoryOptimization.LQRCost</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">LQRCost(Q, R, xf)
</code></pre><p>Cost function of the form <span>$(x-x_f)^T Q (x_x_f) + u^T R u$</span> R must be positive definite, Q must be positive semidefinite</p></div></div><a class="source-link" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/2ea839be5a504992bf02865f34a4c376ca18e2a3/src/cost.jl#L143">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrajectoryOptimization.LQRCostTerminal" href="#TrajectoryOptimization.LQRCostTerminal"><code>TrajectoryOptimization.LQRCostTerminal</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">LQRCostTerminal(Qf, xf)
</code></pre><p>Cost function of the form <span>$(x-x_f)^T Q (x_x_f)$</span> Q must be positive semidefinite</p></div></div><a class="source-link" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/2ea839be5a504992bf02865f34a4c376ca18e2a3/src/cost.jl#L157">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrajectoryOptimization.LQRObjective" href="#TrajectoryOptimization.LQRObjective"><code>TrajectoryOptimization.LQRObjective</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">LQRObjective(Q, R, Qf, xf, N)</code></pre><p>Create an objective of the form <span>$(x_N - x_f)^T Q_f (x_N - x_f) + \sum_{k=0}^{N-1} (x_k-x_f)^T Q (x_k-x_f) + u_k^T R u_k$</span></p></div></div><a class="source-link" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/2ea839be5a504992bf02865f34a4c376ca18e2a3/src/objective.jl#L65-L71">source</a></section><h3><a class="nav-anchor" id="Generic-Costs-(Experimental)-1" href="#Generic-Costs-(Experimental)-1">Generic Costs (Experimental)</a></h3><p>For general, non-linear cost functions use <a href="#TrajectoryOptimization.GenericCost"><code>GenericCost</code></a>. Generic cost functions must define their second-order Taylor series expansion, either automatically using <code>ForwardDiff</code> or analytically.</p><p>Let&#39;s say we wanted to use a nonlinear objective for the pendulum</p><div>\[cos(\theta_N) + \omega_N^2 \sum_{k=1}^{N-1} cos(\theta_k) + u_k^T R u_k + Q ω^2\]</div><p>which is small when θ = π, encouraging swing-up.</p><p>We define the cost function by defining ℓ(x,u) and ℓ(x)</p><pre><code class="language-julia"># Define the stage and terminal cost functions
function mycost(x,u)
    R = Diagonal(0.1I,1)
    Q = 0.1
    return cos(x[1] + u&#39;R*u + Q*x[2]^2)
end
function mycost(xN)
    return cos(xN[1]) + xN[2]^2
end

# Create the nonlinear cost function
nlcost = GenericCost(mycost,mycost,n,m)</code></pre><p>This will use <code>ForwardDiff</code> to generate the gradient and Hessian needed for the 2nd order expansion.</p><p>Performance-wise, it will be faster to specify the Jacobian analytically (which could also use <code>ForwardDiff</code> for part of it). We just need to define the following functions</p><ul><li><code>hess</code>: multiple-dispatch function of the form,   <code>Q,R,H = hess(x,u)</code> with sizes (n,n), (m,m), (m,n)   <code>Qf = hess(xN)</code> with size (n,n)</li><li><code>grad</code>: multiple-dispatch function of the form,   <code>q,r = grad(x,u)</code> with sizes (n,), (m,)   <code>qf = grad(x,u)</code> with size (n,)</li></ul><p>Here&#39;s an example for the nonlinear cost function we used before</p><pre><code class="language-julia"># Define the gradient and Hessian functions
R = Diagonal(0.1I,m)
Q = 0.1
function hess(x,u)
    n,m = length(x),length(u)
    Qexp = Diagonal([-cos(x[1]), 2Q])
    Rexp = 2R
    H = zeros(m,n)
    return Qexp,Rexp,Hexp
end
function hess(x)
    return Diagonal([-cos(x[1]), 2])
end
function grad(x,u)
    q = [-sin(x[1]), 2Q*x[2]]
    r = 2R*u
    return q,r
end
function grad(x)
    return [-sin(x[1]), 2*x[2]]
end

# Create the cost function
nlcost = GenericCost(mycost, mycost, grad, hess, n, m)</code></pre><p>Since our cost function is defined at both stage and terminal steps, we can simply copy it over all time steps to create an objective:</p><pre><code class="language-julia"># Create objective
N = 51
nlobj = Objective(nlcost, N)</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrajectoryOptimization.GenericCost" href="#TrajectoryOptimization.GenericCost"><code>TrajectoryOptimization.GenericCost</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct GenericCost &lt;: TrajectoryOptimization.CostFunction</code></pre><p>Cost function of the form     ℓf(xₙ) + ∫ ℓ(x,u) dt from 0 to tf</p></div></div><a class="source-link" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/2ea839be5a504992bf02865f34a4c376ca18e2a3/src/cost.jl#L228">source</a></section><h3><a class="nav-anchor" id="Cost-Function-Interface-1" href="#Cost-Function-Interface-1">Cost Function Interface</a></h3><p>All cost functions are required to define the following methods</p><pre><code class="language-julia">stage_cost(cost, x, u)
stage_cost(cost, xN)
cost_expansion!(Q::Expansion, cost, x, u)
cost_expansion(Q::Expansion, cost, xN)</code></pre><p>and inherit from <code>CostFunction</code>.</p><p>The <code>Expansion</code> type is defined in the next section. This common interface allows the <code>Objective</code> to efficiently dispatch over cost functions to compute the overall cost and Taylor series expansion (i.e. gradient and Hessian).</p><h3><a class="nav-anchor" id="Expansion-Type-1" href="#Expansion-Type-1">Expansion Type</a></h3><p>The expansion type stores the pieces of the second order Taylor expansion of the cost.</p><p>If we store the expansion as <code>Q</code>, then <code>Q.x</code> is the partial with respect to the control, <code>Q.xu</code> is the partial with respect to x and u, etc.</p><h2><a class="nav-anchor" id="Objectives-1" href="#Objectives-1">Objectives</a></h2><h3><a class="nav-anchor" id="Constructors-1" href="#Constructors-1">Constructors</a></h3><p>Objectives can be created by copying a single cost function over all time steps</p><pre><code class="language-julia">Objective(cost::CostFunction, N::Int)</code></pre><p>or uniquely specifying the terminal cost function</p><pre><code class="language-julia">Objective(cost::CostFunction, cost_terminal::CostFunction, N::Int)</code></pre><p>or by explicitly specifying a list of cost functions</p><pre><code class="language-julia">Objective(costfuns::Vector{&lt;:CostFunction})</code></pre><h3><a class="nav-anchor" id="Methods-1" href="#Methods-1">Methods</a></h3><p><code>Constraints</code> extends the methods on <code>CostFunction</code> to the whole trajectory</p><pre><code class="language-julia">cost(obj, X, U)
cost_expansion!(Q::Vector{Expansion}, obj, X, U)</code></pre><p>where <code>X</code> and <code>U</code> are the state and control trajectories.</p><h2><a class="nav-anchor" id="API-1" href="#API-1">API</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrajectoryOptimization.cost" href="#TrajectoryOptimization.cost"><code>TrajectoryOptimization.cost</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">cost(obj::Objective, X::Vector, U::Vector, dt::Vector)</code></pre><p>Calculate cost over entire state and control trajectories</p></div></div><a class="source-link" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/2ea839be5a504992bf02865f34a4c376ca18e2a3/src/objective.jl#L35-L40">source</a><div><div><p>Evaluate the current cost for the problem</p></div></div><a class="source-link" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/2ea839be5a504992bf02865f34a4c376ca18e2a3/src/problem.jl#L234">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrajectoryOptimization.stage_cost" href="#TrajectoryOptimization.stage_cost"><code>TrajectoryOptimization.stage_cost</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">stage_cost(cost, x, u)
</code></pre><p>Evaluate the cost at state <code>x</code> and control <code>u</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/2ea839be5a504992bf02865f34a4c376ca18e2a3/src/cost.jl#L86">source</a><div><div><pre><code class="language-julia">stage_cost(cost, xN)
</code></pre><p>Evaluate the cost at the terminal state <code>xN</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/2ea839be5a504992bf02865f34a4c376ca18e2a3/src/cost.jl#L88">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrajectoryOptimization.cost_expansion!" href="#TrajectoryOptimization.cost_expansion!"><code>TrajectoryOptimization.cost_expansion!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">cost_expansion!(Q, cost, x, u)
</code></pre><p>Evaluate the second order expansion at state <code>x</code> and control <code>u</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/2ea839be5a504992bf02865f34a4c376ca18e2a3/src/cost.jl#L90">source</a><div><div><pre><code class="language-julia">cost_expansion!(Q, cost, xN)
</code></pre><p>Evaluate the second order expansion at the terminal state <code>xN</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/2ea839be5a504992bf02865f34a4c376ca18e2a3/src/cost.jl#L92">source</a><div><div><pre><code class="language-julia">cost_expansion!(Q, obj, X, U, dt)
</code></pre><p>Compute the second order Taylor expansion of the cost for the entire trajectory</p></div></div><a class="source-link" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/2ea839be5a504992bf02865f34a4c376ca18e2a3/src/objective.jl#L50">source</a></section><footer><hr/><a class="previous" href="../models/"><span class="direction">Previous</span><span class="title">1. Setting up a Dynamics Model</span></a><a class="next" href="../constraints/"><span class="direction">Next</span><span class="title">3. Creating Constraints</span></a></footer></article></body></html>
