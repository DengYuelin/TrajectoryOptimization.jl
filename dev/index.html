<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>TrajectoryOptimization.jl · TrajectoryOptimization</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>TrajectoryOptimization</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>TrajectoryOptimization.jl</a><ul class="internal"><li class="toplevel"><a class="toctext" href="#Overview-1">Overview</a></li><li class="toplevel"><a class="toctext" href="#Getting-Started-1">Getting Started</a></li><li><a class="toctext" href="#Creating-a-Model-1">Creating a Model</a></li><li><a class="toctext" href="#Creating-an-Objective-1">Creating an Objective</a></li><li><a class="toctext" href="#Solving-the-Problem-1">Solving the Problem</a></li><li><a class="toctext" href="#Solve-Methods-1">Solve Methods</a></li><li><a class="toctext" href="#Direct-Collocation-(DIRCOL)-1">Direct Collocation (DIRCOL)</a></li></ul></li><li><a class="toctext" href="models/">1. Setting up a Dynamics Model</a></li><li><a class="toctext" href="costfunctions/">2. Setting up a Cost Function</a></li><li><a class="toctext" href="constraints/">4. Add Constraints</a></li><li><a class="toctext" href="problem/">Setting up a Problem</a></li><li><a class="toctext" href="solvers/">Solvers</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>TrajectoryOptimization.jl</a></li></ul><a class="edit-page" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/master/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>TrajectoryOptimization.jl</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="TrajectoryOptimization.jl-1" href="#TrajectoryOptimization.jl-1">TrajectoryOptimization.jl</a></h1><p>Documentation for TrajectoryOptimization.jl</p><ul><li><a href="constraints/#.-Add-Constraints-1">4. Add Constraints</a></li><li><a href="constraints/#Constraint-Type-1">Constraint Type</a></li><li><a href="constraints/#Creating-Constraints-1">Creating Constraints</a></li><ul><li><a href="constraints/#Special-Constraints-1">Special Constraints</a></li></ul><li><a href="models/#.-Setting-up-a-Dynamics-Model-1">1. Setting up a Dynamics Model</a></li><li><a href="models/#Overview-1">Overview</a></li><li><a href="models/#Continuous-Models-1">Continuous Models</a></li><ul><li><a href="models/#From-analytical-function-1">From analytical function</a></li><li><a href="models/#With-analytical-Jacobians-1">With analytical Jacobians</a></li><li><a href="models/#URDF-Files-1">URDF Files</a></li><li><a href="models/#A-note-on-Model-types-1">A note on Model types</a></li></ul><li><a href="models/#Discrete-Models-1">Discrete Models</a></li><ul><li><a href="models/#From-a-continuous-model-1">From a continuous model</a></li><li><a href="models/#From-an-analytical-expression-1">From an analytical expression</a></li></ul><li><a href="models/#Methods-1">Methods</a></li><ul><li><a href="models/#Testing-the-dynamics-1">Testing the dynamics</a></li></ul><li><a href="models/#API-1">API</a></li><li><a href="solvers/#Solvers-1">Solvers</a></li><li><a href="solvers/#Iterative-LQR-(iLQR)-1">Iterative LQR (iLQR)</a></li><li><a href="solvers/#Augmented-Lagrangian-1">Augmented Lagrangian</a></li><li><a href="solvers/#ALTRO-1">ALTRO</a></li><li><a href="solvers/#Direct-Collocation-(DIRCOL)-1">Direct Collocation (DIRCOL)</a></li><li><a href="problem/#Setting-up-a-Problem-1">Setting up a Problem</a></li><ul><li><a href="problem/#Creating-a-Problem-1">Creating a Problem</a></li><li><a href="problem/#Adding-constraints-1">Adding constraints</a></li></ul><li><a href="#TrajectoryOptimization.jl-1">TrajectoryOptimization.jl</a></li><li><a href="#Overview-1">Overview</a></li><li><a href="#Getting-Started-1">Getting Started</a></li><ul><li><a href="#Creating-a-Model-1">Creating a Model</a></li><li><a href="#Creating-an-Objective-1">Creating an Objective</a></li><li><a href="#Solving-the-Problem-1">Solving the Problem</a></li><li><a href="#Solve-Methods-1">Solve Methods</a></li><li><a href="#Direct-Collocation-(DIRCOL)-1">Direct Collocation (DIRCOL)</a></li></ul><li><a href="costfunctions/#.-Setting-up-a-Cost-Function-1">2. Setting up a Cost Function</a></li><li><a href="costfunctions/#Overview-1">Overview</a></li><li><a href="costfunctions/#Creating-a-Cost-function-1">Creating a Cost function</a></li><ul><li><a href="costfunctions/#Quadratic-Costs-1">Quadratic Costs</a></li><li><a href="costfunctions/#Generic-Costs-1">Generic Costs</a></li></ul></ul><h1><a class="nav-anchor" id="Overview-1" href="#Overview-1">Overview</a></h1><p>This package is a testbed for state-of-the-art trajectory optimization algorithms. Trajectory optimization problems are of the form, (put LaTeX here)</p><p>This package currently implements both indirect and direct methods for trajectory optimization:</p><ul><li>Iterative LQR (iLQR): indirect method based on Differential Dynamic Programming</li><li>Direct Collocation: direct method that formulates the problem as an NLP and passes the problem off to a commercial NLP solver</li></ul><p>Key features include the use of ForwardDiff for fast auto-differentiation of dynamics, cost functions, and constraints; the use of RigidBodyDynamics to work directly from URDF files; and the ability to specify general constraints.</p><h1><a class="nav-anchor" id="Getting-Started-1" href="#Getting-Started-1">Getting Started</a></h1><p>To set up and solve a trajectory optimization problem with TrajectoryOptimization.jl, the user will go through the following steps:</p><ol><li>Create a <a href="@ref">Model</a></li><li>Create an <a href="@ref">Objective</a></li><li>Instantiate a <a href="@ref">Problem</a></li><li>(Optionally) Add constraints</li><li>Select a solver</li><li>Solve the problem</li><li>Analyze the solution</li></ol><h2><a class="nav-anchor" id="Creating-a-Model-1" href="#Creating-a-Model-1">Creating a Model</a></h2><p>There are two ways of creating a model:</p><ol><li>from an in-place analytic function of the form f(y,x,u) that operates on y</li><li>from a URDF file</li></ol><h3><a class="nav-anchor" id="Analytic-Models-1" href="#Analytic-Models-1">Analytic Models</a></h3><p>To create an analytic model, first create an in-place function for the continuous or discrete dynamics. The function must be of the form <code>f(y,x,u)</code> where y ∈ Rⁿ is the state derivative vector for continuous dynamics or the next state for discrete dynamics. x ∈ Rⁿ is the state vector, and u ∈ Rᵐ is the control input vector. The function should not return any values, but should write y &quot;inplace,&quot; e.g. <code>y[1] = x[2]*u[2]</code> NOT <code>y = f(x,u)</code>. This makes a significant difference in performance.</p><p>The Model type is then created using the following signature: <code>model = Model{D}(f,n,m)</code> where <code>n</code> is the dimension of the state input and <code>m</code> is the dimension of the control input, and D is a DynamicsType, either Continuous of Discrete.</p><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>Model{D}(f::Function, n::Int, m::Int)</code>. Check Documenter&#39;s build log for details.</p></div></div><h3><a class="nav-anchor" id="URDF-Model-1" href="#URDF-Model-1">URDF Model</a></h3><p>This package relies on RigidBodyDynamics.jl to parse URDFs and generate dynamics functions for them. There are several useful constructors:</p><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>Model(mech::Mechanism)</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>Model(mech::Mechanism, torques::Array)</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>Model(urdf::String)</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>Model(urdf::String, torques::Array)</code>. Check Documenter&#39;s build log for details.</p></div></div><h2><a class="nav-anchor" id="Creating-an-Objective-1" href="#Creating-an-Objective-1">Creating an Objective</a></h2><p>The <a href="@ref"><code>Objective</code></a> defines a metric for what you want the dynamics to do. The Objective type contains a CostFunctions for each stage of the trajectory.</p><h3><a class="nav-anchor" id="Creating-a-Cost-Function-1" href="#Creating-a-Cost-Function-1">Creating a Cost Function</a></h3><p>A <a href="@ref"><code>CostFunction</code></a> is required for each stage of the trajectory to define an Objective. While the majority of trajectory optimization problems have quadratic objectives, TrajectoryOptimization.jl allows the user to specify any generic cost function of the form <span>$\ell_N(x_N) + \sum_{k=0}^N \ell_k(x_k,u_k)$</span>. Currently GenericObjective is only supported by iLQR, and not by DIRCOL. Since iLQR relies on 2nd Order Taylor Series Expansions of the cost, the user may specify analytical functions for this expansion in order to increase performance; if the user does not specify an analytical expansion it will be generated using ForwardDiff.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrajectoryOptimization.QuadraticCost" href="#TrajectoryOptimization.QuadraticCost"><code>TrajectoryOptimization.QuadraticCost</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">mutable struct QuadraticCost{T} &lt;: TrajectoryOptimization.CostFunction</code></pre><p>Cost function of the form     1/2xₙᵀ Qf xₙ + qfᵀxₙ +  ∫ ( 1/2xᵀQx + 1/2uᵀRu + xᵀHu + q⁠ᵀx  rᵀu ) dt from 0 to tf R must be positive definite, Q and Qf must be positive semidefinite</p></div></div><a class="source-link" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/62f2a5e53d43919c09ffd21c8d463c15178a4814/src/cost.jl#L72">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrajectoryOptimization.LQRCost" href="#TrajectoryOptimization.LQRCost"><code>TrajectoryOptimization.LQRCost</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">LQRCost(Q, R, Qf, xf)
</code></pre><p>Cost function of the form     1/2(xₙ-x<em>f)ᵀ Qf (xₙ - x</em>f) + 1/2 ∫ ( (x-x_f)ᵀQ(x-xf) + uᵀRu ) dt from 0 to tf R must be positive definite, Q and Qf must be positive semidefinite</p></div></div><a class="source-link" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/62f2a5e53d43919c09ffd21c8d463c15178a4814/src/cost.jl#L107">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrajectoryOptimization.GenericCost" href="#TrajectoryOptimization.GenericCost"><code>TrajectoryOptimization.GenericCost</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct GenericCost &lt;: TrajectoryOptimization.CostFunction</code></pre><p>Cost function of the form     ℓf(xₙ) + ∫ ℓ(x,u) dt from 0 to tf</p></div></div><a class="source-link" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/62f2a5e53d43919c09ffd21c8d463c15178a4814/src/cost.jl#L173">source</a></section><h2><a class="nav-anchor" id="Solving-the-Problem-1" href="#Solving-the-Problem-1">Solving the Problem</a></h2><p>With a defined model and objective, the next step is to create a <a href="#TrajectoryOptimization.Problem"><code>Problem</code></a> type. The Problem contains both the Model and Objective and contains all information needed for the solve.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrajectoryOptimization.Problem" href="#TrajectoryOptimization.Problem"><code>TrajectoryOptimization.Problem</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct Problem{T&lt;:AbstractFloat, D&lt;:TrajectoryOptimization.DynamicsType}</code></pre><p>Trajectory Optimization Problem</p></div></div><a class="source-link" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/62f2a5e53d43919c09ffd21c8d463c15178a4814/src/problem.jl#L1">source</a></section><p>Once the Problem is instantiated, the user must create an initial guess for the control trajectory, and optionally a state trajectory. For simple problems a initialization of random values, ones, or zeros works well. For more complicated systems it is usually recommended to feed trim conditions, i.e. controls that maintain the initial state values. Note that for trajectory optimization the control trajectory should be length N-1 since there are no controls at the final time step. However, DIRCOL uses controls at the final time step, and iLQR will simply discard any controls at the time step. Therefore, an initial control trajectory of size (m,N) is valid (but be aware that iLQR will return the correctly-sized control trajectory). Once the initial state and control trajectories are specified, they are passed with the solver to one of the <a href="@ref"><code>solve</code></a> methods.</p><h2><a class="nav-anchor" id="Solve-Methods-1" href="#Solve-Methods-1">Solve Methods</a></h2><p>With a Problem instantiated, the user can then select a solver: iLQR, AugmentedLagrangian, ALTRO, DIRCOL.</p><h3><a class="nav-anchor" id="Unconstrained-Methods-1" href="#Unconstrained-Methods-1">Unconstrained Methods</a></h3><p>iLQR is an unconstrained solver. For unconstrained Problems simply call the <code>solve</code> method:</p><pre><code class="language-none">solve(prob,iLQRSolverOptions())</code></pre><h3><a class="nav-anchor" id="Constrained-Methods-1" href="#Constrained-Methods-1">Constrained Methods</a></h3><h4><a class="nav-anchor" id="Augmented-Lagrangian-1" href="#Augmented-Lagrangian-1">Augmented Lagrangian</a></h4><p>The default constrained solver uses iLQR with an augmented Lagrangian framework to handle general nonlinear constraints. <a href="@ref">AugmentedLagrangianSolverOptions</a> can be changed to effect solver performance. Other than now having more parameters to tune for better performance (see another section for tips), the user solves a constrained problem using the exact same method for solving an unconstrained problem.</p><h4><a class="nav-anchor" id="ALTRO-1" href="#ALTRO-1">ALTRO</a></h4><h3><a class="nav-anchor" id="Constrained-Problem-with-Infeasible-Start-1" href="#Constrained-Problem-with-Infeasible-Start-1">Constrained Problem with Infeasible Start</a></h3><p>One of the primary disadvantages of iLQR (and most indirect methods) is that the user must specify an initial input trajectory. Specifying a good initial guess can often be difficult in practice, whereas specifying a guess for the state trajectory is typically more straightforward. To overcome this limitation, the ALTRO solver adds slack controls to the discrete dynamics <span>$x_{k+1} = f_d(x_k,u_k) + \diag{(\tidle{u}_1,\hdots,\tidle{u}_n)}$</span> such that the system becomes artificially fully-actuated These slack controls are then constrained to be zero using the augmented Lagrangian method. This results in an algorithm similar to that of DIRCOL: initial solutions are dynamically infeasible but become dynamically infeasible at convergence. To solve the problem using &quot;infeasible start&quot;, simply pass in an initial guess for the state and control:</p><pre><code class="language-none">copyto!(prob.X,X0)
solve(prob,ALTROSolverOptions())</code></pre><h3><a class="nav-anchor" id="Minimum-Time-Problem-1" href="#Minimum-Time-Problem-1">Minimum Time Problem</a></h3><p>A minimum time problem can be solved using the ALTRO solver by setting tf=:min</p><h2><a class="nav-anchor" id="Direct-Collocation-(DIRCOL)-1" href="#Direct-Collocation-(DIRCOL)-1">Direct Collocation (DIRCOL)</a></h2><p>Problems can be solved using DIRCOL by simply calling</p><pre><code class="language-none">solve(prob,DIRCOLSolverOptions())</code></pre><footer><hr/><a class="next" href="models/"><span class="direction">Next</span><span class="title">1. Setting up a Dynamics Model</span></a></footer></article></body></html>
