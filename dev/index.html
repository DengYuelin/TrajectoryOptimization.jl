<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>TrajectoryOptimization.jl · TrajectoryOptimization</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>TrajectoryOptimization</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>TrajectoryOptimization.jl</a><ul class="internal"><li class="toplevel"><a class="toctext" href="#Overview-1">Overview</a></li><li class="toplevel"><a class="toctext" href="#Getting-Started-1">Getting Started</a></li><li><a class="toctext" href="#Creating-a-Model-1">Creating a Model</a></li><li><a class="toctext" href="#Creating-an-Objective-1">Creating an Objective</a></li><li><a class="toctext" href="#Solving-the-Problem-1">Solving the Problem</a></li><li><a class="toctext" href="#Solve-Methods-1">Solve Methods</a></li><li><a class="toctext" href="#DIRCOL-Method-1">DIRCOL Method</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>TrajectoryOptimization.jl</a></li></ul><a class="edit-page" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/master/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>TrajectoryOptimization.jl</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="TrajectoryOptimization.jl-1" href="#TrajectoryOptimization.jl-1">TrajectoryOptimization.jl</a></h1><p>Documentation for TrajectoryOptimization.jl</p><ul><li><a href="#TrajectoryOptimization.jl-1">TrajectoryOptimization.jl</a></li><li><a href="#Overview-1">Overview</a></li><li><a href="#Getting-Started-1">Getting Started</a></li><ul><li><a href="#Creating-a-Model-1">Creating a Model</a></li><li><a href="#Creating-an-Objective-1">Creating an Objective</a></li><li><a href="#Solving-the-Problem-1">Solving the Problem</a></li><li><a href="#Solve-Methods-1">Solve Methods</a></li><li><a href="#DIRCOL-Method-1">DIRCOL Method</a></li></ul></ul><h1><a class="nav-anchor" id="Overview-1" href="#Overview-1">Overview</a></h1><p>The purpose of this package is to provide a testbed for state-of-the-art trajectory optimization algorithms. In general, this package focuses on trajectory optimization problems of the form (put LaTeX here)</p><p>This package currently implements both indirect and direct methods for trajectory optimization:</p><ul><li>Iterative LQR (iLQR): indirect method based on differential dynamic programming</li><li>Direct Collocation: direct method that formulates the problem as an NLP and passes the problem off to a commercial NLP solver</li></ul><p>Key features include the use of ForwardDiff for fast auto-differentiation of dynamics, cost functions, and constraints; the use of RigidBodyDynamics to work directly from URDF files; and the ability to specify general constraints.</p><p>The primary focus of this package is developing the iLQR algorithm, although we hope this will extend to many algorithms in the future.</p><h1><a class="nav-anchor" id="Getting-Started-1" href="#Getting-Started-1">Getting Started</a></h1><p>In order to set up a trajectory optimization problem, the user needs to create a Model and Objective</p><h2><a class="nav-anchor" id="Creating-a-Model-1" href="#Creating-a-Model-1">Creating a Model</a></h2><p>There are two ways of creating a model:</p><ol><li>An in-place analytic function of the form f(ẋ,x,u)</li><li>A URDF</li></ol><h3><a class="nav-anchor" id="Analytic-Models-1" href="#Analytic-Models-1">Analytic Models</a></h3><p>To create an analytic model create an in-place function for the continuous dynamics. The function must be of the form <code>f(ẋ,x,u)</code> where ẋ ∈ Rⁿ is the state derivative vector, x ∈ Rⁿ is the state vector, and u ∈ Rᵐ is the control input vector. The function should not return any values, but should write ẋ &quot;inplace,&quot; e.g. <code>ẋ[1] = x[2]*u[2]</code> NOT <code>ẋ = f(x,u)</code>. This makes a significant difference in performance.</p><p>Specifying discrete-time dynamics directly is currently not supported (but should be straight-forward to implement).</p><p>The Model type is then created using the following signature: <code>model = Model(f,n,m)</code> where <code>n</code> is the dimension of the state input and <code>m</code> is the dimension of the control input.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrajectoryOptimization.Model-Tuple{Function,Int64,Int64}" href="#TrajectoryOptimization.Model-Tuple{Function,Int64,Int64}"><code>TrajectoryOptimization.Model</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Model(f, n, m)
Model(f, n, m, d)
</code></pre><p>Create a Model given an inplace analytical function for the continuous dynamics with n states and m controls</p></div></div><a class="source-link" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/9c0ac91bc8be06df93221d1248dfaf561c4e90e9/src/model.jl#L41">source</a></section><h3><a class="nav-anchor" id="URDF-Model-1" href="#URDF-Model-1">URDF Model</a></h3><p>This package relies on RigidBodyDynamics.jl to parse URDFs and generate dynamics functions for them. There are several useful constructors:</p><pre><code class="language-none">Model(mech::Mechanism)
Model(mech::Mechanism, torques::Array)
Model(urdf::String)
Model(urdf::String, torques::Array)</code></pre><h2><a class="nav-anchor" id="Creating-an-Objective-1" href="#Creating-an-Objective-1">Creating an Objective</a></h2><p>While the model defines the dynamics of the system, the Objective defines what you want the dynamics to do. The Objective class defines the objective function via a <a href="@ref"><code>CostFunction</code></a> type, as well as the initial states and trajectory duration. The Objective class also specifies constraints on the states and controls. Both iLQR and Direct Collocation (DIRCOL) allow generic cost functions of the form <span>$g(x,u) \leq 0$</span> or <span>$h(x,u) = 0$</span>: any generic function of the state and control is permitted, but no couples between time steps is allowed.</p><h3><a class="nav-anchor" id="Creating-a-Cost-Function-1" href="#Creating-a-Cost-Function-1">Creating a Cost Function</a></h3><p>The cost (or objective) function is the first piece of the objective. While the majority of trajectory optimization problems have quadratic objectives, TrjaectoryOptimization.jl allows the user to specify any generic cost function of the form <span>$\ell_N(x_N) + \sum_{k=0}^N \ell(x_k,u_k)$</span>. Currently GenericObjective is only supported by iLQR, and not by DIRCOL. Since iLQR relies on 2nd Order Taylor Series Expansions of the cost, the user may specify analytical functions for this expansion in order to increase performance; if the user does not specify an analytical expansion it will be generated using ForwardDiff.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrajectoryOptimization.QuadraticCost" href="#TrajectoryOptimization.QuadraticCost"><code>TrajectoryOptimization.QuadraticCost</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">mutable struct QuadraticCost{TM, TH, TV, T} &lt;: TrajectoryOptimization.CostFunction</code></pre><p>Cost function of the form     xₙᵀ Qf xₙ + qfᵀxₙ + ∫ ( xᵀQx + uᵀRu + xᵀHu + q⁠ᵀx  rᵀu ) dt from 0 to tf R must be positive definite, Q and Qf must be positive semidefinite</p></div></div><a class="source-link" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/9c0ac91bc8be06df93221d1248dfaf561c4e90e9/src/objective.jl#L9">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrajectoryOptimization.LQRCost" href="#TrajectoryOptimization.LQRCost"><code>TrajectoryOptimization.LQRCost</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">LQRCost(Q, R, Qf, xf)
</code></pre><p>Cost function of the form     (xₙ-x<em>f)ᵀ Qf (xₙ - x</em>f) ∫ ( (x-x_f)ᵀQ(x-xf) + uᵀRu ) dt from 0 to tf R must be positive definite, Q and Qf must be positive semidefinite</p></div></div><a class="source-link" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/9c0ac91bc8be06df93221d1248dfaf561c4e90e9/src/objective.jl#L43">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrajectoryOptimization.GenericCost" href="#TrajectoryOptimization.GenericCost"><code>TrajectoryOptimization.GenericCost</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct GenericCost &lt;: TrajectoryOptimization.CostFunction</code></pre><p>Cost function of the form     ℓf(xₙ) + ∫ ℓ(x,u) dt from 0 to tf</p></div></div><a class="source-link" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/9c0ac91bc8be06df93221d1248dfaf561c4e90e9/src/objective.jl#L87">source</a></section><h3><a class="nav-anchor" id="Creating-the-Objective-1" href="#Creating-the-Objective-1">Creating the Objective</a></h3><p>Once the cost function is specified, the user then creates either an Unconstrained or Constrained Objective. When running iLQR, specifying any ConstrainedObjective will perform outer loop updates using an Augmented Lagrangian method.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrajectoryOptimization.UnconstrainedObjective" href="#TrajectoryOptimization.UnconstrainedObjective"><code>TrajectoryOptimization.UnconstrainedObjective</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct UnconstrainedObjective{C} &lt;: TrajectoryOptimization.Objective</code></pre><p>Defines an objective for an unconstrained optimization problem. xf does not have to specified. It is provided for convenience when used as part of the cost function (see LQRObjective function) If tf = 0, the objective is assumed to be minimum-time.</p></div></div><a class="source-link" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/9c0ac91bc8be06df93221d1248dfaf561c4e90e9/src/objective.jl#L201">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrajectoryOptimization.ConstrainedObjective" href="#TrajectoryOptimization.ConstrainedObjective"><code>TrajectoryOptimization.ConstrainedObjective</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct ConstrainedObjective{C} &lt;: TrajectoryOptimization.Objective</code></pre><p>Define a quadratic objective for a constrained optimization problem.</p><p><strong>Constraint formulation</strong></p><ul><li>Equality constraints: <code>f(x,u) = 0</code></li><li>Inequality constraints: <code>f(x,u) ≥ 0</code></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/9c0ac91bc8be06df93221d1248dfaf561c4e90e9/src/objective.jl#L245">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrajectoryOptimization.LQRObjective" href="#TrajectoryOptimization.LQRObjective"><code>TrajectoryOptimization.LQRObjective</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">LQRObjective(Q, R, Qf, tf, x0, xf)
</code></pre><p>Create unconstrained objective for a problem of the form:     min (xₙ - xf)ᵀ Qf (xₙ - xf) + ∫ ( (x-xf)ᵀQ(x-xf) + uᵀRu ) dt from 0 to tf     s.t. x(0) = x0          x(tf) = xf</p></div></div><a class="source-link" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/9c0ac91bc8be06df93221d1248dfaf561c4e90e9/src/objective.jl#L504">source</a></section><p>Since objectives are immutable types, the user can &quot;update&quot; the objective using the following function</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrajectoryOptimization.update_objective" href="#TrajectoryOptimization.update_objective"><code>TrajectoryOptimization.update_objective</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">update_objective(obj; cost, tf, x0, xf, u_min, u_max, x_min, x_max, cI, cE, cI_N, cE_N, use_xf_equality_constraint, cIx, cIu, cEx, cEu, cI_Nx, cE_Nx)
</code></pre><p>Updates constrained objective values and returns a new objective.</p><p>Only updates the specified fields, all others are copied from the previous Objective.</p></div></div><a class="source-link" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/9c0ac91bc8be06df93221d1248dfaf561c4e90e9/src/objective.jl#L442">source</a></section><h2><a class="nav-anchor" id="Solving-the-Problem-1" href="#Solving-the-Problem-1">Solving the Problem</a></h2><p>With a defined model and objective, the next step is to create a <a href="#TrajectoryOptimization.Solver"><code>Solver</code></a> type. The Solver is responsible for storing solve-dependent variables (such as number of knot points, step size, discrete dynamics functions, etc.) and storing parameters used during the solve (via <a href="@ref"><code>SolverOptions</code></a>). The solver contains both the Model and Objective and contains all information needed for the solve, except for the initial trajectories.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrajectoryOptimization.Solver" href="#TrajectoryOptimization.Solver"><code>TrajectoryOptimization.Solver</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct Solver{M&lt;:Model, O&lt;:TrajectoryOptimization.Objective}</code></pre><p>Responsible for storing all solve-dependent variables and solve parameters.</p></div></div><a class="source-link" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/9c0ac91bc8be06df93221d1248dfaf561c4e90e9/src/solver.jl#L36">source</a></section><p>Once the solver is created, the user must create an initial guess for the control trajectory, and optionally a state trajectory. For simple problems a initialization of random values, ones, or zeros works well. For more complicated systems it is usually recommended to feed trim conditions, i.e. controls that maintain the initial state values. For convenience, the function <a href="@ref"><code>get_sizes</code></a> returns n,m,N from the solver. Note that for trajectory optimization the control trajectory should be length N-1 since there are no controls at the final time step. However, DIRCOL uses controls at the final time step, and iLQR will simply discard any controls at the time step. Therefore, an initial control trajectory of size (m,N) is valid (but be aware that iLQR will return the correctly-sized control trajectory). Once the initial state and control trajectories are specified, they are passed with the solver to one of the <a href="@ref"><code>solve</code></a> methods.</p><h2><a class="nav-anchor" id="Solve-Methods-1" href="#Solve-Methods-1">Solve Methods</a></h2><p>With a Solver instantiated, the user can then choose to solve the problem using iLQR (<code>solve</code> function) or DIRCOL (<code>solve_dircol</code> function), where are detailed below</p><h3><a class="nav-anchor" id="iLQR-Methods-1" href="#iLQR-Methods-1">iLQR Methods</a></h3><h4><a class="nav-anchor" id="Unconstrained-Problem-1" href="#Unconstrained-Problem-1">Unconstrained Problem</a></h4><p>For unconstrained problems the user doesn&#39;t have any options. iLQR can usually solve unconstrained problems without any modification. Simply call the <code>solve</code> method, passing in a initial guess for the control trajectory:</p><pre><code class="language-none">solve(solver,U0)</code></pre><p>where <code>U0</code> is a Matrix of size <code>(m,N-1)</code> (although a trajectory of N points will also be accepted).</p><h3><a class="nav-anchor" id="Constrained-Problem-1" href="#Constrained-Problem-1">Constrained Problem</a></h3><p>The default constrained iLQR method uses an Augmented Lagrangian approach to handle the constraints. Nearly all of the options in <a href="@ref">SolverOptions</a> determine parameters used by the Augmented Lagrangian method. Other than now having more parameters to tune for better performance (see another section for tips), the user solves a constrained problem using the exact same method for solving an unconstrained problem.</p><h3><a class="nav-anchor" id="Constrained-Problem-with-Infeasible-Start-1" href="#Constrained-Problem-with-Infeasible-Start-1">Constrained Problem with Infeasible Start</a></h3><p>One of the primary disadvantages of iLQR (and most indirect methods) is that the user must specify an initial input trajectory. Specifying a good initial guess can often be difficult in practice, whereas specifying a guess for the state trajectory is typically more straightforward. To overcome this limitation, TrajectoryOptimization adds artificial controls to the discrete dynamics $x<em>{k+1} = f</em>d(x<em>k,u</em>k) + \diag{(\tidle{u}<em>1,\hdots,\tidle{u}</em>n)} such that the system is fully-actuated (technically over-actuated), so that an arbitrary state trajectory can be achieved. These artificial controls are then constrained to be zero using the Augmented Lagrangian method. This results in an algorithm similar to that of DIRCOL: initial solutions are dynamically infeasible but become dynamically infeasible at convergence. To solve the problem using &quot;infeasible start&quot;, simply pass in an initial guess for the state and control:</p><pre><code class="language-none">solve(solver,X0,U0)</code></pre><h2><a class="nav-anchor" id="DIRCOL-Method-1" href="#DIRCOL-Method-1">DIRCOL Method</a></h2><p>Problems can be solved using DIRCOL by simply calling</p><pre><code class="language-none">solve_dircol(solver,X0,U0)</code></pre><footer><hr/></footer></article></body></html>
