<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Solvers · TrajectoryOptimization</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>TrajectoryOptimization</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">TrajectoryOptimization.jl</a></li><li><a class="toctext" href="../models/">1. Setting up a Dynamics Model</a></li><li><a class="toctext" href="../costfunctions/">2. Setting up a Cost Function</a></li><li><a class="toctext" href="../constraints/">4. Add Constraints</a></li><li><a class="toctext" href="../problem/">Setting up a Problem</a></li><li class="current"><a class="toctext" href>Solvers</a><ul class="internal"><li class="toplevel"><a class="toctext" href="#Iterative-LQR-(iLQR)-1">Iterative LQR (iLQR)</a></li><li class="toplevel"><a class="toctext" href="#Augmented-Lagrangian-1">Augmented Lagrangian</a></li><li class="toplevel"><a class="toctext" href="#ALTRO-1">ALTRO</a></li><li class="toplevel"><a class="toctext" href="#Direct-Collocation-(DIRCOL)-1">Direct Collocation (DIRCOL)</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Solvers</a></li></ul><a class="edit-page" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/master/docs/src/solvers.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Solvers</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Solvers-1" href="#Solvers-1">Solvers</a></h1><ul><li><a href="#Solvers-1">Solvers</a></li><li><a href="#Iterative-LQR-(iLQR)-1">Iterative LQR (iLQR)</a></li><li><a href="#Augmented-Lagrangian-1">Augmented Lagrangian</a></li><li><a href="#ALTRO-1">ALTRO</a></li><li><a href="#Direct-Collocation-(DIRCOL)-1">Direct Collocation (DIRCOL)</a></li></ul><h1><a class="nav-anchor" id="Iterative-LQR-(iLQR)-1" href="#Iterative-LQR-(iLQR)-1">Iterative LQR (iLQR)</a></h1><p>iLQR is an unconstrained indirect method for trajectory optimization that parameterizes only the controls and enforces strict dynamics feasibility at every iteration by simulating forward the dynamics with an LQR feedback controller. The main algorithm consists of two parts: 1) a backward pass that uses Differential Dynamic Programming to compute recursively a quadratic approximation of the cost-to-go, along with linear feedback and feed-forward gain matrices, <code>K</code> and <code>d</code>, respectively, for an LQR tracking controller, and 2) a forward pass that uses the gains <code>K</code> and <code>d</code> to simulate forward the full nonlinear dynamics with feedback.</p><p>The iLQR solver has the following solver options</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrajectoryOptimization.iLQRSolverOptions" href="#TrajectoryOptimization.iLQRSolverOptions"><code>TrajectoryOptimization.iLQRSolverOptions</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">mutable struct iLQRSolverOptions{T} &lt;: TrajectoryOptimization.AbstractSolverOptions{T}</code></pre><p>Solver options for the iterative LQR (iLQR) solver. iLQR is an indirect, unconstrained solver.</p><ul><li><p><code>verbose</code></p><p>Print summary at each iteration Default: false</p></li><li><p><code>live_plotting</code></p><p>Live plotting Default: :off</p></li><li><p><code>cost_tolerance</code></p><p>dJ &lt; ϵ, cost convergence criteria for unconstrained solve or to enter outerloop for constrained solve Default: 0.0001</p></li><li><p><code>gradient_type</code></p><p>gradient type: :todorov, :feedforward Default: :todorov</p></li><li><p><code>gradient_norm_tolerance</code></p><p>gradient_norm &lt; ϵ, gradient norm convergence criteria Default: 1.0e-5</p></li><li><p><code>iterations</code></p><p>iLQR iterations Default: 300</p></li><li><p><code>dJ_counter_limit</code></p><p>restricts the total number of times a forward pass fails, resulting in regularization, before exiting Default: 10</p></li><li><p><code>square_root</code></p><p>use square root method backward pass for numerical conditioning Default: false</p></li><li><p><code>line_search_lower_bound</code></p><p>forward pass approximate line search lower bound, 0 &lt; line<em>search</em>lower<em>bound &lt; line</em>search<em>upper</em>bound Default: 1.0e-8</p></li><li><p><code>line_search_upper_bound</code></p><p>forward pass approximate line search upper bound, 0 &lt; line<em>search</em>lower<em>bound &lt; line</em>search<em>upper</em>bound &lt; ∞ Default: 10.0</p></li><li><p><code>iterations_linesearch</code></p><p>maximum number of backtracking steps during forward pass line search Default: 20</p></li><li><p><code>bp_reg_initial</code></p><p>initial regularization Default: 0.0</p></li><li><p><code>bp_reg_increase_factor</code></p><p>regularization scaling factor Default: 1.6</p></li><li><p><code>bp_reg_max</code></p><p>maximum regularization value Default: 1.0e8</p></li><li><p><code>bp_reg_min</code></p><p>minimum regularization value Default: 1.0e-8</p></li><li><p><code>bp_reg_type</code></p><p>type of regularization- control: () + ρI, state: (S + ρI); see Synthesis and Stabilization of Complex Behaviors through Online Trajectory Optimization Default: :control</p></li><li><p><code>bp_reg_fp</code></p><p>additive regularization when forward pass reaches max iterations Default: 10.0</p></li><li><p><code>bp_sqrt_inv_type</code></p><p>type of matrix inversion for bp sqrt step Default: :pseudo</p></li><li><p><code>bp_reg_sqrt_initial</code></p><p>initial regularization for square root method Default: 1.0e-6</p></li><li><p><code>bp_reg_sqrt_increase_factor</code></p><p>regularization scaling factor for square root method Default: 10.0</p></li><li><p><code>max_cost_value</code></p><p>maximum cost value, if exceded solve will error Default: 1.0e8</p></li><li><p><code>max_state_value</code></p><p>maximum state value, evaluated during rollout, if exceded solve will error Default: 1.0e8</p></li><li><p><code>max_control_value</code></p><p>maximum control value, evaluated during rollout, if exceded solve will error Default: 1.0e8</p></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0">source</a></section><h1><a class="nav-anchor" id="Augmented-Lagrangian-1" href="#Augmented-Lagrangian-1">Augmented Lagrangian</a></h1><p>Augmented Lagrangian</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrajectoryOptimization.AugmentedLagrangianSolverOptions" href="#TrajectoryOptimization.AugmentedLagrangianSolverOptions"><code>TrajectoryOptimization.AugmentedLagrangianSolverOptions</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">mutable struct AugmentedLagrangianSolverOptions{T} &lt;: TrajectoryOptimization.AbstractSolverOptions{T}</code></pre><p>Solver options for the augmented Lagrangian solver.     Augmented Lagrangian is a general method for solving constrained problems by solving a sequence of unconstrained problems.</p><ul><li><p><code>verbose</code></p><p>Print summary at each iteration Default: false</p></li><li><p><code>opts_uncon</code></p><p>unconstrained solver options Default: iLQRSolverOptions{T}()</p></li><li><p><code>cost_tolerance</code></p><p>dJ &lt; ϵ, cost convergence criteria for unconstrained solve or to enter outerloop for constrained solve Default: 0.0001</p></li><li><p><code>cost_tolerance_intermediate</code></p><p>dJ &lt; ϵ_int, intermediate cost convergence criteria to enter outerloop of constrained solve Default: 0.001</p></li><li><p><code>gradient_norm_tolerance</code></p><p>gradient_norm &lt; ϵ, gradient norm convergence criteria Default: 1.0e-5</p></li><li><p><code>gradient_norm_tolerance_intermediate</code></p><p>gradient<em>norm</em>int &lt; ϵ, gradient norm intermediate convergence criteria Default: 1.0e-5</p></li><li><p><code>constraint_tolerance</code></p><p>max(constraint) &lt; ϵ, constraint convergence criteria Default: 0.001</p></li><li><p><code>constraint_tolerance_intermediate</code></p><p>max(constraint) &lt; ϵ_int, intermediate constraint convergence criteria Default: 0.001</p></li><li><p><code>iterations</code></p><p>maximum outerloop updates Default: 30</p></li><li><p><code>dual_min</code></p><p>minimum Lagrange multiplier Default: -1.0e8</p></li><li><p><code>dual_max</code></p><p>maximum Lagrange multiplier Default: 1.0e8</p></li><li><p><code>penalty_max</code></p><p>maximum penalty term Default: 1.0e8</p></li><li><p><code>penalty_initial</code></p><p>initial penalty term Default: 1.0</p></li><li><p><code>penalty_scaling</code></p><p>penalty update multiplier; penalty_scaling &gt; 0 Default: 10.0</p></li><li><p><code>penalty_scaling_no</code></p><p>penalty update multiplier when μ should not be update, typically 1.0 (or 1.0 + ϵ) Default: 1.0</p></li><li><p><code>constraint_decrease_ratio</code></p><p>ratio of current constraint to previous constraint violation; 0 &lt; constraint<em>decrease</em>ratio &lt; 1 Default: 0.25</p></li><li><p><code>outer_loop_update_type</code></p><p>type of outer loop update (default, feedback) Default: :default</p></li><li><p><code>active_constraint_tolerance</code></p><p>numerical tolerance for constraint violation Default: 0.0</p></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0">source</a></section><h1><a class="nav-anchor" id="ALTRO-1" href="#ALTRO-1">ALTRO</a></h1><p>ALTRO</p><pre><code class="language-none">ALTROSolverOptions</code></pre><h1><a class="nav-anchor" id="Direct-Collocation-(DIRCOL)-1" href="#Direct-Collocation-(DIRCOL)-1">Direct Collocation (DIRCOL)</a></h1><footer><hr/><a class="previous" href="../problem/"><span class="direction">Previous</span><span class="title">Setting up a Problem</span></a></footer></article></body></html>
