<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Solvers · TrajectoryOptimization</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>TrajectoryOptimization</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">TrajectoryOptimization.jl Documentation</a></li><li><a class="toctext" href="../models/">1. Setting up a Dynamics Model</a></li><li><a class="toctext" href="../costfunctions/">2. Setting up an Objective</a></li><li><a class="toctext" href="../constraints/">3. Creating Constraints</a></li><li><a class="toctext" href="../problem/">4. Setting up a Problem</a></li><li class="current"><a class="toctext" href>Solvers</a><ul class="internal"><li><a class="toctext" href="#Iterative-LQR-(iLQR)-1">Iterative LQR (iLQR)</a></li><li><a class="toctext" href="#Augmented-Lagrangian-1">Augmented Lagrangian</a></li><li><a class="toctext" href="#ALTRO-1">ALTRO</a></li><li><a class="toctext" href="#Direct-Collocation-(DIRCOL)-1">Direct Collocation (DIRCOL)</a></li><li><a class="toctext" href="#Projected-Newton-1">Projected Newton</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Solvers</a></li></ul><a class="edit-page" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/master/docs/src/solvers.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Solvers</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Solvers-1" href="#Solvers-1">Solvers</a></h1><ul><li><a href="#Solvers-1">Solvers</a></li><ul><li><a href="#Iterative-LQR-(iLQR)-1">Iterative LQR (iLQR)</a></li><li><a href="#Augmented-Lagrangian-1">Augmented Lagrangian</a></li><li><a href="#ALTRO-1">ALTRO</a></li><li><a href="#Direct-Collocation-(DIRCOL)-1">Direct Collocation (DIRCOL)</a></li><li><a href="#Projected-Newton-1">Projected Newton</a></li></ul></ul><h2><a class="nav-anchor" id="Iterative-LQR-(iLQR)-1" href="#Iterative-LQR-(iLQR)-1">Iterative LQR (iLQR)</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrajectoryOptimization.iLQRSolver" href="#TrajectoryOptimization.iLQRSolver"><code>TrajectoryOptimization.iLQRSolver</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct iLQRSolver{T} &lt;: TrajectoryOptimization.AbstractSolver{T}</code></pre><p>iLQR is an unconstrained indirect method for trajectory optimization that parameterizes only the controls and enforces strict dynamics feasibility at every iteration by simulating forward the dynamics with an LQR feedback controller. The main algorithm consists of two parts:</p><ol><li>a backward pass that uses Differential Dynamic Programming to compute recursively a quadratic approximation of the cost-to-go, along with linear feedback and feed-forward gain matrices, <code>K</code> and <code>d</code>, respectively, for an LQR tracking controller, and</li><li>a forward pass that uses the gains <code>K</code> and <code>d</code> to simulate forward the full nonlinear dynamics with feedback.</li></ol></div></div><a class="source-link" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/2ea839be5a504992bf02865f34a4c376ca18e2a3/src/solvers/ilqr.jl#L87">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrajectoryOptimization.iLQRSolverOptions" href="#TrajectoryOptimization.iLQRSolverOptions"><code>TrajectoryOptimization.iLQRSolverOptions</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">mutable struct iLQRSolverOptions{T} &lt;: TrajectoryOptimization.AbstractSolverOptions{T}</code></pre><p>Solver options for the iterative LQR (iLQR) solver.</p><ul><li><p><code>verbose</code></p><p>Print summary at each iteration. Default: false</p></li><li><p><code>live_plotting</code></p><p>Live plotting. Default: :off</p></li><li><p><code>cost_tolerance</code></p><p>dJ &lt; ϵ, cost convergence criteria for unconstrained solve or to enter outerloop for constrained solve. Default: 0.0001</p></li><li><p><code>gradient_type</code></p><p>gradient type: :todorov, :feedforward. Default: :todorov</p></li><li><p><code>gradient_norm_tolerance</code></p><p>gradient_norm &lt; ϵ, gradient norm convergence criteria. Default: 1.0e-5</p></li><li><p><code>iterations</code></p><p>iLQR iterations. Default: 300</p></li><li><p><code>dJ_counter_limit</code></p><p>restricts the total number of times a forward pass fails, resulting in regularization, before exiting. Default: 10</p></li><li><p><code>square_root</code></p><p>use square root method backward pass for numerical conditioning. Default: false</p></li><li><p><code>line_search_lower_bound</code></p><p>forward pass approximate line search lower bound, 0 &lt; line<em>search</em>lower<em>bound &lt; line</em>search<em>upper</em>bound. Default: 1.0e-8</p></li><li><p><code>line_search_upper_bound</code></p><p>forward pass approximate line search upper bound, 0 &lt; line<em>search</em>lower<em>bound &lt; line</em>search<em>upper</em>bound &lt; ∞. Default: 10.0</p></li><li><p><code>iterations_linesearch</code></p><p>maximum number of backtracking steps during forward pass line search. Default: 20</p></li><li><p><code>bp_reg_initial</code></p><p>initial regularization. Default: 0.0</p></li><li><p><code>bp_reg_increase_factor</code></p><p>regularization scaling factor. Default: 1.6</p></li><li><p><code>bp_reg_max</code></p><p>maximum regularization value. Default: 1.0e8</p></li><li><p><code>bp_reg_min</code></p><p>minimum regularization value. Default: 1.0e-8</p></li><li><p><code>bp_reg_type</code></p><p>type of regularization- control: () + ρI, state: (S + ρI); see Synthesis and Stabilization of Complex Behaviors through Online Trajectory Optimization. Default: :control</p></li><li><p><code>bp_reg_fp</code></p><p>additive regularization when forward pass reaches max iterations. Default: 10.0</p></li><li><p><code>bp_sqrt_inv_type</code></p><p>type of matrix inversion for bp sqrt step. Default: :pseudo</p></li><li><p><code>bp_reg_sqrt_initial</code></p><p>initial regularization for square root method. Default: 1.0e-6</p></li><li><p><code>bp_reg_sqrt_increase_factor</code></p><p>regularization scaling factor for square root method. Default: 10.0</p></li><li><p><code>max_cost_value</code></p><p>maximum cost value, if exceded solve will error. Default: 1.0e8</p></li><li><p><code>max_state_value</code></p><p>maximum state value, evaluated during rollout, if exceded solve will error. Default: 1.0e8</p></li><li><p><code>max_control_value</code></p><p>maximum control value, evaluated during rollout, if exceded solve will error. Default: 1.0e8</p></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0">source</a></section><h2><a class="nav-anchor" id="Augmented-Lagrangian-1" href="#Augmented-Lagrangian-1">Augmented Lagrangian</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrajectoryOptimization.AugmentedLagrangianSolver" href="#TrajectoryOptimization.AugmentedLagrangianSolver"><code>TrajectoryOptimization.AugmentedLagrangianSolver</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct AugmentedLagrangianSolver &lt;: TrajectoryOptimization.AbstractSolver{T}</code></pre><p>Augmented Lagrangian (AL) is a standard tool for constrained optimization. For a trajectory optimization problem of the form:</p><div>\[\begin{equation*}
\begin{aligned}
  \min_{x_{0:N},u_{0:N-1}} \quad &amp; \ell_f(x_N) + \sum_{k=0}^{N-1} \ell_k(x_k, u_k, dt) \\
  \textrm{s.t.}            \quad &amp; x_{k+1} = f(x_k, u_k), \\
                                 &amp; g_k(x_k,u_k) \leq 0, \\
                                 &amp; h_k(x_k,u_k) = 0.
\end{aligned}
\end{equation*}\]</div><p>AL methods form the following augmented Lagrangian function:</p><div>\[\begin{align*}
    \ell_f(x_N) + &amp;λ_N^T c_N(x_N) + c_N(x_N)^T I_{\mu_N} c_N(x_N) \\
           &amp; + \sum_{k=0}^{N-1} \ell_k(x_k,u_k,dt) + λ_k^T c_k(x_k,u_k) + c_k(x_k,u_k)^T I_{\mu_k} c_k(x_k,u_k)
\end{align*}\]</div><p>This function is then minimized with respect to the primal variables using any unconstrained minimization solver (e.g. iLQR).     After a local minima is found, the AL method updates the Lagrange multipliers λ and the penalty terms μ and repeats the unconstrained minimization.     AL methods have superlinear convergence as long as the penalty term μ is updated each iteration.</p></div></div><a class="source-link" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/2ea839be5a504992bf02865f34a4c376ca18e2a3/src/solvers/augmentedlagrangian.jl#L70-L96">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrajectoryOptimization.AugmentedLagrangianSolverOptions" href="#TrajectoryOptimization.AugmentedLagrangianSolverOptions"><code>TrajectoryOptimization.AugmentedLagrangianSolverOptions</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">mutable struct AugmentedLagrangianSolverOptions{T} &lt;: TrajectoryOptimization.AbstractSolverOptions{T}</code></pre><p>Solver options for the augmented Lagrangian solver.</p><ul><li><p><code>verbose</code></p><p>Print summary at each iteration. Default: false</p></li><li><p><code>opts_uncon</code></p><p>unconstrained solver options. Default: iLQRSolverOptions{T}()</p></li><li><p><code>cost_tolerance</code></p><p>dJ &lt; ϵ, cost convergence criteria for unconstrained solve or to enter outerloop for constrained solve. Default: 0.0001</p></li><li><p><code>cost_tolerance_intermediate</code></p><p>dJ &lt; ϵ_int, intermediate cost convergence criteria to enter outerloop of constrained solve. Default: 0.001</p></li><li><p><code>gradient_norm_tolerance</code></p><p>gradient_norm &lt; ϵ, gradient norm convergence criteria. Default: 1.0e-5</p></li><li><p><code>gradient_norm_tolerance_intermediate</code></p><p>gradient<em>norm</em>int &lt; ϵ, gradient norm intermediate convergence criteria. Default: 1.0e-5</p></li><li><p><code>constraint_tolerance</code></p><p>max(constraint) &lt; ϵ, constraint convergence criteria. Default: 0.001</p></li><li><p><code>constraint_tolerance_intermediate</code></p><p>max(constraint) &lt; ϵ_int, intermediate constraint convergence criteria. Default: 0.001</p></li><li><p><code>iterations</code></p><p>maximum outerloop updates. Default: 30</p></li><li><p><code>dual_min</code></p><p>minimum Lagrange multiplier. Default: -1.0e8</p></li><li><p><code>dual_max</code></p><p>maximum Lagrange multiplier. Default: 1.0e8</p></li><li><p><code>penalty_max</code></p><p>maximum penalty term. Default: 1.0e8</p></li><li><p><code>penalty_initial</code></p><p>initial penalty term. Default: 1.0</p></li><li><p><code>penalty_scaling</code></p><p>penalty update multiplier; penalty_scaling &gt; 0. Default: 10.0</p></li><li><p><code>penalty_scaling_no</code></p><p>penalty update multiplier when μ should not be update, typically 1.0 (or 1.0 + ϵ). Default: 1.0</p></li><li><p><code>constraint_decrease_ratio</code></p><p>ratio of current constraint to previous constraint violation; 0 &lt; constraint<em>decrease</em>ratio &lt; 1. Default: 0.25</p></li><li><p><code>outer_loop_update_type</code></p><p>type of outer loop update (default, feedback). Default: :default</p></li><li><p><code>active_constraint_tolerance</code></p><p>numerical tolerance for constraint violation. Default: 0.0</p></li><li><p><code>kickout_max_penalty</code></p><p>terminal solve when maximum penalty is reached. Default: false</p></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0">source</a></section><h2><a class="nav-anchor" id="ALTRO-1" href="#ALTRO-1">ALTRO</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrajectoryOptimization.ALTROSolver" href="#TrajectoryOptimization.ALTROSolver"><code>TrajectoryOptimization.ALTROSolver</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct ALTROSolver{T} &lt;: TrajectoryOptimization.AbstractSolver{T}</code></pre><p>Augmented Lagrangian Trajectory Optimizer (ALTRO) is a solver developed by the Robotic Exploration Lab at Stanford University.     The solver is special-cased to solve Markov Decision Processes by leveraging the internal problem structure.</p><p>ALTRO consists of two &quot;phases&quot;:</p><ol><li>AL-iLQR: iLQR is used with an Augmented Lagrangian framework to solve the problem quickly to rough constraint satisfaction</li><li>Projected Newton: A collocation-flavored active-set solver projects the solution from AL-iLQR onto the feasible subspace to achieve machine-precision constraint satisfaction.</li></ol></div></div><a class="source-link" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/2ea839be5a504992bf02865f34a4c376ca18e2a3/src/solvers/altro.jl#L68">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrajectoryOptimization.ALTROSolverOptions" href="#TrajectoryOptimization.ALTROSolverOptions"><code>TrajectoryOptimization.ALTROSolverOptions</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">mutable struct ALTROSolverOptions{T} &lt;: TrajectoryOptimization.AbstractSolverOptions{T}</code></pre><p>Solver options for the ALTRO solver.</p><ul><li><p><code>verbose</code></p><p>Default: false</p></li><li><p><code>opts_al</code></p><p>Augmented Lagrangian solver options. Default: AugmentedLagrangianSolverOptions{T}()</p></li><li><p><code>constraint_tolerance_infeasible</code></p><p>infeasible control constraint tolerance. Default: 1.0e-5</p></li><li><p><code>R_inf</code></p><p>regularization term for infeasible controls. Default: 1.0</p></li><li><p><code>dynamically_feasible_projection</code></p><p>project infeasible results to feasible space using TVLQR. Default: true</p></li><li><p><code>resolve_feasible_problem</code></p><p>resolve feasible problem after infeasible solve. Default: true</p></li><li><p><code>penalty_initial_infeasible</code></p><p>initial penalty term for infeasible controls. Default: 1.0</p></li><li><p><code>penalty_scaling_infeasible</code></p><p>penalty update rate for infeasible controls. Default: 10.0</p></li><li><p><code>R_minimum_time</code></p><p>regularization term for dt. Default: 1.0</p></li><li><p><code>dt_max</code></p><p>maximum allowable dt. Default: 1.0</p></li><li><p><code>dt_min</code></p><p>minimum allowable dt. Default: 0.001</p></li><li><p><code>penalty_initial_minimum_time_inequality</code></p><p>initial penalty term for minimum time bounds constraints. Default: 1.0</p></li><li><p><code>penalty_initial_minimum_time_equality</code></p><p>initial penalty term for minimum time equality constraints. Default: 1.0</p></li><li><p><code>penalty_scaling_minimum_time_inequality</code></p><p>penalty update rate for minimum time bounds constraints. Default: 1.0</p></li><li><p><code>penalty_scaling_minimum_time_equality</code></p><p>penalty update rate for minimum time equality constraints. Default: 1.0</p></li><li><p><code>projected_newton</code></p><p>finish with a projecte newton solve. Default: false</p></li><li><p><code>opts_pn</code></p><p>options for projected newton solver. Default: ProjectedNewtonSolverOptions{T}()</p></li><li><p><code>projected_newton_tolerance</code></p><p>constraint satisfaction tolerance that triggers the projected newton solver.     If set to a non-positive number it will kick out when the maximum penalty is reached. Default: 0.001</p></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0">source</a></section><h2><a class="nav-anchor" id="Direct-Collocation-(DIRCOL)-1" href="#Direct-Collocation-(DIRCOL)-1">Direct Collocation (DIRCOL)</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrajectoryOptimization.DIRCOLSolver" href="#TrajectoryOptimization.DIRCOLSolver"><code>TrajectoryOptimization.DIRCOLSolver</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct DIRCOLSolver{T, Q} &lt;: TrajectoryOptimization.DirectSolver{T}</code></pre><p>Direct Collocation Solver. Uses a commerical NLP solver to solve the Trajectory Optimization problem. Uses the MathOptInterface to interface with the NLP.</p></div></div><a class="source-link" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/2ea839be5a504992bf02865f34a4c376ca18e2a3/src/solvers/direct/direct_solvers.jl#L138">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrajectoryOptimization.DIRCOLSolverOptions" href="#TrajectoryOptimization.DIRCOLSolverOptions"><code>TrajectoryOptimization.DIRCOLSolverOptions</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">mutable struct DIRCOLSolverOptions{T} &lt;: TrajectoryOptimization.DirectSolverOptions{T}</code></pre><p>Solver options for the Direct Collocation solver. Most options are passed to the NLP through the <code>opts</code> dictionary</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0">source</a></section><h2><a class="nav-anchor" id="Projected-Newton-1" href="#Projected-Newton-1">Projected Newton</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrajectoryOptimization.ProjectedNewtonSolver" href="#TrajectoryOptimization.ProjectedNewtonSolver"><code>TrajectoryOptimization.ProjectedNewtonSolver</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct ProjectedNewtonSolver{T} &lt;: TrajectoryOptimization.DirectSolver{T}</code></pre><p>Projected Newton Solver Direct method developed by the REx Lab at Stanford University</p><p>Achieves machine-level constraint satisfaction by projecting onto the feasible subspace.     It can also take a full Newton step by solving the KKT system.</p><p>This solver is to be used exlusively for solutions that are close to the optimal solution.     It is intended to be used as a &quot;solution polishing&quot; method for augmented Lagrangian methods.</p></div></div><a class="source-link" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/2ea839be5a504992bf02865f34a4c376ca18e2a3/src/solvers/direct/direct_solvers.jl#L28">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrajectoryOptimization.ProjectedNewtonSolverOptions" href="#TrajectoryOptimization.ProjectedNewtonSolverOptions"><code>TrajectoryOptimization.ProjectedNewtonSolverOptions</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">mutable struct ProjectedNewtonSolverOptions{T} &lt;: TrajectoryOptimization.DirectSolverOptions{T}</code></pre><p>Solver options for the Projected Newton solver</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0">source</a></section><footer><hr/><a class="previous" href="../problem/"><span class="direction">Previous</span><span class="title">4. Setting up a Problem</span></a></footer></article></body></html>
