<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>4. Add Constraints · TrajectoryOptimization</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>TrajectoryOptimization</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">TrajectoryOptimization.jl</a></li><li><a class="toctext" href="../models/">1. Setting up a Dynamics Model</a></li><li><a class="toctext" href="../costfunctions/">2. Setting up a Cost Function</a></li><li class="current"><a class="toctext" href>4. Add Constraints</a><ul class="internal"><li class="toplevel"><a class="toctext" href="#Constraint-Type-1">Constraint Type</a></li><li><a class="toctext" href="#General-Constraints-1">General Constraints</a></li><li><a class="toctext" href="#Bound-Constraints-1">Bound Constraints</a></li><li class="toplevel"><a class="toctext" href="#Constraint-Sets-1">Constraint Sets</a></li><li class="toplevel"><a class="toctext" href="#Problem-Constraints-1">Problem Constraints</a></li></ul></li><li><a class="toctext" href="../problem/">Setting up a Problem</a></li><li><a class="toctext" href="../solvers/">Solvers</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>4. Add Constraints</a></li></ul><a class="edit-page" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/master/docs/src/constraints.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>4. Add Constraints</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id=".-Add-Constraints-1" href="#.-Add-Constraints-1">4. Add Constraints</a></h1><ul><li><a href="#.-Add-Constraints-1">4. Add Constraints</a></li><li><a href="#Constraint-Type-1">Constraint Type</a></li><ul><li><a href="#General-Constraints-1">General Constraints</a></li><li><a href="#Bound-Constraints-1">Bound Constraints</a></li></ul><li><a href="#Constraint-Sets-1">Constraint Sets</a></li><li><a href="#Problem-Constraints-1">Problem Constraints</a></li></ul><h1><a class="nav-anchor" id="Constraint-Type-1" href="#Constraint-Type-1">Constraint Type</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrajectoryOptimization.Constraint" href="#TrajectoryOptimization.Constraint"><code>TrajectoryOptimization.Constraint</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct Constraint{S} &lt;: TrajectoryOptimization.AbstractConstraint{S}</code></pre><p>General nonlinear constraint</p></div></div><a class="source-link" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/4e143c5967ddabc0c294e257e35d8655ce24cc3d/src/constraints.jl#L43">source</a></section><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>ConstraintType</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>Equality</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>Inequality</code>. Check Documenter&#39;s build log for details.</p></div></div><p>All constraint types inherit from <code>AbstractConstraint</code> and are parameterized by <a href="@ref">ConstraintType</a>, which specifies the type of constraint, <code>Inequality</code> or <code>Equality</code>. This allows the software to easily dispatch over the type of constraint. Each constraint type represents a vector-valued constraint. The intention is that each constraint type represent one line in constraints of problem definition (where they may be vector or scalar-valued). Each constraint has the following interface:</p><p><code>evaluate!(v, con, x, u)</code>: Stage constraint <code>evaluate!(v, con, x)</code>: Terminal constraint <code>jacobian!(V, con, x, u)</code>: Jacobian wrt states and controls at a stage time step <code>jacobian!(V, con, x)</code>: Jacobian wrt terminal state at terminal time step <code>is_terminal(con)</code>: Boolean true if the constraint is defined at the terminal time step <code>is_stage(con)</code>: Boolean true if the constraint is defined at the stage time steps <code>length(con)</code>: Number of constraints (length of the output vector)</p><p>There are currently two types of constraints implemented</p><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>Constraint</code>. Check Documenter&#39;s build log for details.</p></div></div><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrajectoryOptimization.BoundConstraint" href="#TrajectoryOptimization.BoundConstraint"><code>TrajectoryOptimization.BoundConstraint</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Linear bound constraint on states and controls</p></div></div><a class="source-link" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/4e143c5967ddabc0c294e257e35d8655ce24cc3d/src/constraints.jl#L109">source</a></section><h2><a class="nav-anchor" id="General-Constraints-1" href="#General-Constraints-1">General Constraints</a></h2><h3><a class="nav-anchor" id="Fields-1" href="#Fields-1">Fields</a></h3><p>Each <code>Constraint</code> contains the following fields:</p><ul><li><code>c</code>: the in-place constraint function. Methods dispatch over constraint functions of the form <code>c(v,x,u)</code> and <code>c(v,x)</code>.</li><li><code>∇c</code>: the in-place constraint jacobian function defined as <code>∇c(Z,x,u)</code> where <code>Z</code> is the p × (n+m) concatenated Jacobian. <code>p</code>: number of elements in the constraint vector</li><li><code>label</code>: a Symbol for identifying the constraint</li><li><code>type</code>: a Symbol identifying where the constraint applies. One of <code>[:stage, :terminal, :all]</code></li></ul><h3><a class="nav-anchor" id="Basic-Constructor-1" href="#Basic-Constructor-1">Basic Constructor</a></h3><p>Let&#39;s say we have a problem with 3 states and 2 controls, the following constraints <span>$x_1^2 + x_2^2 - 1 \leq 0$</span>, <span>$x_2 + u_1  = 0$</span>, and <span>$x_3 + u_2 = 0$</span>. These two constraints could be created as follows:</p><pre><code class="language-julia"># Problem size
n,m = 3,2

# Inequality Constraint
c(v,x,u) = v[1] = x[1]^2 + x[2]^2 - 1
p1 = 1
con = Constraint{Inequality}(c, n, m, p1, :mycon1)

# Equality Constraint
c_eq(v,x,u) = v[1:2] = x[2:3] + u
p2 = 2
con_eq = Constraint{Equality}(c_eq, n, m, p2, :mycon2)</code></pre><h3><a class="nav-anchor" id="Analytical-Jacobians-1" href="#Analytical-Jacobians-1">Analytical Jacobians</a></h3><p>Previously, we let the constructor build the Jacobians using ForwardDiff. We can alternatively specify them explicitly:</p><pre><code class="language-julia"># Jacobian for inequality constraint
∇c(V,x,u) = begin V[1,1] = 2x[1]; V[1,2] = 2x[2]; end
con = Constraint{Inequality}(c, ∇c, n, m, p1, :mycon1)

# Jacobian for equality constraint
∇c_eq(V,x,u) = begin V[1,2] = 1; V[1,4] = 1;
                     V[2,3] = 1; V[2,5] = 1; end
con_eq = Constraint{Equality}(c_eq, ∇c_eq, n, m, p2, :mycon2)</code></pre><h3><a class="nav-anchor" id="Terminal-Constraints-1" href="#Terminal-Constraints-1">Terminal Constraints</a></h3><p>We can also build a terminal constraint that only depends on the terminal state, <span>$x_N$</span>. Let&#39;s say we have a terminal constraint <span>$x_1 + x_2 + x_3 = 1$</span>. We can create it using similar constructors:</p><pre><code class="language-julia"># Build terminal constraint
c_term(v,x) = sum(x) - 1
p_term = 1
con_term = Constraint{Equality}(c_term, n, p_term, :con_term)

# We can also optionally give it an analytical Jacobian
∇c_term(V,x) = ones(1,n)
con_term = Constraint{Equality}(c_term, ∇c_term, n, p_term, :con_term)</code></pre><h3><a class="nav-anchor" id="Both-Stage-and-Terminal-Constraints-1" href="#Both-Stage-and-Terminal-Constraints-1">Both Stage and Terminal Constraints</a></h3><p>Every constraint can be applied to both stage and terminal time steps. The constructor automatically determines which is applied based on the methods defined for the provided function. You can check this by inspecting the <code>type</code> field, which will be one of <code>[:stage, :terminal, :all]</code>.</p><p>Notice our first constraint is only dependent on the state. If we want to enforce it at the terminal time step we can simply use multiple dispatch:</p><pre><code class="language-julia">con.label == :stage  # true
c(v,x) = v[1] = x[1]^2 + x[2]^2 - 1
con = Constraint{Inequality}(c, n, m, p1, :mycon1)
con.label == :all  # true</code></pre><p>The type can easily be checked with the <code>is_terminal</code> and <code>is_stage</code> commands.</p><h3><a class="nav-anchor" id="Constructors-1" href="#Constructors-1">Constructors</a></h3><p>In summary, here are the constructors:</p><pre><code class="language-none">Constraint{S}(c::Function, ∇c::Function, n::Int, m::Int, p::Int, label::Symbol) where S&lt;:ConstraintType
Constraint{S}(c::Function, n::Int, m::Int, p::Int, label::Symbol) where S&lt;:ConstraintType
Constraint{S}(c::Function, ∇c::Function, n::Int, p::Int, label::Symbol) where S&lt;:ConstraintType
Constraint{S}(c::Function, n::Int, p::Int, label::Symbol) where S&lt;:ConstraintType</code></pre><h3><a class="nav-anchor" id="Methods-1" href="#Methods-1">Methods</a></h3><p>Given that constraints can apply at any time step, we assume that there is the same number of constraints for both stage and terminal time steps. The <code>length</code> method can also accept either <code>:stage</code> or <code>:terminal</code> as a second argument to specify which length you want (since one may be zero). e.g.</p><pre><code class="language-julia">length(con, :stage) == length(con, :terminal)  == 1  # true
length(con_eq, :stage) == 2     # true
length(con_eq, :terminal) == 0  # true</code></pre><h3><a class="nav-anchor" id="Special-Constraints-1" href="#Special-Constraints-1">Special Constraints</a></h3><p>A few constructors for common constraints have been provided:</p><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>goal_constraint</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>planar_obstacle_constraint</code>. Check Documenter&#39;s build log for details.</p></div></div><h2><a class="nav-anchor" id="Bound-Constraints-1" href="#Bound-Constraints-1">Bound Constraints</a></h2><p>Bound constraints define simple bounds on the states and controls, allowing the solver to efficiently dispatch on methods to handle these simple constraints (especially when using direct methods). The constructor is very simple</p><pre><code class="language-julia">BoundConstraint(n, m; x_min, x_max, u_min, x_max)</code></pre><p>The bounds can be given by vectors of the appropriate length, using ±Inf for unbounded values, or a scalar can be passed in when all the states have the same bound. If left blank, the value is assumed to be unbounded.</p><p>Working from the previous examples, let&#39;s say we have <span>$-1 \geq x_1 \leq 1, x_3 \leq 10, -15 \geq u \leq 12$</span>:</p><pre><code class="language-julia"># Create a bound constraint
bnd = BoundConstraint(n, m, x_min=[-1,-Inf,-Inf], x_max=[1,Inf,10],
                            u_min=-15, u_max=12)</code></pre><p>Note that bound constraints are automatically valid at both stage and terminal time steps, i.e. <code>evaluate!(v, bnd, x, u)</code> and <code>evaluate!(v, bnd, x)</code> are both defined.</p><h1><a class="nav-anchor" id="Constraint-Sets-1" href="#Constraint-Sets-1">Constraint Sets</a></h1><p>A <code>ConstraintSet</code> is simply a vector of constraints, and represents a set of constraints at a particular time step. There are some convenient methods for creating and working with constraint sets.</p><p>Let&#39;s say we combine the previous constraints into a single constraint set. We can do this easily using the <code>+</code> method:</p><pre><code class="language-julia"># Create a constraint set for stage time steps
constraints = con + con_eq + bnd

# Create a constraint set for terminal constraints
constraints_term = con + con_term + bnd</code></pre><p>There are several functions provided to work with <code>ConstraintSets</code></p><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>Base.pop!(C::ConstraintSet, label::Symbol)</code>. Check Documenter&#39;s build log for details.</p></div></div><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrajectoryOptimization.evaluate!-Tuple{PartedArray{T,1,P,P1} where P1 where P where T,Array{#s67,1} where #s67&lt;:TrajectoryOptimization.GeneralConstraint,Any,Any}" href="#TrajectoryOptimization.evaluate!-Tuple{PartedArray{T,1,P,P1} where P1 where P where T,Array{#s67,1} where #s67&lt;:TrajectoryOptimization.GeneralConstraint,Any,Any}"><code>TrajectoryOptimization.evaluate!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">evaluate!(c, C, x, u)
</code></pre><p>Evaluate the constraint function for all the constraint functions in a set</p></div></div><a class="source-link" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/4e143c5967ddabc0c294e257e35d8655ce24cc3d/src/constraints.jl#L369">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrajectoryOptimization.evaluate!-Tuple{PartedArray{T,1,P,P1} where P1 where P where T,Array{#s67,1} where #s67&lt;:TrajectoryOptimization.GeneralConstraint,Any}" href="#TrajectoryOptimization.evaluate!-Tuple{PartedArray{T,1,P,P1} where P1 where P where T,Array{#s67,1} where #s67&lt;:TrajectoryOptimization.GeneralConstraint,Any}"><code>TrajectoryOptimization.evaluate!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">evaluate!(c, C, x)
</code></pre><p>Evaluate the constraint function for all the terminal constraint functions in a set</p></div></div><a class="source-link" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/4e143c5967ddabc0c294e257e35d8655ce24cc3d/src/constraints.jl#L376">source</a></section><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>jacobian!(c::PartedMatrix, C::ConstraintSet, x, u)</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>jacobian!(c::PartedMatrix, C::ConstraintSet, x)</code>. Check Documenter&#39;s build log for details.</p></div></div><p>The <code>PartedVector</code> and <code>PartedMatrix</code> needed for the <code>evaluate!</code> and <code>jacobian!</code> methods can be generated using</p><pre><code class="language-julia">PartedVector(C::ConstraintSet, type=:stage)
PartedMatrix(C::ConstraintSet, type=:stage)</code></pre><h1><a class="nav-anchor" id="Problem-Constraints-1" href="#Problem-Constraints-1">Problem Constraints</a></h1><p>A <code>Problem</code> is made up of individual <code>ConstraintSet</code>s at each of the <code>N</code> time steps, allowing for different constraints along the trajectory. The collection of <code>ConstraintSet</code>s is captured in the <code>ProblemConstraints</code> type. There are several methods for constructing <code>ProblemConstraints</code>:</p><pre><code class="language-julia"># Create an empty set
ProblemConstraints(N)

# Copy a single ConstraintSet over every time step
ProblemConstraints(constraints, N)

# Use a different set at the terminal time step
ProblemConstraints(constraints, constraints_term, N)

# Create from a Vector of Constraint Sets
ProblemConstraints([constraints, constraints, constraints, constraints_term])</code></pre><p>You can easily add or remove constraints from time steps using <code>+</code> and <code>pop!</code> on the appropriate time step:</p><pre><code class="language-julia">pcon = ProblemConstraints(N)
pcon[1] += con
pcon[2] += con + con_eq
pop!(pcon[2], :mycon2)
pcon[N] += con_term</code></pre><footer><hr/><a class="previous" href="../costfunctions/"><span class="direction">Previous</span><span class="title">2. Setting up a Cost Function</span></a><a class="next" href="../problem/"><span class="direction">Next</span><span class="title">Setting up a Problem</span></a></footer></article></body></html>
