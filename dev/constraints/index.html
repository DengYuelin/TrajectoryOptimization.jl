<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>4. Add Constraints · TrajectoryOptimization</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>TrajectoryOptimization</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">TrajectoryOptimization.jl</a></li><li><a class="toctext" href="../models/">1. Setting up a Dynamics Model</a></li><li><a class="toctext" href="../costfunctions/">2. Setting up a Cost Function</a></li><li class="current"><a class="toctext" href>4. Add Constraints</a><ul class="internal"><li class="toplevel"><a class="toctext" href="#Constraint-Type-1">Constraint Type</a></li><li><a class="toctext" href="#General-Constraints-1">General Constraints</a></li><li><a class="toctext" href="#Bound-Constraints-1">Bound Constraints</a></li><li class="toplevel"><a class="toctext" href="#Constraint-Sets-1">Constraint Sets</a></li><li class="toplevel"><a class="toctext" href="#Problem-Constraints-1">Problem Constraints</a></li></ul></li><li><a class="toctext" href="../problem/">Setting up a Problem</a></li><li><a class="toctext" href="../solvers/">Solvers</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>4. Add Constraints</a></li></ul><a class="edit-page" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/master/docs/src/constraints.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>4. Add Constraints</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id=".-Add-Constraints-1" href="#.-Add-Constraints-1">4. Add Constraints</a></h1><ul><li><a href="#.-Add-Constraints-1">4. Add Constraints</a></li><li><a href="#Constraint-Type-1">Constraint Type</a></li><ul><li><a href="#General-Constraints-1">General Constraints</a></li><li><a href="#Bound-Constraints-1">Bound Constraints</a></li></ul><li><a href="#Constraint-Sets-1">Constraint Sets</a></li><li><a href="#Problem-Constraints-1">Problem Constraints</a></li></ul><h1><a class="nav-anchor" id="Constraint-Type-1" href="#Constraint-Type-1">Constraint Type</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrajectoryOptimization.Constraint" href="#TrajectoryOptimization.Constraint"><code>TrajectoryOptimization.Constraint</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct Constraint{S} &lt;: TrajectoryOptimization.AbstractConstraint{S}</code></pre><p>General nonlinear constraint</p></div></div><a class="source-link" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/7649515f052b93c37944ede4c9dbb09f7da504fa/src/constraints.jl#L47">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrajectoryOptimization.ConstraintType" href="#TrajectoryOptimization.ConstraintType"><code>TrajectoryOptimization.ConstraintType</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Sense of a constraint (inequality / equality / null)</p></div></div><a class="source-link" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/7649515f052b93c37944ede4c9dbb09f7da504fa/src/constraints.jl#L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrajectoryOptimization.Equality" href="#TrajectoryOptimization.Equality"><code>TrajectoryOptimization.Equality</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Inequality constraints</p></div></div><a class="source-link" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/7649515f052b93c37944ede4c9dbb09f7da504fa/src/constraints.jl#L7">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrajectoryOptimization.Inequality" href="#TrajectoryOptimization.Inequality"><code>TrajectoryOptimization.Inequality</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Equality constraints</p></div></div><a class="source-link" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/7649515f052b93c37944ede4c9dbb09f7da504fa/src/constraints.jl#L9">source</a></section><p>All constraint types inherit from <code>AbstractConstraint</code> and are parameterized by <a href="@ref">ConstraintType</a>, which specifies the type of constraint, <code>Inequality</code> or <code>Equality</code>. This allows the software to easily dispatch over the type of constraint. Each constraint type represents a vector-valued constraint. The intention is that each constraint type represent one line in constraints of problem definition (where they may be vector or scalar-valued). Each constraint has the following interface:</p><p><code>evaluate!(v, con, x, u)</code>: Stage constraint <code>evaluate!(v, con, x)</code>: Terminal constraint <code>jacobian!(V, con, x, u)</code>: Jacobian wrt states and controls at a stage time step <code>jacobian!(V, con, x)</code>: Jacobian wrt terminal state at terminal time step <code>is_terminal(con)</code>: Boolean true if the constraint is defined at the terminal time step <code>is_stage(con)</code>: Boolean true if the constraint is defined at the stage time steps <code>length(con)</code>: Number of constraints (length of the output vector)</p><p>There are currently two types of constraints implemented</p><pre><code class="language-none">Constraint
BoundConstraint</code></pre><h2><a class="nav-anchor" id="General-Constraints-1" href="#General-Constraints-1">General Constraints</a></h2><p>Each <code>Constraint</code> contains the following fields:</p><ul><li><code>c</code>: the in-place constraint function. Methods dispatch over constraint functions of the form <code>c(v,x,u)</code> and <code>c(v,x)</code>.</li><li><code>∇c</code>: the in-place constraint jacobian function defined as <code>∇c(Z,x,u)</code> where <code>Z</code> is the p × (n+m) concatenated Jacobian. Methods also dispatch over constraint jacobians of the form <code>∇c(Z,x)</code> where <code>Z</code> is p x n.</li><li><code>p</code>: number of elements in the constraint vector</li><li><code>label</code>: a Symbol for identifying the constraint</li></ul><p>Let&#39;s say we have a problem with 3 states and 2 controls, the following constraints <span>$x_1^2 + x_2^2 - 1 \leq 0$</span>, <span>$x_2 + u_1  = 0$</span>, and <span>$x_3 + u_2 = 0$</span>. These two constraints could be created as follows:</p><pre><code class="language-julia">n,m = 3,2

# Inequality Constraint
c(v,x,u) = v[1] = x[1]^2 + x[2]^2 - 1
p1 = 1
con = Constraint{Inequality}(c, n, m, p1, :mycon1)

# Equality Constraint
c_eq(v,x,u) = v[1:2] = x[2:3] + u
p2 = 2
con_eq = Constraint{Equality}(c_eq, n, m, p2, :mycon2)</code></pre><p>Here we let the constructor build the Jacobians using ForwardDiff. We can alternatively specify them explicitly:</p><pre><code class="language-julia">∇c(V,x,u) = begin V[1,1] = 2x[1]; V[1,2] = 2x[2]; end
con = Constraint{Inequality}(c, ∇c, n, m, p1, :mycon1)

∇c_eq(V,x,u) = begin V[1,2] = 1; V[1,4] = 1;
                     V[2,3] = 1; V[2,5] = 1; end
con_eq = Constraint{Equality}(c_eq, ∇c_eq, n, m, p2, :mycon2)</code></pre><p>We can also build a terminal constraint that only depends on the terminal state, <span>$x_N$</span>. Let&#39;s say we have a terminal constraint <span>$x_1 + x_2 + x_3 = 1$</span>. We can create it using similar constructors:</p><pre><code class="language-julia">c_term(v,x) = sum(x) - 1
p_term = 1
con_term = Constraint{Equality}(c_term, n, p_term, :con_term)

# We can also optionally give it an analytical Jacobian
∇c_term(V,x) = ones(1,n)
con_term = Constraint{Equality}(c_term, ∇c_term, n, p_term, :con_term)</code></pre><p>Every constraint can be applied to both stage and terminal time steps. The constructor automatically determines which is applied based on the methods defined for the provided function. You can check this by inspecting the <code>type</code> field, which will be one of <code>[:stage, :terminal, :all]</code>.</p><p>Notice our first constraint is only dependent on the state. If we want to enforce it at the terminal time step we can simply use multiple dispatch:</p><pre><code class="language-julia">con.label == :stage  # true
c(v,x) = v[1] = x[1]^2 + x[2]^2 - 1
con = Constraint{Inequality}(c, n, m, p1, :mycon1)
con.label == :all  # true</code></pre><p>The type can easily be checked with the <code>is_terminal</code> and <code>is_stage</code> commands.</p><p>In summary, here are the constructors:</p><pre><code class="language-none">Constraint{S}(c::Function, ∇c::Function, n::Int, m::Int, p::Int, label::Symbol) where S&lt;:ConstraintType
Constraint{S}(c::Function, n::Int, m::Int, p::Int, label::Symbol) where S&lt;:ConstraintType
Constraint{S}(c::Function, ∇c::Function, n::Int, p::Int, label::Symbol) where S&lt;:ConstraintType
Constraint{S}(c::Function, n::Int, p::Int, label::Symbol) where S&lt;:ConstraintType</code></pre><p>Given that constraints can apply at any time step, we assume that there is the same number of constraints for both stage and terminal time steps. The <code>length</code> method can also accept either <code>:stage</code> or <code>:terminal</code> as a second argument to specify which length you want (since one may be zero). e.g.</p><pre><code class="language-julia">length(con, :stage) == length(con, :terminal)  == 1  # true
length(con_eq, :stage) == 2     # true
length(con_eq, :terminal) == 0  # true</code></pre><h3><a class="nav-anchor" id="Special-Constraints-1" href="#Special-Constraints-1">Special Constraints</a></h3><p>A few constructors for common constraints have been provided:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrajectoryOptimization.goal_constraint" href="#TrajectoryOptimization.goal_constraint"><code>TrajectoryOptimization.goal_constraint</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Creates a terminal equality constraint specifying the goal. All states must be specified.</p></div></div><a class="source-link" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/7649515f052b93c37944ede4c9dbb09f7da504fa/src/constraints.jl#L258">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrajectoryOptimization.planar_obstacle_constraint" href="#TrajectoryOptimization.planar_obstacle_constraint"><code>TrajectoryOptimization.planar_obstacle_constraint</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">planar_obstacle_constraint(n, m, x_obs, r_obs)
planar_obstacle_constraint(n, m, x_obs, r_obs, label)
</code></pre><p>A constraint where x,y positions of the state must remain a distance r from a circle centered at x_obs Assumes x,y are the first two dimensions of the state vector</p></div></div><a class="source-link" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/7649515f052b93c37944ede4c9dbb09f7da504fa/src/constraints.jl#L248">source</a></section><h2><a class="nav-anchor" id="Bound-Constraints-1" href="#Bound-Constraints-1">Bound Constraints</a></h2><p>Bound constraints define simple bounds on the states and controls, allowing the solver to efficiently dispatch on methods to handle these simple constraints (especially when using direct methods). The constructor is very simple</p><pre><code class="language-julia">BoundConstraint(n, m; x_min, x_max, u_min, x_max)</code></pre><p>The bounds can be given by vectors of the appropriate length, using ±Inf for unbounded values, or a scalar can be passed in when all the states have the same bound. If left blank, the value is assumed to be unbounded.</p><p>Working from the previous examples, let&#39;s say we have <code>-1 \geq x_1 \leq 1, x_3 \leq 10, -15 \geq u \leq 12</code>:</p><pre><code class="language-julia">bnd = BoundConstraint(n, m, x_min=[-1,-Inf,-Inf], x_max=[1,Inf,10], u_min=-15, u_max=12)</code></pre><p>Note that bound constraints are automatically valid at both stage and terminal time steps, i.e. <code>evaluate!(v, bnd, x, u)</code> and <code>evaluate!(v, bnd, x)</code> are both defined.</p><h1><a class="nav-anchor" id="Constraint-Sets-1" href="#Constraint-Sets-1">Constraint Sets</a></h1><p>A <code>ConstraintSet</code> is simply a vector of constraints, and represents a set of constraints at a particular time step. There are some convenient methods for creating and working with constraint sets.</p><p>Let&#39;s say we combine the previous constraints into a single constraint set. We can do this easily using the <code>+</code> method:</p><pre><code class="language-julia">constraints = con + con_eq + bnd
constraints_term = con + con_term + bnd</code></pre><p>There are several functions provided to work with <code>ConstraintSets</code></p><pre><code class="language-none">Base.pop!(C::ConstraintSet, label::Symbol)
evaluate!(c::PartedVector, C::ConstraintSet, x, u)
evaluate!(c::PartedVector, C::ConstraintSet, x)
jacobian!(c::PartedMatrix, C::ConstraintSet, x, u)
jacobian!(c::PartedMatrix, C::ConstraintSet, x)</code></pre><p>The <code>PartedVector</code> and <code>PartedMatrix</code> needed for the <code>evaluate!</code> and <code>jacobian!</code> methods can be generated using</p><pre><code class="language-julia">PartedVector(C::ConstraintSet, type=:stage)
PartedMatrix(C::ConstraintSet, type=:stage)</code></pre><h1><a class="nav-anchor" id="Problem-Constraints-1" href="#Problem-Constraints-1">Problem Constraints</a></h1><footer><hr/><a class="previous" href="../costfunctions/"><span class="direction">Previous</span><span class="title">2. Setting up a Cost Function</span></a><a class="next" href="../problem/"><span class="direction">Next</span><span class="title">Setting up a Problem</span></a></footer></article></body></html>
