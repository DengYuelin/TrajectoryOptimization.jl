<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>1. Setting up a Dynamics Model · TrajectoryOptimization</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">TrajectoryOptimization</span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Introduction</a></li><li class="is-active"><a class="tocitem" href="models.html">1. Setting up a Dynamics Model</a><ul class="internal"><li><a class="tocitem" href="#Overview-1"><span>Overview</span></a></li><li><a class="tocitem" href="#Creating-a-New-Model-1"><span>Creating a New Model</span></a></li><li><a class="tocitem" href="#Model-Discretization-1"><span>Model Discretization</span></a></li><li><a class="tocitem" href="#Integration-Schemes-1"><span>Integration Schemes</span></a></li></ul></li><li><a class="tocitem" href="costfunctions.html">2. Setting up an Objective</a></li><li><a class="tocitem" href="constraints.html">3. Creating Constraints</a></li><li><a class="tocitem" href="problem.html">4. Setting up a Problem</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="models.html">1. Setting up a Dynamics Model</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="models.html">1. Setting up a Dynamics Model</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/master/docs/src/models.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="model_section-1"><a class="docs-heading-anchor" href="#model_section-1">1. Setting up a Dynamics Model</a><a class="docs-heading-anchor-permalink" href="#model_section-1" title="Permalink"></a></h1><ul><li><a href="models.html#model_section-1">1. Setting up a Dynamics Model</a></li><ul><li><a href="models.html#Overview-1">Overview</a></li><li><a href="models.html#Creating-a-New-Model-1">Creating a New Model</a></li><li><a href="models.html#Model-Discretization-1">Model Discretization</a></li><li><a href="models.html#Integration-Schemes-1">Integration Schemes</a></li></ul></ul><h2 id="Overview-1"><a class="docs-heading-anchor" href="#Overview-1">Overview</a><a class="docs-heading-anchor-permalink" href="#Overview-1" title="Permalink"></a></h2><p>The Model type holds information about the dynamics of the system. All dynamics are assumed to be state-space models of the system of the form ẋ = f(x,u) where ẋ is the state derivative, x an n-dimensional state vector, and u in an m-dimensional control input vector. The function f can be any nonlinear function.</p><p>TrajectoryOptimization.jl solves the trajectory optimization problem by discretizing the state and control trajectories, which requires discretizing the dynamics, i.e., turning the continuous time differential equation into a discrete time difference equation of the form x[k+1] = f(x[k],u[k]), where k is the time step. There many methods of performing this discretization, and TrajectoryOptimization.jl offers several of the most common methods.</p><h2 id="Creating-a-New-Model-1"><a class="docs-heading-anchor" href="#Creating-a-New-Model-1">Creating a New Model</a><a class="docs-heading-anchor-permalink" href="#Creating-a-New-Model-1" title="Permalink"></a></h2><p>To create a new model of a dynamical system, you need to define a new type that inherits from <code>AbstractModel</code>. You will need to then define only a few methods on your type. Let&#39;s say we want to create a model of the canonical cartpole. We start by defining our type:</p><pre><code class="language-julia">struct Cartpole{T} &lt;: AbstractModel
    mc::T  # mass of the cart
    mp::T  # mass of the pole
    l::T   # length of the pole
    g::T   # gravity
end</code></pre><p>It&#39;s often convenient to store any model parameters inside the new type (make sure they&#39;re concrete types!). If you need to store vectors or matrices, we highly recommend using StaticArrays, which are extremely fast and avoid memory allocations. For models with lots of parameters, we recommend <a href="https://github.com/mauro3/Parameters.jl">Parameters.jl</a> that makes it easy to specify default parameters.</p><p>We now just need to define two functions to complete the interface</p><pre><code class="language-julia">function dynamics(model::Cartpole, x, u)
    mc = model.mc  # mass of the cart in kg (10)
    mp = model.mp   # mass of the pole (point mass at the end) in kg
    l = model.l   # length of the pole in m
    g = model.g  # gravity m/s^2

    q = x[ @SVector [1,2] ]
    qd = x[ @SVector [3,4] ]

    s = sin(q[2])
    c = cos(q[2])

    H = @SMatrix [mc+mp mp*l*c; mp*l*c mp*l^2]
    C = @SMatrix [0 -mp*qd[2]*l*s; 0 0]
    G = @SVector [0, mp*g*l*s]
    B = @SVector [1, 0]

    qdd = -H\(C*qd + G - B*u[1])
    return [qd; qdd]
end

size(::Cartpole) = 4,1</code></pre><p>And voila! we have a new model.</p><p>We now have a few methods automatically available to us:</p><article class="docstring"><header><a class="docstring-binding" id="TrajectoryOptimization.dynamics" href="#TrajectoryOptimization.dynamics"><code>TrajectoryOptimization.dynamics</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ẋ = dynamics(model, z::KnotPoint)</code></pre><p>Compute the continuous dynamics of a dynamical system given a KnotPoint</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/466b23960c72df7d9857d0b47c2640f5da57550e/src/static_model.jl#L76-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TrajectoryOptimization.jacobian" href="#TrajectoryOptimization.jacobian"><code>TrajectoryOptimization.jacobian</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">∇f = jacobian(model, z::KnotPoint)
∇f = jacobian(model, z::SVector)</code></pre><p>Compute the Jacobian of the continuous-time dynamics using ForwardDiff. The input can be either a static vector of the concatenated state and control, or a KnotPoint. They must be concatenated to avoid unnecessary memory allocations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/466b23960c72df7d9857d0b47c2640f5da57550e/src/static_model.jl#L85-L93">source</a></section></article><p>The next section outlines how our continuous time model is discretized</p><h2 id="Model-Discretization-1"><a class="docs-heading-anchor" href="#Model-Discretization-1">Model Discretization</a><a class="docs-heading-anchor-permalink" href="#Model-Discretization-1" title="Permalink"></a></h2><p>With a model defined, we can compute the discrete dynamics and discrete dynamics Jacobians for an Implicit integration rule with the following methods</p><article class="docstring"><header><a class="docstring-binding" id="TrajectoryOptimization.discrete_dynamics" href="#TrajectoryOptimization.discrete_dynamics"><code>TrajectoryOptimization.discrete_dynamics</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Compute the discretized dynamics of <code>model</code> using implicit integration scheme <code>Q&lt;:QuadratureRule</code>.</p><p>Methods:</p><pre><code class="language-none">x′ = discrete_dynamics(Q, model, x, u, dt)
x′ = discrete_dynamics(Q, model, z::KnotPoint)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/466b23960c72df7d9857d0b47c2640f5da57550e/src/static_model.jl#L115-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TrajectoryOptimization.discrete_jacobian" href="#TrajectoryOptimization.discrete_jacobian"><code>TrajectoryOptimization.discrete_jacobian</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Compute the discrete dynamics Jacobian of <code>model</code> using implicit integration scheme <code>Q&lt;:QuadratureRule</code></p><p>Methods:</p><pre><code class="language-none">∇f = discrete_jacobian(model, z::KnotPoint)
∇f = discrete_jacobian(model, s::SVector{NM1}, ix::SVector{N}, iu::SVector{M})</code></pre><p>where <code>s = [x; u; dt]</code> and <code>ix</code> and <code>iu</code> are the indices to extract the state and controls.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/466b23960c72df7d9857d0b47c2640f5da57550e/src/static_model.jl#L126-L135">source</a></section></article><h2 id="Integration-Schemes-1"><a class="docs-heading-anchor" href="#Integration-Schemes-1">Integration Schemes</a><a class="docs-heading-anchor-permalink" href="#Integration-Schemes-1" title="Permalink"></a></h2><p>TrajectoryOptimization.jl has already defined a handful of integration schemes for computing discrete dynamics. The integration schemes are specified as abstract types, so that methods can efficiently dispatch based on the integration scheme selected. Here is the current set of implemented types:</p><ul><li><a href="models.html#TrajectoryOptimization.QuadratureRule"><code>QuadratureRule</code></a><ul><li><a href="models.html#TrajectoryOptimization.Implicit"><code>Implicit</code></a><ul><li><a href="models.html#TrajectoryOptimization.RK3"><code>RK3</code></a></li></ul></li><li><a href="models.html#TrajectoryOptimization.Explicit"><code>Explicit</code></a><ul><li><a href="models.html#TrajectoryOptimization.HermiteSimpson"><code>HermiteSimpson</code></a></li></ul></li></ul></li></ul><article class="docstring"><header><a class="docstring-binding" id="TrajectoryOptimization.QuadratureRule" href="#TrajectoryOptimization.QuadratureRule"><code>TrajectoryOptimization.QuadratureRule</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Integration rule for approximating the continuous integrals for the equations of motion</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/466b23960c72df7d9857d0b47c2640f5da57550e/src/static_model.jl#L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TrajectoryOptimization.Implicit" href="#TrajectoryOptimization.Implicit"><code>TrajectoryOptimization.Implicit</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Integration rules of the form x′ = f(x,u), where x′ is the next state</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/466b23960c72df7d9857d0b47c2640f5da57550e/src/static_model.jl#L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TrajectoryOptimization.RK3" href="#TrajectoryOptimization.RK3"><code>TrajectoryOptimization.RK3</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Third-order Runge-Kutta method with zero-order-old on the controls</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/466b23960c72df7d9857d0b47c2640f5da57550e/src/static_model.jl#L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TrajectoryOptimization.Explicit" href="#TrajectoryOptimization.Explicit"><code>TrajectoryOptimization.Explicit</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Integration rules of the form x′ = f(x,u,x′,u′), where x′,u′ are the states and controls at the next time step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/466b23960c72df7d9857d0b47c2640f5da57550e/src/static_model.jl#L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TrajectoryOptimization.HermiteSimpson" href="#TrajectoryOptimization.HermiteSimpson"><code>TrajectoryOptimization.HermiteSimpson</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Third-order Runge-Kutta method with first-order-hold on the controls</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/466b23960c72df7d9857d0b47c2640f5da57550e/src/static_model.jl#L38">source</a></section></article><h3 id="Defining-a-New-Integration-Scheme-1"><a class="docs-heading-anchor" href="#Defining-a-New-Integration-Scheme-1">Defining a New Integration Scheme</a><a class="docs-heading-anchor-permalink" href="#Defining-a-New-Integration-Scheme-1" title="Permalink"></a></h3><h4 id="Implicit-Methods-1"><a class="docs-heading-anchor" href="#Implicit-Methods-1">Implicit Methods</a><a class="docs-heading-anchor-permalink" href="#Implicit-Methods-1" title="Permalink"></a></h4><p>Implicit integration schemes are understandably simpler, since the output is not a function of itself, as is the case with implicit schemes. As such, as a minimum, the user only needs to define the following method for a new rule <code>MyQ</code>:</p><pre><code class="language-julia">x′ = discrete_dynamics(::Type{MyQ}, model::AbstractModel, x, u, dt)</code></pre><h4 id="Explicit-Methods-1"><a class="docs-heading-anchor" href="#Explicit-Methods-1">Explicit Methods</a><a class="docs-heading-anchor-permalink" href="#Explicit-Methods-1" title="Permalink"></a></h4><p>Explicit integration schemes are specified in a <a href="@ref"><code>DynamicsConstraint</code></a>. These methods are most efficiently computed when the entire trajectory is considered at once, thereby avoiding duplicate function evaluations. As a result, the user must define methods that deal with the entire trajectory at once:</p><pre><code class="language-julia">evaluate!(vals::Vector{&lt;:AbstractVector}, con::DynamicsConstraint{MyQ},
    Z::Traj, inds=1:length(Z)-1)</code></pre><p>Here <code>vals</code> is a Vector of Static Vectors, where the result of the calculation will be stored. <code>con</code> is a <code>DynamicsConstraint</code> that specifies the integration scheme, <code>Z</code> is the trajectory, and <code>inds</code> are the knotpoints where the constraint is applied (which should always be 1:N-1 if you have a single model for the entire trajectory). The method should compute</p><pre><code class="language-julia">vals[k] = x[k+1] - f(x[k],u[k],x[k+1],u[k+1])</code></pre><p>which is the amount of dynamic infeasibility between knotpoints. The method should obviously loop over the entire trajectory (see implementation for <code>HermiteSimpson</code>).</p><h4 id="Integrating-Cost-Functions-1"><a class="docs-heading-anchor" href="#Integrating-Cost-Functions-1">Integrating Cost Functions</a><a class="docs-heading-anchor-permalink" href="#Integrating-Cost-Functions-1" title="Permalink"></a></h4><p>Some methods, such as DIRCOL, apply the integration scheme to the cost function, as well. This can be done for a new integration rule by defining the following methods:</p><pre><code class="language-julia">cost(obj::Objective, dyn_con::DynamicsConstraint{MyQ}, Z::Traj)
cost_gradient!(E::CostExpansion, obj::Objective, dyn_con::DynamicsConstraint{MyQ}, Z::Traj)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="index.html">« Introduction</a><a class="docs-footer-nextpage" href="costfunctions.html">2. Setting up an Objective »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 24 December 2019 11:08">Tuesday 24 December 2019</span>. Using Julia version 1.2.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
