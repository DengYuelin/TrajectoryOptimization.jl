<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Setting up a Dynamics Model · TrajectoryOptimization</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>TrajectoryOptimization</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">TrajectoryOptimization.jl</a></li><li class="current"><a class="toctext" href>Setting up a Dynamics Model</a><ul class="internal"><li class="toplevel"><a class="toctext" href="#Overview-1">Overview</a></li><li class="toplevel"><a class="toctext" href="#Continuous-Models-1">Continuous Models</a></li><li><a class="toctext" href="#From-analytical-function-1">From analytical function</a></li><li><a class="toctext" href="#With-analytical-Jacobians-1">With analytical Jacobians</a></li><li><a class="toctext" href="#URDF-Files-1">URDF Files</a></li><li><a class="toctext" href="#A-note-on-Model-types-1">A note on Model types</a></li><li class="toplevel"><a class="toctext" href="#Discrete-Models-1">Discrete Models</a></li><li><a class="toctext" href="#From-a-continuous-model-1">From a continuous model</a></li><li><a class="toctext" href="#Analytical-1">Analytical</a></li><li><a class="toctext" href="#From-Continuous-Model-1">From Continuous Model</a></li><li class="toplevel"><a class="toctext" href="#API-1">API</a></li></ul></li><li><a class="toctext" href="../constraints/">Constraints</a></li><li><a class="toctext" href="../problem/">Setting up a Problem</a></li><li><a class="toctext" href="../solvers/">Solvers</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Setting up a Dynamics Model</a></li></ul><a class="edit-page" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/master/docs/src/models.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Setting up a Dynamics Model</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Setting-up-a-Dynamics-Model-1" href="#Setting-up-a-Dynamics-Model-1">Setting up a Dynamics Model</a></h1><ul><li><a href="../constraints/#Constraints-1">Constraints</a></li><li><a href="../constraints/#Constraint-Type-1">Constraint Type</a></li><li><a href="../constraints/#Creating-Constraints-1">Creating Constraints</a></li><ul><li><a href="../constraints/#Special-Constraints-1">Special Constraints</a></li></ul><li><a href="#Setting-up-a-Dynamics-Model-1">Setting up a Dynamics Model</a></li><li><a href="#Overview-1">Overview</a></li><li><a href="#Continuous-Models-1">Continuous Models</a></li><ul><li><a href="#From-analytical-function-1">From analytical function</a></li><li><a href="#With-analytical-Jacobians-1">With analytical Jacobians</a></li><li><a href="#URDF-Files-1">URDF Files</a></li><li><a href="#A-note-on-Model-types-1">A note on Model types</a></li></ul><li><a href="#Discrete-Models-1">Discrete Models</a></li><ul><li><a href="#From-a-continuous-model-1">From a continuous model</a></li><li><a href="#Analytical-1">Analytical</a></li><li><a href="#From-Continuous-Model-1">From Continuous Model</a></li></ul><li><a href="#API-1">API</a></li><li><a href="../solvers/#Solvers-1">Solvers</a></li><li><a href="../solvers/#Iterative-LQR-(iLQR)-1">Iterative LQR (iLQR)</a></li><li><a href="../problem/#Setting-up-a-Problem-1">Setting up a Problem</a></li><ul><li><a href="../problem/#Creating-a-Problem-1">Creating a Problem</a></li><li><a href="../problem/#Adding-constraints-1">Adding constraints</a></li></ul><li><a href="../#TrajectoryOptimization.jl-1">TrajectoryOptimization.jl</a></li><li><a href="../#Overview-1">Overview</a></li><li><a href="../#Getting-Started-1">Getting Started</a></li><ul><li><a href="../#Creating-a-Model-1">Creating a Model</a></li><li><a href="../#Creating-an-Objective-1">Creating an Objective</a></li><li><a href="../#Solving-the-Problem-1">Solving the Problem</a></li><li><a href="../#Solve-Methods-1">Solve Methods</a></li><li><a href="../#DIRCOL-Method-1">DIRCOL Method</a></li></ul></ul><h1><a class="nav-anchor" id="Overview-1" href="#Overview-1">Overview</a></h1><p>The Model type holds information about the dynamics of the system. All dynamics are assumed to be state-space models of the system of the form ẋ = f(x,u) where ẋ is the state derivative, x an n-dimentional state vector, and u in an m-dimensional control input vector. The function f can be any nonlinear function.</p><p>TrajectoryOptimization.jl poses the trajectory optimization problem by discretizing the state and control trajectories, which requires discretizing the dynamics, turning the continuous time differential equation into a discrete time difference equation of the form x[k+1] = f(x[k],u[k]), where k is the time step. There many methods of performing this discretization, and TrajectoryOptimization.jl offers several of the most common methods.</p><p>Sometimes is it convenient to write down the difference equation directly, rather than running a differential equation through a discretizing integration method. TrajectoryOptimization.jl offers method deal directly with either continuous differential equations, or discrete difference equations.</p><p>The <code>Model</code> type is parameterized by the <code>DynamicsType</code>, which is either <code>Continuous</code>, or <code>Discrete</code>. The models holds the equation f and it&#39;s Jacobian, ∇f, along with the dimensions of the state and control vectors.</p><p>Models can be created by writing down the dynamics analytically or be generated from a URDF file via <a href="https://github.com/JuliaRobotics/RigidBodyDynamics.jl"><code>RigidBodyDynamics.jl</code></a>.</p><h1><a class="nav-anchor" id="Continuous-Models-1" href="#Continuous-Models-1">Continuous Models</a></h1><h2><a class="nav-anchor" id="From-analytical-function-1" href="#From-analytical-function-1">From analytical function</a></h2><p>Let&#39;s start by writing down a dynamics function for a simple pendulum with state [θ; ω] and a torque control input</p><pre><code class="language-julia">function pendulum_dynamics!(xdot,x,u)
    m = 1.
    l = 0.5
    b = 0.1
    lc = 0.5
    J = 0.25
    g = 9.81
    xdot[1] = x[2]
    xdot[2] = (u[1] - m*g*lc*sin(x[1]) - b*x[2])/J
end</code></pre><p>Note that the function is in-place, in that it writes the result to the first argument. It is also good practice to concretely specify the location to write to rather than using something like <code>xdot[1:end]</code> or <code>xdot[:]</code>.</p><p>Notice that we had to specify a handful of constants when writing down the dynamics. We could have initialized them outside the scope of the function (which may result in global variables, so be careful!) or we can pass them in as a <code>NamedTuple</code> of parameters:</p><pre><code class="language-julia">function pendulum_dynamics_params!(xdot,x,u,p)
    xdot[1] = x[2]
    xdot[2] = (u[1] - p.m * p.g * p.lc * sin(x[1]) - p.b*x[2])/p.J
end</code></pre><p>We can now create our model using our analytical dynamics function with or without the parameters tuple</p><pre><code class="language-julia">n,m = 2,1
model = Model(pendulum_dynamics!, n, m)

params = (m=1, l=0.5, b=0.1, lc=0.5, J=0.25, g=9.81)
model = Model(pendulum_dynamics_params!, n, m, params)</code></pre><h2><a class="nav-anchor" id="With-analytical-Jacobians-1" href="#With-analytical-Jacobians-1">With analytical Jacobians</a></h2><p>Since we have a very simple model, writing down an analytical expression of the Jacobian is pretty easy:</p><pre><code class="language-julia">function pendulum_jacobian!(Z,x,u)
    m = 1.
    l = 0.5
    b = 0.1
    lc = 0.5
    J = 0.25
    g = 9.81

    Z[1,1] = 0                    # ∂θdot/∂θ
    Z[1,2] = 1                    # ∂θdot/∂ω
    Z[1,3] = 0                    # ∂θ/∂u
    Z[2,1] = -m*g*lc*cos(x[1])/J  # ∂ωdot/∂θ
    Z[2,2] = -b/J                 # ∂ωdot/∂ω
    Z[2,3] = 1/J                  # ∂ωdot/∂u
end

function pendulum_jacobian_params!(Z,x,u,p)
    Z[1,1] = 0                                    # ∂θdot/∂θ
    Z[1,2] = 1                                    # ∂θdot/∂ω
    Z[1,3] = 0                                    # ∂θ/∂u
    Z[2,1] = -p.m * p.g * p.lc * cos(x[1]) / p.J  # ∂ωdot/∂θ
    Z[2,2] = -p.b / p.J                           # ∂ωdot/∂ω
    Z[2,3] = 1/p.J                                # ∂ωdot/∂u
end</code></pre><p>We can then pass these functions into the model instead of using <code>ForwardDiff</code> to calculate them</p><pre><code class="language-julia">model = Model(pendulum_dynamics!, pendulum_jacobian!, n, m)
model = Model(pendulum_dynamics_params!, pendulum_jacobian_params!, n, m, params)</code></pre><h2><a class="nav-anchor" id="URDF-Files-1" href="#URDF-Files-1">URDF Files</a></h2><p>Instead of writing down the dynamics explicity, we can import the dynamics from geometry specified in a URDF model using <code>RigidBodyDynamics.jl</code>. Let&#39;s say we have a URDF file for a double pendulum and don&#39;t want to both writing down the dynamics, then we can create a model using any of the following methods</p><pre><code class="language-julia">using RigidBodyDynamics
# From a string
urdf = &quot;doublependulum.urdf&quot;
model = Model(urdf)

# From a RigidBodyDynamics `Mechanism` type
mech = parse_urdf(urdf)  # return a Mechanism type
model = Model(mech)</code></pre><p>Now let&#39;s say we want to control an <code>acrobot</code>, which can only control the first joint. We can pass in a vector of Booleans to specify which of the joints are &quot;active.&quot;</p><pre><code class="language-julia">joints = [true,false]

# From a string
urdf = &quot;doublependulum.urdf&quot;
model = Model(urdf,joints)

# From a RigidBodyDynamics `Mechanism` type
mech = parse_urdf(urdf)  # return a Mechanism type
model = Model(mech,joints)</code></pre><h2><a class="nav-anchor" id="A-note-on-Model-types-1" href="#A-note-on-Model-types-1">A note on Model types</a></h2><p>While the constructors look very similar, URDF models actually return a slightly different type than the the analytical ones of the first section. Analytical models are represented by</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrajectoryOptimization.AnalyticalModel" href="#TrajectoryOptimization.AnalyticalModel"><code>TrajectoryOptimization.AnalyticalModel</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct AnalyticalModel{D} &lt;: Model{D}</code></pre><p>Dynamics model</p><p>Holds all information required to uniquely describe a dynamic system, including a general nonlinear dynamics function of the form <code>ẋ = f(x,u)</code>, where x ∈ ℜⁿ are the states and u ∈ ℜᵐ are the controls.</p><p>Dynamics function <code>Model.f</code> should be in the following forms:     &#39;f!(ẋ,x,u)&#39; and modify ẋ in place</p></div></div><a class="source-link" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/f751b3668d3fcdef4ae2391cf0f53953e1591352/src/model.jl#L9">source</a></section><p>whereas those created from a URDF are represented by</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrajectoryOptimization.RBDModel" href="#TrajectoryOptimization.RBDModel"><code>TrajectoryOptimization.RBDModel</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct RBDModel{D} &lt;: Model{D}</code></pre><p>RigidBodyDynamics model. Wrapper for a RigidBodyDynamics Mechanism</p></div></div><a class="source-link" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/f751b3668d3fcdef4ae2391cf0f53953e1591352/src/model.jl#L201">source</a></section><p>which explicitly stores the <code>Mechanism</code> internally. </p><h1><a class="nav-anchor" id="Discrete-Models-1" href="#Discrete-Models-1">Discrete Models</a></h1><p>The previous methods all generate models with continuous dynamics (note that all of the models returned above will be of the type <code>Model{Continuous}</code>). In order to perform trajectory optimization we need to have discrete dynamics. Typically, we will form the continuous dynamics as we did above and then use a particular integration scheme to discretize it. Alternatively, we may know the analytical expression for the discrete dynamics.</p><h2><a class="nav-anchor" id="From-a-continuous-model-1" href="#From-a-continuous-model-1">From a continuous model</a></h2><p>Assuming we have a model of type <code>Model{Continuous}</code>, we can discretize as follows:</p><pre><code class="language-julia">model_discrete = Model{Discrete}(model,discretizer)</code></pre><p>where <code>discretizer</code> is a function that returns a discretized version of the continuous dynamics. TrajectoryOptimization.jl offers the following integration schemes</p><ul><li>midpoint</li><li>rk3 (Third Order Runge-Kutta)</li><li>rk4 (Fourth Order Runge-Kutta)</li></ul><p>So to create a discrete model of the pendulum with fourth order Runge-Kutta integration we would do the following</p><pre><code class="language-julia"># Create the continuous model (any of the previously mentioned method would work here)
params = (m=1, l=0.5, b=0.1, lc=0.5, J=0.25, g=9.81)
model = Model(pendulum_dynamics_params!, n, m, params)

# Discretize the continuous model
model_discrete = Model{Discrete}(model,rk4)</code></pre><h2><a class="nav-anchor" id="Analytical-1" href="#Analytical-1">Analytical</a></h2><p>An analytical model with discrete dynamics can be created using the following constructors</p><h2><a class="nav-anchor" id="From-Continuous-Model-1" href="#From-Continuous-Model-1">From Continuous Model</a></h2><p>A discrete model can be created from a continuous model by specifying the integration (discretization) method. The following methods are currently supported</p><p>Use the following method to discretize a continuous model with one of the integration methods listed previously</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrajectoryOptimization.Model-Union{Tuple{Discrete}, Tuple{Model{Continuous},Function}} where Discrete" href="#TrajectoryOptimization.Model-Union{Tuple{Discrete}, Tuple{Model{Continuous},Function}} where Discrete"><code>TrajectoryOptimization.Model</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Convert a continuous dynamics model into a discrete one using the given discretization function.     The discretization function can either be one of the currently supported functions (midpoint, rk3, rk4) or a custom method that has the following form     <code>function discretizer(f::Function,dt::Float64)         function fd!(xdot,x,u,dt)             # Your code             return nothing         end         return fd!     end</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/f751b3668d3fcdef4ae2391cf0f53953e1591352/src/model.jl#L336">source</a></section><h1><a class="nav-anchor" id="API-1" href="#API-1">API</a></h1><p>The following constructors can be used to create a model from an analytic function, with or without parameters or analyical Jacobians</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrajectoryOptimization.Model" href="#TrajectoryOptimization.Model"><code>TrajectoryOptimization.Model</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Model(f::Function, n::Int64, m::Int64) -&gt; TrajectoryOptimization.AnalyticalModel{Continuous}
Model(f::Function, n::Int64, m::Int64, d::Dict{Symbol,Any}) -&gt; TrajectoryOptimization.AnalyticalModel{Continuous}
</code></pre><p>Create a dynamics model, using ForwardDiff to generate the dynamics jacobian, with parameters Dynamics function passes in parameters:     f(ẋ,x,u,p)     where p in NamedTuple of parameters</p></div></div><a class="source-link" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/f751b3668d3fcdef4ae2391cf0f53953e1591352/src/model.jl#L75-L81">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrajectoryOptimization.Model" href="#TrajectoryOptimization.Model"><code>TrajectoryOptimization.Model</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Model(f::Function, n::Int64, m::Int64, p::NamedTuple) -&gt; TrajectoryOptimization.AnalyticalModel{Continuous}
Model(f::Function, n::Int64, m::Int64, p::NamedTuple, d::Dict{Symbol,Any}) -&gt; TrajectoryOptimization.AnalyticalModel{Continuous}
</code></pre><p>Create a dynamics model, using ForwardDiff to generate the dynamics jacobian, without parameters Dynamics function of the form:     f(ẋ,x,u)</p></div></div><a class="source-link" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/f751b3668d3fcdef4ae2391cf0f53953e1591352/src/model.jl#L84-L89">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrajectoryOptimization.Model" href="#TrajectoryOptimization.Model"><code>TrajectoryOptimization.Model</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Model(f::Function, ∇f::Function, n::Int64, m::Int64, p::NamedTuple) -&gt; TrajectoryOptimization.AnalyticalModel{Continuous}
Model(f::Function, ∇f::Function, n::Int64, m::Int64, p::NamedTuple, d::Dict{Symbol,Any}) -&gt; TrajectoryOptimization.AnalyticalModel{Continuous}
</code></pre><p>Create a dynamics model with an analytical Jacobian, with parameters Dynamics functions pass in parameters:     f(ẋ,x,u,p)     ∇f(Z,x,u,p)     where p in NamedTuple of parameters</p></div></div><a class="source-link" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/f751b3668d3fcdef4ae2391cf0f53953e1591352/src/model.jl#L92-L99">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrajectoryOptimization.Model" href="#TrajectoryOptimization.Model"><code>TrajectoryOptimization.Model</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Model(f::Function, ∇f::Function, n::Int64, m::Int64) -&gt; TrajectoryOptimization.AnalyticalModel{Continuous}
Model(f::Function, ∇f::Function, n::Int64, m::Int64, d::Dict{Symbol,Any}) -&gt; TrajectoryOptimization.AnalyticalModel{Continuous}
</code></pre><p>Create a dynamics model with an analytical Jacobian, without parameters Dynamics functions pass of the form:     f(ẋ,x,u)     ∇f(Z,x,u)</p></div></div><a class="source-link" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/f751b3668d3fcdef4ae2391cf0f53953e1591352/src/model.jl#L105-L111">source</a></section><p>The following constructors can be used to create a Model from a URDF file</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrajectoryOptimization.Model-Tuple{Mechanism,Array}" href="#TrajectoryOptimization.Model-Tuple{Mechanism,Array}"><code>TrajectoryOptimization.Model</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Model(mech, torques)
</code></pre><p>Model(mech::Mechanism, torques::Array{Bool, 1}) Constructor for an underactuated mechanism, where torques is a binary array that specifies whether a joint is actuated.</p></div></div><a class="source-link" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/f751b3668d3fcdef4ae2391cf0f53953e1591352/src/model.jl#L216">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrajectoryOptimization.Model-Tuple{Mechanism}" href="#TrajectoryOptimization.Model-Tuple{Mechanism}"><code>TrajectoryOptimization.Model</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Model(mech)
</code></pre><p>Construct model from a <code>Mechanism</code> type from <code>RigidBodyDynamics</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/f751b3668d3fcdef4ae2391cf0f53953e1591352/src/model.jl#L249">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrajectoryOptimization.Model-Tuple{String}" href="#TrajectoryOptimization.Model-Tuple{String}"><code>TrajectoryOptimization.Model</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Model(urdf)
</code></pre><p>Construct a fully actuated model from a string to a urdf file</p></div></div><a class="source-link" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/f751b3668d3fcdef4ae2391cf0f53953e1591352/src/model.jl#L259">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TrajectoryOptimization.Model-Tuple{String,Array{Float64,1}}" href="#TrajectoryOptimization.Model-Tuple{String,Array{Float64,1}}"><code>TrajectoryOptimization.Model</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Model(urdf, torques)
</code></pre><p>Construct a partially actuated model from a string to a urdf file, where torques is a binary array that specifies whether a joint is actuated.</p></div></div><a class="source-link" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/f751b3668d3fcdef4ae2391cf0f53953e1591352/src/model.jl#L266">source</a></section><pre><code class="language-none">evaluate!(ẋ::AbstractVector,model::Model,x,u)
evaluate!(Z::AbstractMatrix,ẋ::AbstractVector,model::Model,x,u)
jacobian!(Z::AbstractMatrix,ẋ::AbstractVector,model::Model,x,u)
jacobian!(Z::AbstractMatrix,model::Model,x,u)
evals(model::Model)
reset(model::Model)</code></pre><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">TrajectoryOptimization.jl</span></a><a class="next" href="../constraints/"><span class="direction">Next</span><span class="title">Constraints</span></a></footer></article></body></html>
