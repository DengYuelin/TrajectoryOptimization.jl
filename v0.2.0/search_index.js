var documenterSearchIndex = {"docs":
[{"location":"constraint_api.html#","page":"Constraints","title":"Constraints","text":"CurrentModule = TrajectoryOptimization","category":"page"},{"location":"constraint_api.html#Constraints-1","page":"Constraints","title":"Constraints","text":"","category":"section"},{"location":"constraint_api.html#","page":"Constraints","title":"Constraints","text":"This page provides details about the various types in TrajectoryOptimization.jl for working with constraints, as well as the methods defined on those types.","category":"page"},{"location":"constraint_api.html#Constraint-Sets-1","page":"Constraints","title":"Constraint Sets","text":"","category":"section"},{"location":"constraint_api.html#","page":"Constraints","title":"Constraints","text":"ConstraintSet","category":"page"},{"location":"constraint_api.html#TrajectoryOptimization.ConstraintSet","page":"Constraints","title":"TrajectoryOptimization.ConstraintSet","text":"struct ConstraintSet{T}\n\nSet of all constraints for a trajectory optimization problem Holds a vector of ConstraintVals that specify where in the trajectory each constraint is applied. The ConstraintSet efficiently dispatches functions to all of the constraints.\n\nConstructors:\n\nConstraintSet(n,m,N)\nConstraintSet(n,m,Vector{<:ConstraintVals},N)\n\n\n\n\n\n","category":"type"},{"location":"constraint_api.html#Information-Methods-1","page":"Constraints","title":"Information Methods","text":"","category":"section"},{"location":"constraint_api.html#","page":"Constraints","title":"Constraints","text":"These methods provide or calculate information about the constraint set","category":"page"},{"location":"constraint_api.html#","page":"Constraints","title":"Constraints","text":"Base.size(::ConstraintSet)\nBase.length(::ConstraintSet)\nnum_constraints!\nnum_constraints","category":"page"},{"location":"constraint_api.html#Base.size-Tuple{ConstraintSet}","page":"Constraints","title":"Base.size","text":"Get size of state and control dimensions\n\n\n\n\n\n","category":"method"},{"location":"constraint_api.html#Base.length-Tuple{ConstraintSet}","page":"Constraints","title":"Base.length","text":"Get number of separate constraints (i.e. ConstraintVals) in the set\n\n\n\n\n\n","category":"method"},{"location":"constraint_api.html#TrajectoryOptimization.num_constraints!","page":"Constraints","title":"TrajectoryOptimization.num_constraints!","text":"Re-calculate the number of constraints in the constraint set\n\n\n\n\n\n","category":"function"},{"location":"constraint_api.html#TrajectoryOptimization.num_constraints","page":"Constraints","title":"TrajectoryOptimization.num_constraints","text":"num_constraints(::ConstraintSet)\nnum_constraints(::AbstractSolver)\nnum_constraints(::Problem)\n\nGet the total number of constraints at each time step\n\n\n\n\n\n","category":"function"},{"location":"constraint_api.html#Calculation-Methods-1","page":"Constraints","title":"Calculation Methods","text":"","category":"section"},{"location":"constraint_api.html#","page":"Constraints","title":"Constraints","text":"These methods perform calculations on the constraint set","category":"page"},{"location":"constraint_api.html#","page":"Constraints","title":"Constraints","text":"max_violation\nmax_penalty\nevaluate!(::ConstraintSet, ::Traj)\njacobian!(::ConstraintSet, ::Traj)\nreset!(::ConstraintSet)","category":"page"},{"location":"constraint_api.html#TrajectoryOptimization.max_violation","page":"Constraints","title":"TrajectoryOptimization.max_violation","text":"max_violation(conSet::ConstraintSet)\nmax_violation(conSet::ConstraintSet, Z::Traj)\nmax_violation(prob::Problem, Z=prob.Z)\nmax_violation(solver::AbstractSolver)\nmax_violation(solver::AbstractSolver, Z)\n\nCalculate the maximum constraint violation for the entire constraint set. \tIf the a trajectory is not passed in, the violation is computed from the currently \tstored constraint values; otherwise, the constraints are re-computed using the \ttrajectory passed in.\n\n\n\n\n\n","category":"function"},{"location":"constraint_api.html#TrajectoryOptimization.max_penalty","page":"Constraints","title":"TrajectoryOptimization.max_penalty","text":"Calculate the maximum penalty parameter across all constraints\n\n\n\n\n\n","category":"function"},{"location":"constraint_api.html#TrajectoryOptimization.evaluate!-Tuple{ConstraintSet,AbstractArray{#s63,1} where #s63<:KnotPoint}","page":"Constraints","title":"TrajectoryOptimization.evaluate!","text":"evaluate!(conSet::ConstraintSet, Z::Traj)\n\nCompute constraint values for all constraints for the entire trajectory\n\n\n\n\n\n","category":"method"},{"location":"constraint_api.html#TrajectoryOptimization.jacobian!-Tuple{ConstraintSet,AbstractArray{#s63,1} where #s63<:KnotPoint}","page":"Constraints","title":"TrajectoryOptimization.jacobian!","text":"jacobian!(conSet::ConstraintSet, Z::Traj)\n\nCompute constraint Jacobians for all constraints for the entire trajectory\n\n\n\n\n\n","category":"method"},{"location":"constraint_api.html#TrajectoryOptimization.reset!-Tuple{ConstraintSet}","page":"Constraints","title":"TrajectoryOptimization.reset!","text":"Reset all the Lagrange multipliers and constraint values to zero and \tpenalties the their initial value\n\n\n\n\n\n","category":"method"},{"location":"constraint_api.html#","page":"Constraints","title":"Constraints","text":"ConstraintSet supports indexing and iteration, which returns the ConstraintVals at that index. However, to avoid allocations, iteration directly on the .constraints field.","category":"page"},{"location":"constraint_api.html#","page":"Constraints","title":"Constraints","text":"Additionally, to avoid allocations when computing max_violation, you can call max_violation!(conSet) and then maximum(conSet.c_max) to perform the reduction in the scope where the result is stored (thereby avoiding an allocation).","category":"page"},{"location":"constraint_api.html#Changing-Dimension-1","page":"Constraints","title":"Changing Dimension","text":"","category":"section"},{"location":"constraint_api.html#","page":"Constraints","title":"Constraints","text":"change_dimension(conSet::ConstraintSet, n, m)","category":"page"},{"location":"constraint_api.html#TrajectoryOptimization.change_dimension-Tuple{ConstraintSet,Any,Any}","page":"Constraints","title":"TrajectoryOptimization.change_dimension","text":"change_dimension(conSet::ConstraintSet, n, m)\n\nChange the dimensionality of the constraint set to one that is strictly larger than the current dimensions. Useful for state and control augmentation. If the dimension change affects a particular constraint, it will be wrapped in an IndexedConstraint that simply passes the original sizes to the original constraints. Right now, this assumes that the original state and controls are first (i.e. the new states or controls are appended to the end of the state and control vectors).\n\n\n\n\n\n","category":"method"},{"location":"constraint_api.html#Implemented-Constraints-1","page":"Constraints","title":"Implemented Constraints","text":"","category":"section"},{"location":"constraint_api.html#","page":"Constraints","title":"Constraints","text":"The following is a list of the constraints currently implemented in TrajectoryOptimization.jl. Please refer to the docstrings for the individual constraints on details on their constructors, since each constraint is unique, in general.","category":"page"},{"location":"constraint_api.html#","page":"Constraints","title":"Constraints","text":"List of currently implemented constraints","category":"page"},{"location":"constraint_api.html#","page":"Constraints","title":"Constraints","text":"GoalConstraint\nBoundConstraint\nCircleConstraint\nSphereConstraint\nNormConstraint\nDynamicsConstraint\nIndexedConstraint","category":"page"},{"location":"constraint_api.html#","page":"Constraints","title":"Constraints","text":"GoalConstraint\nBoundConstraint\nCircleConstraint\nSphereConstraint\nNormConstraint\nDynamicsConstraint\nIndexedConstraint","category":"page"},{"location":"constraint_api.html#TrajectoryOptimization.GoalConstraint","page":"Constraints","title":"TrajectoryOptimization.GoalConstraint","text":"struct GoalConstraint{T, P, N, L} <: TrajectoryOptimization.AbstractConstraint{Equality,State,P}\n\nConstraint of the form x_g = a, where x_g can be only part of the state vector.\n\nConstructors:\n\nGoalConstraint(xf::AbstractVector)\nGoalConstraint(xf::AbstractVector, inds)\n\nwhere xf is an n-dimensional goal state. If inds is provided, only xf[inds] will be used.\n\n\n\n\n\n","category":"type"},{"location":"constraint_api.html#TrajectoryOptimization.BoundConstraint","page":"Constraints","title":"TrajectoryOptimization.BoundConstraint","text":"struct BoundConstraint{T, P, NM, PNM} <: TrajectoryOptimization.AbstractConstraint{Inequality,Stage,P}\n\nLinear bound constraint on states and controls\n\nConstructors\n\nBoundConstraint(n, m; x_min, x_max, u_min, u_max)\n\nAny of the bounds can be ±∞. The bound can also be specifed as a single scalar, which applies the bound to all state/controls.\n\n\n\n\n\n","category":"type"},{"location":"constraint_api.html#TrajectoryOptimization.CircleConstraint","page":"Constraints","title":"TrajectoryOptimization.CircleConstraint","text":"struct CircleConstraint{T, P} <: TrajectoryOptimization.AbstractConstraint{Inequality,State,P}\n\nConstraint of the form (x - x_c)^2 + (y - y_c)^2 leq r^2 where x, y are given by x[xi],x[yi], (x_cy_c) is the center of the circle, and r is the radius.\n\nConstructor:\n\nCircleConstraint(n, xc::SVector{P}, yc::SVector{P}, radius::SVector{P}, xi=1, yi=2)\n\n\n\n\n\n","category":"type"},{"location":"constraint_api.html#TrajectoryOptimization.SphereConstraint","page":"Constraints","title":"TrajectoryOptimization.SphereConstraint","text":"struct SphereConstraint{T, P} <: TrajectoryOptimization.AbstractConstraint{Inequality,State,P}\n\nConstraint of the form (x - x_c)^2 + (y - y_c)^2 + (z - z_c)^2 leq r^2 where x, y, z are given by x[xi],x[yi],x[zi], (x_cy_cz_c) is the center of the sphere, and r is the radius.\n\nConstructor:\n\nSphereConstraint(n, xc::SVector{P}, yc::SVector{P}, zc::SVector{P},\n\tradius::SVector{P}, xi=1, yi=2, zi=3)\n\n\n\n\n\n","category":"type"},{"location":"constraint_api.html#TrajectoryOptimization.NormConstraint","page":"Constraints","title":"TrajectoryOptimization.NormConstraint","text":"struct NormConstraint{S, W<:Union{Control, State}, T} <: TrajectoryOptimization.AbstractConstraint{S,W<:Union{Control, State},1}\n\nConstraint of the form y^2 leq= a where y is either a state or a control vector (but not both)\n\nConstructors:\n\nNormConstraint{S,State}(n,a)\nNormConstraint{S,Control}(m,a)\n\nwhere a is the constant on the right-hand side of the equation.\n\nExamples:\n\nNormConstraint{Equality,Control}(2,4.0)\n\ncreates a constraint equivalent to u^2 = 40 for a problem with 2 controls.\n\nNormConstraint{Inequality,State}(3, 2.3)\n\ncreates a constraint equivalent to x^2 leq 23 for a problem with 3 states.\n\n\n\n\n\n","category":"type"},{"location":"constraint_api.html#TrajectoryOptimization.DynamicsConstraint","page":"Constraints","title":"TrajectoryOptimization.DynamicsConstraint","text":"struct DynamicsConstraint{Q<:QuadratureRule, L<:AbstractModel, T, N, M, NM} <: TrajectoryOptimization.AbstractDynamicsConstraint{Coupled,N}\n\nAn equality constraint imposed by the discretized system dynamics. Links adjacent time steps. Supports both implicit and explicit integration methods. Can store values internally for more efficient computation of dynamics and dynamics Jacobians over the entire trajectory, particularly for explicit methods. These constraints are used in Direct solvers, where the dynamics are explicit stated as constraints in a more general optimization method.\n\nConstructors\n\nDynamicsConstraint{Q}(model::AbstractModel, N)\n\nwhere N is the number of knot points and Q<:QuadratureRule is the integration method.\n\n\n\n\n\n","category":"type"},{"location":"constraint_api.html#TrajectoryOptimization.IndexedConstraint","page":"Constraints","title":"TrajectoryOptimization.IndexedConstraint","text":"struct IndexedConstraint{S, W, P, N, M, w, C} <: TrajectoryOptimization.AbstractConstraint{S,W,P}\n\nCompute a constraint on an arbitrary portion of either the state or control, or both. Useful for dynamics augmentation. e.g. you are controlling two models, and have individual constraints on each. You can define constraints as if they applied to the individual model, and then wrap it in an IndexedConstraint to apply it to the appropriate portion of the concatenated state. Assumes the indexed state portion is contiguous.\n\nType params:\n\nS - Inequality or Equality\nW - ConstraintType\nP - Constraint length\nN,M - original state and control dimensions\nNM - N+M\nBx - location of the first element in the state index\nBu - location of the first element in the control index\nC - type of original constraint\n\nConstructors:\n\nIndexedConstraint(n, m, con)\nIndexedConstraint(n, m, con, ix::SVector, iu::SVector)\n\nwhere the arguments n and m are the state and control dimensions of the new dynamics. ix and iu are the indices into the state and control vectors. If left out, they are assumed to start at the beginning of the vector.\n\nNOTE: Only part of this functionality has been tested. Use with caution!\n\n\n\n\n\n","category":"type"},{"location":"constraint_api.html#ConstraintVals-Type-1","page":"Constraints","title":"ConstraintVals Type","text":"","category":"section"},{"location":"constraint_api.html#","page":"Constraints","title":"Constraints","text":"ConstraintVals","category":"page"},{"location":"constraint_api.html#TrajectoryOptimization.ConstraintVals","page":"Constraints","title":"TrajectoryOptimization.ConstraintVals","text":"struct ConstraintVals{T, W, C, P, N}\n\nStruct that stores all of the values associated with a particular constraint. Importantly, ConstraintVals stores the list of knotpoints to which the constraint is applied. This type should be fairly transparent to the user, and only needs to be directly dealt with when writing solvers or setting fine-tuned updates per constraint (via the .params field).\n\n\n\n\n\n","category":"type"},{"location":"rotations.html#","page":"Rotations","title":"Rotations","text":"CurrentModule = TrajectoryOptimization","category":"page"},{"location":"rotations.html#Rotations-1","page":"Rotations","title":"Rotations","text":"","category":"section"},{"location":"rotations.html#","page":"Rotations","title":"Rotations","text":"UnitQuaternion\nMRP\nRPY","category":"page"},{"location":"rotations.html#TrajectoryOptimization.UnitQuaternion","page":"Rotations","title":"TrajectoryOptimization.UnitQuaternion","text":"struct UnitQuaternion{T, D<:TrajectoryOptimization.DifferentialRotation} <: Rotation\n\n4-parameter attitute representation that is singularity-free. Quaternions with unit norm represent a double-cover of SO(3). The UnitQuaternion does NOT strictly enforce the unit norm constraint, but certain methods will assume you have a unit quaternion. The UnitQuaternion type is parameterized by the linearization method, which maps quaternions to the 3D plane tangent to the 4D unit sphere. Follows the Hamilton convention for quaternions.\n\nThere are currently 4 methods supported:\n\nVectorPart - uses the vector (or imaginary) part of the quaternion\nExponentialMap - the most common approach, uses the exponential and logarithmic maps\nCayleyMap - or Rodrigues parameters (aka Gibbs vectors).\nMRPMap - or Modified Rodrigues Parameter, is a sterographic projection of the 4D unit sphere\n\nonto the plane tangent to either the positive or negative real poles.\n\nConstructors\n\nUnitQuaternion(s,x,y,z)  # defaults to `VectorPart`\nUnitQuaternion{D}(s,x,y,z)\nUnitQuaternion{D}(q::SVector{4})\nUnitQuaternion{D}(r::SVector{3})  # quaternion with 0 real part\n\n\n\n\n\n","category":"type"},{"location":"rotations.html#TrajectoryOptimization.MRP","page":"Rotations","title":"TrajectoryOptimization.MRP","text":"struct MRP{T} <: Rotation\n\nModified Rodrigues Parameter. Is a 3D parameterization of attitude, and is a sterographic projection of the 4D unit sphere onto the plane tangent to the negative real pole. They have a singularity at θ = ±180°.\n\nConstructors\n\nMRP(x, y, z) MRP(r::SVector{3})\n\n\n\n\n\n","category":"type"},{"location":"rotations.html#TrajectoryOptimization.RPY","page":"Rotations","title":"TrajectoryOptimization.RPY","text":"struct RPY{T} <: Rotation\n\nRoll-pitch-yaw Euler angles.\n\n\n\n\n\n","category":"type"},{"location":"models.html#model_section-1","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"","category":"section"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"CurrentModule = TrajectoryOptimization","category":"page"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"Pages = [\"models.md\"]","category":"page"},{"location":"models.html#Overview-1","page":"1. Setting up a Dynamics Model","title":"Overview","text":"","category":"section"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"The Model type holds information about the dynamics of the system. All dynamics are assumed to be state-space models of the system of the form dotx = f(xu) where dotx is the state derivative, x an n-dimensional state vector, and u in an m-dimensional control input vector. The function f can be any nonlinear function.","category":"page"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"TrajectoryOptimization.jl solves the trajectory optimization problem by discretizing the state and control trajectories, which requires discretizing the dynamics, i.e., turning the continuous time differential equation into a discrete time difference equation of the form x_k+1 = f(x_k u_k), where k is the time step. There many methods of performing this discretization, and TrajectoryOptimization.jl offers several of the most common methods. See Model Discretization section for more information on discretizing dynamics, as well as how to define custom integration methods.","category":"page"},{"location":"models.html#Creating-a-New-Model-1","page":"1. Setting up a Dynamics Model","title":"Creating a New Model","text":"","category":"section"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"To create a new model of a dynamical system, you need to define a new type that inherits from AbstractModel. You will need to then define only a few methods on your type. Let's say we want to create a model of the canonical cartpole. We start by defining our type:","category":"page"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"struct Cartpole{T} <: AbstractModel\n    mc::T  # mass of the cart\n    mp::T  # mass of the pole\n    l::T   # length of the pole\n    g::T   # gravity\nend","category":"page"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"It's often convenient to store any model parameters inside the new type (make sure they're concrete types!). If you need to store vectors or matrices, we highly recommend using StaticArrays, which are extremely fast and avoid memory allocations. For models with lots of parameters, we recommend Parameters.jl that makes it easy to specify default parameters.","category":"page"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"We now just need to define two functions to complete the interface","category":"page"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"import TrajectoryOptimization: dynamics  # the dynamics function must be imported\n\nfunction dynamics(model::Cartpole, x, u)\n    mc = model.mc  # mass of the cart in kg (10)\n    mp = model.mp   # mass of the pole (point mass at the end) in kg\n    l = model.l   # length of the pole in m\n    g = model.g  # gravity m/s^2\n\n    q = x[ @SVector [1,2] ]\n    qd = x[ @SVector [3,4] ]\n\n    s = sin(q[2])\n    c = cos(q[2])\n\n    H = @SMatrix [mc+mp mp*l*c; mp*l*c mp*l^2]\n    C = @SMatrix [0 -mp*qd[2]*l*s; 0 0]\n    G = @SVector [0, mp*g*l*s]\n    B = @SVector [1, 0]\n\n    qdd = -H\\(C*qd + G - B*u[1])\n    return [qd; qdd]\nend\n\nBase.size(::Cartpole) = 4,1","category":"page"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"And voila! we have a new model.","category":"page"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"We now have a few methods automatically available to us:","category":"page"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"dynamics\njacobian","category":"page"},{"location":"models.html#TrajectoryOptimization.dynamics","page":"1. Setting up a Dynamics Model","title":"TrajectoryOptimization.dynamics","text":"ẋ = dynamics(model, z::KnotPoint)\n\nCompute the continuous dynamics of a dynamical system given a KnotPoint\n\n\n\n\n\n","category":"function"},{"location":"models.html#Time-varying-systems-(experimental)-1","page":"1. Setting up a Dynamics Model","title":"Time-varying systems (experimental)","text":"","category":"section"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"TrajectoryOptimization.jl also offers experimental support for time-varying systems. Let's say for some reason the mass of our cartpole is decreasing linearly with time. We can model this with a slight modification to the dynamics function signature:","category":"page"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"import TrajectoryOptimization: dynamics\n\nstruct CartpoleTimeVarying{T} <: AbstractModel\n    mc::T  # initial mass of the cart\n    mp::T  # mass of the pole\n    l::T   # length of the pole\n    g::T   # gravity\nend\n\nfunction dynamics(model::CartpoleTimeVarying, x, u, t)  # note extra time parameter\n    mc = model.mc  # mass of the cart in kg (10)\n    mp = model.mp   # mass of the pole (point mass at the end) in kg\n    l = model.l   # length of the pole in m\n    g = model.g  # gravity m/s^2\n\n    # Change the mass of the cart with time\n    mc = mc - 0.01*t\n\n    q = x[ @SVector [1,2] ]\n    qd = x[ @SVector [3,4] ]\n\n    s = sin(q[2])\n    c = cos(q[2])\n\n    H = @SMatrix [mc+mp mp*l*c; mp*l*c mp*l^2]\n    C = @SMatrix [0 -mp*qd[2]*l*s; 0 0]\n    G = @SVector [0, mp*g*l*s]\n    B = @SVector [1, 0]\n\n    qdd = -H\\(C*qd + G - B*u[1])\n    return [qd; qdd]\nend\n\nBase.size(::CartpoleTimeVarying) = 4,1","category":"page"},{"location":"models.html#Models-with-3D-Rotations-(experimental)-1","page":"1. Setting up a Dynamics Model","title":"Models with 3D Rotations (experimental)","text":"","category":"section"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"TrajectoryOptimization.jl offers experimental support for models with non-Euclidean state vectors, such as 3D rotations, which live in SO(3) instead of mathbbR^4 (quaternions) or mathbbR^3 (Euler angles, or Modified Rodrigues Parameters). See RigidBody section for more details.","category":"page"},{"location":"solver_interface.html#","page":"Solver Interface","title":"Solver Interface","text":"CurrentModule = TrajectoryOptimization","category":"page"},{"location":"solver_interface.html#","page":"Solver Interface","title":"Solver Interface","text":"Pages = [\"solver_interface.md\"]","category":"page"},{"location":"solver_interface.html#Solver-Interface-1","page":"Solver Interface","title":"Solver Interface","text":"","category":"section"},{"location":"solver_interface.html#","page":"Solver Interface","title":"Solver Interface","text":"Solvers are currently organized into the following type tree:","category":"page"},{"location":"solver_interface.html#","page":"Solver Interface","title":"Solver Interface","text":"AbstractSolver\nUnconstrainedSolver\nConstrainedSolver\nDirectSolver","category":"page"},{"location":"solver_interface.html#","page":"Solver Interface","title":"Solver Interface","text":"The solver options type is a lightweight container for all of the options the user can specify, such as tolerance values, printing verbosity (highly recommended), Boolean flags, etc. We highly suggest using Parameters.jl to create this and easily specify the default options. All solver options should be mutable (e.g. mutable struct NewSolverOptions{T} <: AbstractSolverOptions{T})","category":"page"},{"location":"solver_interface.html#","page":"Solver Interface","title":"Solver Interface","text":"The solver type, on the other hand, is meant to contain all of the variables needed for the solve, including the model, objective, constraints, and other information originally in the Problem. This information is \"duplicated\" in the solver since oftentimes the solver with perform modifications to these when setting up the solve. For example, the AugmentedLagrangianSolver creates an ALObjective and uses that as it's objective instead. Similarly, ALTRO may convert the model to an InfeasibleModel to leverage an initial state trajectory. Therefore, once the solver is created, the problem is solved by simply calling solve!(solver), which then runs the optimization.","category":"page"},{"location":"solver_interface.html#Defining-a-New-Solver-1","page":"Solver Interface","title":"Defining a New Solver","text":"","category":"section"},{"location":"solver_interface.html#","page":"Solver Interface","title":"Solver Interface","text":"For creating a new solver, e.g. NewSolver, the user must define two new types:","category":"page"},{"location":"solver_interface.html#","page":"Solver Interface","title":"Solver Interface","text":"NewSolverOptions{T} <: AbstractSolverOptions{T}\nNewSolver{T} <: AbstractSolver{T}","category":"page"},{"location":"solver_interface.html#","page":"Solver Interface","title":"Solver Interface","text":"Below we list the methods needed to implement the different solver interfaces, along with a list of inherited methods (that can be overloaded as needed). The docstrings for these functions are listed in more detail down below.","category":"page"},{"location":"solver_interface.html#Unconstrained-Solvers-1","page":"Solver Interface","title":"Unconstrained Solvers","text":"","category":"section"},{"location":"solver_interface.html#","page":"Solver Interface","title":"Solver Interface","text":"Needed methods:","category":"page"},{"location":"solver_interface.html#","page":"Solver Interface","title":"Solver Interface","text":"model = get_model(::NewSolver)\nobj = get_objective(::NewSolver)\nZ = get_trajectory(::NewSolver)\nn,m,N = Base.size(::NewSolver)\nx0 = get_initial_state(::NewSolver)\nsolve!(::NewSolver)","category":"page"},{"location":"solver_interface.html#","page":"Solver Interface","title":"Solver Interface","text":"Needed fields (these will likely be replaced by getters in the near future):","category":"page"},{"location":"solver_interface.html#","page":"Solver Interface","title":"Solver Interface","text":"opts - instance of AbstractSolverOptions\nstats - mutable struct containing statistics on the solve","category":"page"},{"location":"solver_interface.html#","page":"Solver Interface","title":"Solver Interface","text":"Inherited methods:","category":"page"},{"location":"solver_interface.html#","page":"Solver Interface","title":"Solver Interface","text":"states(::NewSolver)\ncontrols(::NewSolver)\ninitial_states!(::NewSolver, X0)\ninitial_controls!(::NewSolver, U0)\ninitial_trajectory!(::NewSolver, Z::Traj)\ncost(::NewSolver, Z=get_trajectory(::NewSolver))\nrollout!(::NewSolver)","category":"page"},{"location":"solver_interface.html#Constrained-Solvers-1","page":"Solver Interface","title":"Constrained Solvers","text":"","category":"section"},{"location":"solver_interface.html#","page":"Solver Interface","title":"Solver Interface","text":"Needed methods (in addition to those for Unconstrained Solvers):","category":"page"},{"location":"solver_interface.html#","page":"Solver Interface","title":"Solver Interface","text":"get_constraints(::NewSolver)","category":"page"},{"location":"solver_interface.html#","page":"Solver Interface","title":"Solver Interface","text":"Inherited methods (in addition to those for Unconstrained Solvers):","category":"page"},{"location":"solver_interface.html#","page":"Solver Interface","title":"Solver Interface","text":"num_constraints(::NewSolver)\nmax_violation(::NewSolver, Z=get_trajectory(::NewSolver))\nupdate_constraints!(::NewSolver, Z=get_trajectory(::NewSolver))\nupdate_active_set!(::NewSolver, Z=get_trajectory(::NewSolver))","category":"page"},{"location":"solver_interface.html#Direct-Solvers-1","page":"Solver Interface","title":"Direct Solvers","text":"","category":"section"},{"location":"solver_interface.html#","page":"Solver Interface","title":"Solver Interface","text":"Currently, direct solvers solve the problem by forming a large, sparse matrix by concatenating the states and controls for all time steps. They need to generate a list of indices that map the constraints to their location in the concatenated array of constraint values, which can be done using gen_con_inds. This must be stored as the con_inds field in the DirectSolver (this will be replaced by a getter method in the near future). With this, all DirectSolvers inherit the following methods for copying values to and from the large, concatenated vectors and matrices:","category":"page"},{"location":"solver_interface.html#","page":"Solver Interface","title":"Solver Interface","text":"copy_constraints!(d, ::DirectSolver)\ncopy_active_set!(a, ::DirectSolver)\ncopy_jacobians!(D, ::DirectSolver)","category":"page"},{"location":"solver_interface.html#Unconstrained-Solvers-2","page":"Solver Interface","title":"Unconstrained Solvers","text":"","category":"section"},{"location":"solver_interface.html#","page":"Solver Interface","title":"Solver Interface","text":"AbstractSolver\nUnconstrainedSolver\nstates\ncontrols\ninitial_trajectory!\ninitial_states!\ninitial_controls!\ncost\ncost_expansion!","category":"page"},{"location":"solver_interface.html#TrajectoryOptimization.AbstractSolver","page":"Solver Interface","title":"TrajectoryOptimization.AbstractSolver","text":"abstract type AbstractSolver <: MathOptInterface.AbstractNLPEvaluator\n\nAbstract solver for trajectory optimization problems\n\nAny type that inherits from AbstractSolver must define the following methods:\n\nmodel = get_model(::AbstractSolver)::AbstractModel\nobj = get_objective(::AbstractSolver)::AbstractObjective\nZ = get_trajectory(::AbstractSolver)::Traj\nn,m,N = Base.size(::AbstractSolver)\nx0 = get_initial_state(::AbstractSolver)::SVector\nsolve!(::AbstractSolver)\n\n\n\n\n\n","category":"type"},{"location":"solver_interface.html#TrajectoryOptimization.UnconstrainedSolver","page":"Solver Interface","title":"TrajectoryOptimization.UnconstrainedSolver","text":"abstract type UnconstrainedSolver <: TrajectoryOptimization.AbstractSolver{T}\n\nUnconstrained optimization solver. Will ignore any constraints in the problem\n\n\n\n\n\n","category":"type"},{"location":"solver_interface.html#TrajectoryOptimization.states","page":"Solver Interface","title":"TrajectoryOptimization.states","text":"states(::Problem)\nstates(::AbstractSolver)\nstates(::Traj)\n\nGet the state trajectory\n\n\n\n\n\n","category":"function"},{"location":"solver_interface.html#TrajectoryOptimization.controls","page":"Solver Interface","title":"TrajectoryOptimization.controls","text":"controls(::Problem)\ncontrols(::AbstractSolver)\ncontrols(::Traj)\n\nGet the control trajectory\n\n\n\n\n\n","category":"function"},{"location":"solver_interface.html#TrajectoryOptimization.initial_trajectory!","page":"Solver Interface","title":"TrajectoryOptimization.initial_trajectory!","text":"initial_trajectory!(::Problem, Z)\ninitial_trajectory!(::AbstractSolver, Z)\n\nCopy the trajectory \n\n\n\n\n\n","category":"function"},{"location":"solver_interface.html#TrajectoryOptimization.initial_states!","page":"Solver Interface","title":"TrajectoryOptimization.initial_states!","text":"initial_states!(::Union{Problem,AbstractSolver}, X0::Vector{<:AbstractVector})\ninitial_states!(::Union{Problem,AbstractSolver}, X0::AbstractMatrix)\n\nCopy the state trajectory \n\n\n\n\n\n","category":"function"},{"location":"solver_interface.html#TrajectoryOptimization.initial_controls!","page":"Solver Interface","title":"TrajectoryOptimization.initial_controls!","text":"initial_controls!(::Union{Problem,AbstractSolver}, U0::Vector{<:AbstractVector})\ninitial_controls!(::Union{Problem,AbstractSolver}, U0::AbstractMatrx)\n\nCopy the control trajectory \n\n\n\n\n\n","category":"function"},{"location":"solver_interface.html#TrajectoryOptimization.cost","page":"Solver Interface","title":"TrajectoryOptimization.cost","text":"cost(obj::Objective, Z::Traj)::Float64\ncost(obj::Objective, dyn_con::DynamicsConstraint{Q}, Z::Traj)\n\nEvaluate the cost for a trajectory. Calculate the cost gradient for an entire trajectory. If a dynamics constraint is given,     use the appropriate integration rule, if defined.\n\n\n\n\n\ncost(::Problem)\ncost(::AbstractSolver)\n\nCompute the cost for the current trajectory\n\n\n\n\n\n","category":"function"},{"location":"solver_interface.html#TrajectoryOptimization.cost_expansion!","page":"Solver Interface","title":"TrajectoryOptimization.cost_expansion!","text":"cost_expansion!(E::Any, obj::Objective, Z::AbstractArray{#s63,1} where #s63<:KnotPoint)\n\n\nExpand cost for entire trajectory\n\n\n\n\n\n","category":"function"},{"location":"solver_interface.html#Constrained-Solvers-2","page":"Solver Interface","title":"Constrained Solvers","text":"","category":"section"},{"location":"solver_interface.html#","page":"Solver Interface","title":"Solver Interface","text":"ConstrainedSolver\nupdate_constraints!\nupdate_active_set!\nconstraint_jacobian!","category":"page"},{"location":"solver_interface.html#TrajectoryOptimization.ConstrainedSolver","page":"Solver Interface","title":"TrajectoryOptimization.ConstrainedSolver","text":"abstract type ConstrainedSolver <: TrajectoryOptimization.AbstractSolver{T}\n\nAbstract solver for constrained trajectory optimization problems\n\nIn addition to the methods required for AbstractSolver, all ConstrainedSolvers     must define the following method\n\nget_constraints(::ConstrainedSolver)::ConstrainSet\n\n\n\n\n\n","category":"type"},{"location":"solver_interface.html#TrajectoryOptimization.update_constraints!","page":"Solver Interface","title":"TrajectoryOptimization.update_constraints!","text":"update_constraints!(solver)\nupdate_constraints!(solver, Z)\n\n\nCalculate all the constraint values given the trajectory Z\n\n\n\n\n\n","category":"function"},{"location":"solver_interface.html#TrajectoryOptimization.update_active_set!","page":"Solver Interface","title":"TrajectoryOptimization.update_active_set!","text":"update_active_set!(conSet::ConstraintSet, Z::Traj, ::Val{tol})\n\nCompute the active set for the current constraint values, with tolerance tol. \tUses a value type to avoid an allocation down the line.\n\n\n\n\n\n","category":"function"},{"location":"solver_interface.html#TrajectoryOptimization.constraint_jacobian!","page":"Solver Interface","title":"TrajectoryOptimization.constraint_jacobian!","text":"constraint_jacobian!(solver)\nconstraint_jacobian!(solver, Z)\n\n\nCalculate all the constraint Jacobians given the trajectory Z\n\n\n\n\n\n","category":"function"},{"location":"solver_interface.html#Direct-Solvers-2","page":"Solver Interface","title":"Direct Solvers","text":"","category":"section"},{"location":"solver_interface.html#","page":"Solver Interface","title":"Solver Interface","text":"Direct solvers often perform similar operations, so the following methods are provided that should work with any direct solver","category":"page"},{"location":"solver_interface.html#","page":"Solver Interface","title":"Solver Interface","text":"DirectSolver\nremove_bounds!\nremove_constraint_type!\nget_bounds\nadd_dynamics_constraints!\ngen_con_inds\nconstraint_jacobian_structure\ncopy_constraints!\ncopy_active_set!\ncopy_jacobian!\ncopy_jacobians!","category":"page"},{"location":"solver_interface.html#TrajectoryOptimization.DirectSolver","page":"Solver Interface","title":"TrajectoryOptimization.DirectSolver","text":"abstract type DirectSolver <: ConstrainedSolver{T}\n\nSolve the trajectory optimization problem by computing search directions using the joint state vector, often solving the KKT system directly.\n\n\n\n\n\n","category":"type"},{"location":"solver_interface.html#TrajectoryOptimization.remove_bounds!","page":"Solver Interface","title":"TrajectoryOptimization.remove_bounds!","text":"remove_bounds!(conSet)\n\n\nRemove bounds constraints from constraint set\n\n\n\n\n\n","category":"function"},{"location":"solver_interface.html#TrajectoryOptimization.remove_constraint_type!","page":"Solver Interface","title":"TrajectoryOptimization.remove_constraint_type!","text":"remove_constraint_type!(conSet, ?)\n\n\nRemove a type of constraint from constraint set\n\n\n\n\n\n","category":"function"},{"location":"solver_interface.html#TrajectoryOptimization.get_bounds","page":"Solver Interface","title":"TrajectoryOptimization.get_bounds","text":"get_bounds(conSet)\n\n\nRemove bounds from constraint set and return them as vectors\n\n\n\n\n\n","category":"function"},{"location":"solver_interface.html#TrajectoryOptimization.add_dynamics_constraints!","page":"Solver Interface","title":"TrajectoryOptimization.add_dynamics_constraints!","text":"add_dynamics_constraints!(prob::Problem)\n\nAdd dynamics constraints to the constraint set\n\n\n\n\n\n","category":"function"},{"location":"solver_interface.html#TrajectoryOptimization.gen_con_inds","page":"Solver Interface","title":"TrajectoryOptimization.gen_con_inds","text":"gen_con_inds(conSet)\ngen_con_inds(conSet, structure)\n\n\nGenerate the indices into the concatenated constraint vector for each constraint. Determines the bandedness of the Jacobian\n\n\n\n\n\n","category":"function"},{"location":"solver_interface.html#TrajectoryOptimization.constraint_jacobian_structure","page":"Solver Interface","title":"TrajectoryOptimization.constraint_jacobian_structure","text":"constraint_jacobian_structure(solver)\nconstraint_jacobian_structure(solver, structure)\n\n\nGet the constraint Jacobian structure as a sparse array, and fill in the linear indices used for filling a vector of the non-zero elements of the Jacobian\n\n\n\n\n\n","category":"function"},{"location":"solver_interface.html#TrajectoryOptimization.copy_constraints!","page":"Solver Interface","title":"TrajectoryOptimization.copy_constraints!","text":"Copy constraints to a single concatenated vector\n\n\n\n\n\n","category":"function"},{"location":"solver_interface.html#TrajectoryOptimization.copy_active_set!","page":"Solver Interface","title":"TrajectoryOptimization.copy_active_set!","text":"Copy active set to a single concatenated vector\n\n\n\n\n\n","category":"function"},{"location":"solver_interface.html#TrajectoryOptimization.copy_jacobian!","page":"Solver Interface","title":"TrajectoryOptimization.copy_jacobian!","text":"Copy constraint Jacobians to given indices in a sparse array Dispatches on bandedness of the constraint\n\n\n\n\n\nCopy constraint Jacobians to linear indices of a vector\n\n\n\n\n\n","category":"function"},{"location":"solver_interface.html#TrajectoryOptimization.copy_jacobians!","page":"Solver Interface","title":"TrajectoryOptimization.copy_jacobians!","text":"Copy all constraint Jacobians to a sparse matrix\n\n\n\n\n\nCopy all constraint Jacobians to linear indices of a vector\n\n\n\n\n\n","category":"function"},{"location":"solver_interface.html#","page":"Solver Interface","title":"Solver Interface","text":"The solver must also contain the following fields:","category":"page"},{"location":"solver_interface.html#","page":"Solver Interface","title":"Solver Interface","text":"opts: Solver options for the solver (e.g. opts::NewSolverOptions)\nstats::Dict{Symbol,Any}: Dictionary containing pertinent statistics for the solve, such as run time, final max constraint violation, final cost, optimality criteria, number of iterations, etc.","category":"page"},{"location":"solvers.html#Solvers-1","page":"Solvers","title":"Solvers","text":"","category":"section"},{"location":"solvers.html#","page":"Solvers","title":"Solvers","text":"CurrentModule = TrajectoryOptimization","category":"page"},{"location":"solvers.html#","page":"Solvers","title":"Solvers","text":"Pages = [\"solvers.md\"]","category":"page"},{"location":"solvers.html#Iterative-LQR-(iLQR)-1","page":"Solvers","title":"Iterative LQR (iLQR)","text":"","category":"section"},{"location":"solvers.html#","page":"Solvers","title":"Solvers","text":"iLQRSolver\niLQRSolverOptions","category":"page"},{"location":"solvers.html#TrajectoryOptimization.iLQRSolverOptions","page":"Solvers","title":"TrajectoryOptimization.iLQRSolverOptions","text":"mutable struct iLQRSolverOptions{T} <: TrajectoryOptimization.AbstractSolverOptions{T}\n\nSolver options for the iterative LQR (iLQR) solver.\n\nverbose\nPrint summary at each iteration. Default: false\nlive_plotting\nLive plotting. Default: :off\ncost_tolerance\ndJ < ϵ, cost convergence criteria for unconstrained solve or to enter outerloop for constrained solve. Default: 0.0001\ngradient_type\ngradient type: :todorov, :feedforward. Default: :todorov\ngradient_norm_tolerance\ngradient_norm < ϵ, gradient norm convergence criteria. Default: 1.0e-5\niterations\niLQR iterations. Default: 300\ndJ_counter_limit\nrestricts the total number of times a forward pass fails, resulting in regularization, before exiting. Default: 10\nsquare_root\nuse square root method backward pass for numerical conditioning. Default: false\nline_search_lower_bound\nforward pass approximate line search lower bound, 0 < linesearchlowerbound < linesearchupperbound. Default: 1.0e-8\nline_search_upper_bound\nforward pass approximate line search upper bound, 0 < linesearchlowerbound < linesearchupperbound < ∞. Default: 10.0\niterations_linesearch\nmaximum number of backtracking steps during forward pass line search. Default: 20\nbp_reg_initial\ninitial regularization. Default: 0.0\nbp_reg_increase_factor\nregularization scaling factor. Default: 1.6\nbp_reg_max\nmaximum regularization value. Default: 1.0e8\nbp_reg_min\nminimum regularization value. Default: 1.0e-8\nbp_reg_type\ntype of regularization- control: () + ρI, state: (S + ρI); see Synthesis and Stabilization of Complex Behaviors through Online Trajectory Optimization. Default: :control\nbp_reg_fp\nadditive regularization when forward pass reaches max iterations. Default: 10.0\nbp_sqrt_inv_type\ntype of matrix inversion for bp sqrt step. Default: :pseudo\nbp_reg_sqrt_initial\ninitial regularization for square root method. Default: 1.0e-6\nbp_reg_sqrt_increase_factor\nregularization scaling factor for square root method. Default: 10.0\nbp_reg\nDefault: false\nmax_cost_value\nmaximum cost value, if exceded solve will error. Default: 1.0e8\nmax_state_value\nmaximum state value, evaluated during rollout, if exceded solve will error. Default: 1.0e8\nmax_control_value\nmaximum control value, evaluated during rollout, if exceded solve will error. Default: 1.0e8\nstatic_bp\nDefault: true\nlog_level\nDefault: InnerLoop\n\n\n\n\n\n","category":"type"},{"location":"solvers.html#Augmented-Lagrangian-Solver-1","page":"Solvers","title":"Augmented Lagrangian Solver","text":"","category":"section"},{"location":"solvers.html#","page":"Solvers","title":"Solvers","text":"AugmentedLagrangianSolver\nAugmentedLagrangianSolverOptions","category":"page"},{"location":"solvers.html#TrajectoryOptimization.AugmentedLagrangianSolver","page":"Solvers","title":"TrajectoryOptimization.AugmentedLagrangianSolver","text":"struct AugmentedLagrangianSolver <: TrajectoryOptimization.AbstractSolver{T}\n\nAugmented Lagrangian (AL) is a standard tool for constrained optimization. For a trajectory optimization problem of the form:\n\nbeginaligned\n  min_x_0Nu_0N-1 quad  ell_f(x_N) + sum_k=0^N-1 ell_k(x_k u_k dt) \n  textrmst            quad  x_k+1 = f(x_k u_k) \n                                  g_k(x_ku_k) leq 0 \n                                  h_k(x_ku_k) = 0\nendaligned\n\nAL methods form the following augmented Lagrangian function:\n\nbeginaligned\n    ell_f(x_N) + λ_N^T c_N(x_N) + c_N(x_N)^T I_mu_N c_N(x_N) \n            + sum_k=0^N-1 ell_k(x_ku_kdt) + λ_k^T c_k(x_ku_k) + c_k(x_ku_k)^T I_mu_k c_k(x_ku_k)\nendaligned\n\nThis function is then minimized with respect to the primal variables using any unconstrained minimization solver (e.g. iLQR).     After a local minima is found, the AL method updates the Lagrange multipliers λ and the penalty terms μ and repeats the unconstrained minimization.     AL methods have superlinear convergence as long as the penalty term μ is updated each iteration.\n\n\n\n\n\n","category":"type"},{"location":"solvers.html#TrajectoryOptimization.AugmentedLagrangianSolverOptions","page":"Solvers","title":"TrajectoryOptimization.AugmentedLagrangianSolverOptions","text":"mutable struct AugmentedLagrangianSolverOptions{T} <: TrajectoryOptimization.AbstractSolverOptions{T}\n\nSolver options for the augmented Lagrangian solver.\n\nverbose\nPrint summary at each iteration. Default: false\nopts_uncon\nunconstrained solver options. Default: UnconstrainedSolverOptions{Float64}()\ncost_tolerance\ndJ < ϵ, cost convergence criteria for unconstrained solve or to enter outerloop for constrained solve. Default: 0.0001\ncost_tolerance_intermediate\ndJ < ϵ_int, intermediate cost convergence criteria to enter outerloop of constrained solve. Default: 0.001\ngradient_norm_tolerance\ngradient_norm < ϵ, gradient norm convergence criteria. Default: 1.0e-5\ngradient_norm_tolerance_intermediate\ngradientnormint < ϵ, gradient norm intermediate convergence criteria. Default: 1.0e-5\nconstraint_tolerance\nmax(constraint) < ϵ, constraint convergence criteria. Default: 0.001\nconstraint_tolerance_intermediate\nmax(constraint) < ϵ_int, intermediate constraint convergence criteria. Default: 0.001\niterations\nmaximum outerloop updates. Default: 30\ndual_max\nglobal maximum Lagrange multiplier. If NaN, use value from constraint Default: NaN\npenalty_max\nglobal maximum penalty term. If NaN, use value from constraint Default: NaN\npenalty_initial\nglobal initial penalty term. If NaN, use value from constraint Default: NaN\npenalty_scaling\nglobal penalty update multiplier; penalty_scaling > 1. If NaN, use value from constraint Default: NaN\npenalty_scaling_no\npenalty update multiplier when μ should not be update, typically 1.0 (or 1.0 + ϵ). Default: 1.0\nconstraint_decrease_ratio\nratio of current constraint to previous constraint violation; 0 < constraintdecreaseratio < 1. Default: 0.25\nouter_loop_update_type\ntype of outer loop update (default, feedback). Default: :default\nactive_constraint_tolerance\nnumerical tolerance for constraint violation. Default: 0.0\nkickout_max_penalty\nterminal solve when maximum penalty is reached. Default: false\nreset_duals\nDefault: true\nreset_penalties\nDefault: true\nlog_level\nDefault: OuterLoop\n\n\n\n\n\n","category":"type"},{"location":"solvers.html#ALTRO-1","page":"Solvers","title":"ALTRO","text":"","category":"section"},{"location":"solvers.html#","page":"Solvers","title":"Solvers","text":"ALTROSolver\nALTROSolverOptions","category":"page"},{"location":"solvers.html#TrajectoryOptimization.ALTROSolver","page":"Solvers","title":"TrajectoryOptimization.ALTROSolver","text":"struct ALTROSolver{T, S} <: ConstrainedSolver{T}\n\nAugmented Lagrangian Trajectory Optimizer (ALTRO) is a solver developed by the Robotic Exploration Lab at Stanford University.     The solver is special-cased to solve Markov Decision Processes by leveraging the internal problem structure.\n\nALTRO consists of two \"phases\":\n\nAL-iLQR: iLQR is used with an Augmented Lagrangian framework to solve the problem quickly to rough constraint satisfaction\nProjected Newton: A collocation-flavored active-set solver projects the solution from AL-iLQR onto the feasible subspace to achieve machine-precision constraint satisfaction.\n\n\n\n\n\n","category":"type"},{"location":"solvers.html#TrajectoryOptimization.ALTROSolverOptions","page":"Solvers","title":"TrajectoryOptimization.ALTROSolverOptions","text":"mutable struct ALTROSolverOptions{T} <: TrajectoryOptimization.AbstractSolverOptions{T}\n\nSolver options for the ALTRO solver.\n\nverbose\nDefault: false\nopts_al\nAugmented Lagrangian solver options. Default: AugmentedLagrangianSolverOptions{Float64}()\nconstraint_tolerance\nconstraint tolerance Default: 1.0e-5\ninfeasible\nUse infeasible model (augment controls to make it fully actuated) Default: false\ndynamically_feasible_projection\nproject infeasible results to feasible space using TVLQR. Default: true\nresolve_feasible_problem\nresolve feasible problem after infeasible solve. Default: true\npenalty_initial_infeasible\ninitial penalty term for infeasible controls. Default: 1.0\npenalty_scaling_infeasible\npenalty update rate for infeasible controls. Default: 10.0\nprojected_newton\nfinish with a projecte newton solve. Default: true\nopts_pn\noptions for projected newton solver. Default: ProjectedNewtonSolverOptions{Float64}()\nprojected_newton_tolerance\nconstraint satisfaction tolerance that triggers the projected newton solver.     If set to a non-positive number it will kick out when the maximum penalty is reached. Default: 0.001\n\n\n\n\n\n","category":"type"},{"location":"solvers.html#Direct-Collocation-(DIRCOL)-1","page":"Solvers","title":"Direct Collocation (DIRCOL)","text":"","category":"section"},{"location":"solvers.html#","page":"Solvers","title":"Solvers","text":"DIRCOLSolver\nDIRCOLSolverOptions","category":"page"},{"location":"solvers.html#TrajectoryOptimization.DIRCOLSolver","page":"Solvers","title":"TrajectoryOptimization.DIRCOLSolver","text":"struct DIRCOLSolver{Q<:QuadratureRule, L, T, N, M, NM} <: DirectSolver{T}\n\nDirect Collocation Solver. Uses a commerical NLP solver to solve the Trajectory Optimization problem. Uses the MathOptInterface to interface with the NLP.\n\n\n\n\n\n","category":"type"},{"location":"solvers.html#TrajectoryOptimization.DIRCOLSolverOptions","page":"Solvers","title":"TrajectoryOptimization.DIRCOLSolverOptions","text":"mutable struct DIRCOLSolverOptions{T} <: TrajectoryOptimization.DirectSolverOptions{T}\n\nSolver options for the Direct Collocation solver. Most options are passed to the NLP through the opts dictionary\n\nnlp\nNLP Solver to use. See MathOptInterface for available NLP solvers Default: Ipopt.Optimizer()\nopts\nOptions dictionary for the nlp solver Default: Dict{Symbol, Any}()\nverbose\nPrint output to console Default: true\nconstraint_tolerance\nFeasibility tolerance Default: -1.0\n\n\n\n\n\n","category":"type"},{"location":"solvers.html#Projected-Newton-1","page":"Solvers","title":"Projected Newton","text":"","category":"section"},{"location":"solvers.html#","page":"Solvers","title":"Solvers","text":"ProjectedNewtonSolver\nProjectedNewtonSolverOptions","category":"page"},{"location":"solvers.html#TrajectoryOptimization.ProjectedNewtonSolver","page":"Solvers","title":"TrajectoryOptimization.ProjectedNewtonSolver","text":"struct ProjectedNewtonSolver{T, N, M, NM} <: DirectSolver{T}\n\nProjected Newton Solver Direct method developed by the REx Lab at Stanford University Achieves machine-level constraint satisfaction by projecting onto the feasible subspace.     It can also take a full Newton step by solving the KKT system. This solver is to be used exlusively for solutions that are close to the optimal solution.     It is intended to be used as a \"solution polishing\" method for augmented Lagrangian methods.\n\n\n\n\n\n","category":"type"},{"location":"solvers.html#TrajectoryOptimization.ProjectedNewtonSolverOptions","page":"Solvers","title":"TrajectoryOptimization.ProjectedNewtonSolverOptions","text":"mutable struct ProjectedNewtonSolverOptions{T} <: TrajectoryOptimization.DirectSolverOptions{T}\n\nSolver options for the Projected Newton solver.\n\nverbose\nDefault: true\nn_steps\nDefault: 2\nsolve_type\nDefault: :feasible\nactive_set_tolerance\nDefault: 0.001\nconstraint_tolerance\nDefault: 1.0e-6\nρ\nDefault: 0.01\nr_threshold\nDefault: 1.1\n\n\n\n\n\n","category":"type"},{"location":"change_dimension.html#","page":"Changing Problem Dimension","title":"Changing Problem Dimension","text":"CurrentModule = TrajectoryOptimization","category":"page"},{"location":"change_dimension.html#Changing-Problem-Dimension-1","page":"Changing Problem Dimension","title":"Changing Problem Dimension","text":"","category":"section"},{"location":"change_dimension.html#","page":"Changing Problem Dimension","title":"Changing Problem Dimension","text":"It is common practice to augment the states or controls with additional terms in order to help solve the problem. This page describes experimental methods built into TrajectoryOptimization.jl that make this process easier and hopefully natural.","category":"page"},{"location":"change_dimension.html#","page":"Changing Problem Dimension","title":"Changing Problem Dimension","text":"For example, let's say we have trajectory optimization problem for the canonical cartpole, similar to the one described in Creating a Problem. Now, for some reason, we want to augment the state and control dimension by 1, each, so that the new state and control dimensions are 5 and 2, respectively. We'd like to keep the cost function and constraints we've already defined, and simply add on a few","category":"page"},{"location":"change_dimension.html#Cost-Function-1","page":"Changing Problem Dimension","title":"Cost Function","text":"","category":"section"},{"location":"change_dimension.html#","page":"Changing Problem Dimension","title":"Changing Problem Dimension","text":"Let's say we have model with state and control dimension of 4 and 1, respectively. Suppose now we augment our state and control dimensions to 6 and 3, for some reason. We likely already have a cost function defined for our original problem. We'd like to augment this cost function with the costs on the new s","category":"page"},{"location":"constraints.html#constraint_section-1","page":"3. Creating Constraints","title":"3. Creating Constraints","text":"","category":"section"},{"location":"constraints.html#","page":"3. Creating Constraints","title":"3. Creating Constraints","text":"CurrentModule = TrajectoryOptimization","category":"page"},{"location":"constraints.html#","page":"3. Creating Constraints","title":"3. Creating Constraints","text":"Pages = [\"constraints.md\"]","category":"page"},{"location":"constraints.html#Creating-Constraint-Sets-1","page":"3. Creating Constraints","title":"Creating Constraint Sets","text":"","category":"section"},{"location":"constraints.html#","page":"3. Creating Constraints","title":"3. Creating Constraints","text":"The easiest way to set up the constraints for your problem is through the ConstraintSet. This structure simply holds a vector of all the constraints in the trajectory optimization problem. The easiest way to start is to create an empty ConstraintSet:","category":"page"},{"location":"constraints.html#","page":"3. Creating Constraints","title":"3. Creating Constraints","text":"conSet = ConstraintSet(n,m,N)","category":"page"},{"location":"constraints.html#Adding-Constraints-1","page":"3. Creating Constraints","title":"Adding Constraints","text":"","category":"section"},{"location":"constraints.html#","page":"3. Creating Constraints","title":"3. Creating Constraints","text":"You can add any constraint (the list of currently implemented constraints is given in the following section) to the constraint set using the following method:","category":"page"},{"location":"constraints.html#","page":"3. Creating Constraints","title":"3. Creating Constraints","text":"add_constraint!","category":"page"},{"location":"constraints.html#TrajectoryOptimization.add_constraint!","page":"3. Creating Constraints","title":"TrajectoryOptimization.add_constraint!","text":"add_constraint!(conSet, conVal::ConstraintVals, idx=-1)\nadd_constraint!(conSet, con::AbstractConstraint, inds::UnitRange, idx=-1)\n\nAdd a constraint to the constraint set. You can directly add a ConstraintVals type, but when adding a normal AbstractConstraint you must specify the range of knotpoints to which the constraint applies.\n\nThe optional idx argument allows you to specify exactly where in the vector of constraints you'd like the constraint to be added. The ordering will effect the order in which the constraint appears in concatenated vectors of constraint values (that show up in direct methods), potentially effecting the band structure of the resultant Jacobian. See solvers for more details.\n\n\n\n\n\n","category":"function"},{"location":"constraints.html#Defined-Constraints-1","page":"3. Creating Constraints","title":"Defined Constraints","text":"","category":"section"},{"location":"constraints.html#","page":"3. Creating Constraints","title":"3. Creating Constraints","text":"The following constraints are currently defined. See thier individual docstrings on details on how to construct them, since constraint constructors are, in general, unique to the constraint.","category":"page"},{"location":"constraints.html#","page":"3. Creating Constraints","title":"3. Creating Constraints","text":"GoalConstraint\nBoundConstraint\nCircleConstraint\nSphereConstraint\nNormConstraint\nIndexedConstraint","category":"page"},{"location":"creating_problems.html#","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"CurrentModule = TrajectoryOptimization","category":"page"},{"location":"creating_problems.html#problem_section-1","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"","category":"section"},{"location":"creating_problems.html#","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"The Problem contains all of the information needed to solve a trajectory optimization problem. At a minimum, this is the model, objective, and initial condition. A Problem is passed to a solver, which extracts needed information, and may or may or not modify its internal representation of the problem in order to solve it (e.g. the Augmented Lagrangian solver combines the constraints and objective into a single Augmented Lagrangian objective.)","category":"page"},{"location":"creating_problems.html#Creating-a-Problem-1","page":"4. Setting up a Problem","title":"Creating a Problem","text":"","category":"section"},{"location":"creating_problems.html#","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"Let's say we're trying to solve the following trajectory optimization problem:","category":"page"},{"location":"creating_problems.html#","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"beginaligned\n  min_x_0Nu_0N-1 quad  (x_N-x_f)^T Q_f (x_N-x_f) + dt sum_k=0^N-1 (x_k-x_f)^T Q (x_k - x_f) + u^T R u  \n  textrmst            quad  x_k+1 = f(x_k u_k) \n                                  u_k leq 3 \n                                  x_N = x_f \nendaligned","category":"page"},{"location":"creating_problems.html#","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"We'll quickly set up the dynamics, objective, and constraints. See previous sections for more details on how to do this.","category":"page"},{"location":"creating_problems.html#","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"# Dynamics and Constants\nmodel = Dynamics.Cartpole()\nn,m = size(model)\nN = 101   # number of knot points\ntf = 5.0  # final time\nx0 = @SVector[0.0, 0.0]  # initial state\nxf = @SVector [0, π]     # goal state (i.e. swing up)\n\n# Objective\nQ = Diagonal(@SVector fill(1e-2,n))\nR = Diagonal(@SVector fill(1e-1,m))\nQf = Diagonal(@SVector fill(100,n))\nobj = LQRObjective(Q, R, Qf, xf, N)\n\n# Constraints\nconSet = ConstraintSet(n,m,N)\nbnd = BoundConstraint(n,m, u_min=-3.0, u_max=3.0)\ngoal = GoalConstraint(xf)\nadd_constraint!(conSet, bnd, 1:N-1)\nadd_constraint!(conSet, goal, N:N)","category":"page"},{"location":"creating_problems.html#","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"The following method is the easiest way to set up a trajectory optimization problem:","category":"page"},{"location":"creating_problems.html#","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"prob = Problem(model, obj, xf, tf, constraints=conSet, x0=x0, integration=RK3)","category":"page"},{"location":"creating_problems.html#","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"where the keyword arguments are, of course, optional.","category":"page"},{"location":"creating_problems.html#","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"This constructor has the following arguments:","category":"page"},{"location":"creating_problems.html#","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"(required) model::AbstractModel - dynamics model\n(required) obj::AbstractObjective - objective function\n(required) xf::AbstractVector - goal state (this will be made optional in the near future)\n(required) tf::AbstractFloat - final time\n(optional) constraints::ConstraintSet - constraint set. Default is no constraints.\n(optional) x0::AbstractVector - Initial state. Default is the zero vector.\n(optional) N::Int - number of knot points. Default is given by length of objective.\n(optional) dt::AbstractFloat - Time step length. Can be either a scalar or a vector of length N. Default is calculated using tf and N.\n(optional) integration::Type{<:QuadratureRule} - Quadrature rule for discretizing the dynamics. Default is given by TrajectoryOptimization.DEFAULT_Q.\n(optional) X0 - Initial guess for state trajectory. Can either be a matrix of size (n,N) or a vector of length N of n-dimensional vectors.\n(optional) U0 - Initial guess for control trajectory. Can either be a matrix of size (m,N) or a vector of length N-1 of n-dimensional vectors.","category":"page"},{"location":"creating_problems.html#Initialization-1","page":"4. Setting up a Problem","title":"Initialization","text":"","category":"section"},{"location":"creating_problems.html#","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"A good initialization is critical to getting good results for nonlinear optimization problems. TrajectoryOptimization.jl current supports initialization of the state and control trajectories. Initialization of dual variables (i.e. Lagrange multipliers) is not yet support but will be included in the near future. The state and control trajectories can be initialized directly in the constructor using the X0 and U0 keyword arguments described above, or using the following methods:","category":"page"},{"location":"creating_problems.html#","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"initial_states!(prob, X0)\ninitial_controls!(prob, U0)","category":"page"},{"location":"creating_problems.html#","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"where, again, these can either be matrices or vectors of vectors of the appropriate size. It should be noted that these methods work on either Problems or instances of AbstractSolver.","category":"page"},{"location":"creating_problems.html#","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"Alternatively, the problem can be initialized with both the state and control trajectories simultaneously by passing in a vector of KnotPoints, described in the next sections.","category":"page"},{"location":"creating_problems.html#KnotPoint-Type-1","page":"4. Setting up a Problem","title":"KnotPoint Type","text":"","category":"section"},{"location":"creating_problems.html#","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"Internally, TrajectoryOptimization.jl stores the state and controls at each time step as a concatenated vector inside of a custom KnotPoint type. In addition to storing the state and control, the KnotPoint type also stores the time and time step length for the current knot point.  ","category":"page"},{"location":"creating_problems.html#","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"KnotPoint","category":"page"},{"location":"creating_problems.html#TrajectoryOptimization.KnotPoint","page":"4. Setting up a Problem","title":"TrajectoryOptimization.KnotPoint","text":"mutable struct KnotPoint{T, N, M, NM} <: TrajectoryOptimization.AbstractKnotPoint{T,N,M,NM}\n\nStores critical information corresponding to each knot point in the trajectory optimization problem, including the state and control values, as well as the time and time step length.\n\nGetters\n\nUse the following methods to access values from a KnotPoint:\n\nx  = state(z::KnotPoint)    # returns the n-dimensional state as a SVector\nu  = control(z::KnotPoint)  # returns the m-dimensional control vector as a SVector\nt  = z.t                    # current time\ndt = z.dt                   # time step length\n\nSetters\n\nUse the following methods to set values in a KnotPoint:\n\nset_state!(z::KnotPoint, x)\nset_control!(z::KnotPoint, u)\nz.t = t\nz.dt = dt\n\nConstructors\n\nKnotPoint(x, u, dt, t=0.0)\nKnotPoint(x, m, t=0.0)  # for terminal knot point\n\nUse is_terminal(z::KnotPoint) to determine if a KnotPoint is a terminal knot point (e.g. has no time step length and z.t == tf).\n\n\n\n\n\n","category":"type"},{"location":"creating_problems.html#Traj-Type-1","page":"4. Setting up a Problem","title":"Traj Type","text":"","category":"section"},{"location":"creating_problems.html#","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"The Traj type is simply a vector of KnotPoints. However, it provides a few helpful methods for constructing and working vectors of KnotPoints, which effectively describe a discrete-time state-control trajectory.","category":"page"},{"location":"creating_problems.html#Constructors-1","page":"4. Setting up a Problem","title":"Constructors","text":"","category":"section"},{"location":"creating_problems.html#","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"Initialize a trajectory with NaN states and zeroed controls:","category":"page"},{"location":"creating_problems.html#","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"Traj(n, m, dt, N)","category":"page"},{"location":"creating_problems.html#","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"Copy a single state-control pair across N knot points:","category":"page"},{"location":"creating_problems.html#","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"Traj(x::SVector, u::SVector, dt, N)","category":"page"},{"location":"creating_problems.html#","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"Create a trajectory from individual state, control, and time step trajectories:","category":"page"},{"location":"creating_problems.html#","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"Traj(X::Vector{<:AbstractVector}, U::Vector{<:AbstractVector}, dt::Vector)","category":"page"},{"location":"creating_problems.html#Other-Methods-1","page":"4. Setting up a Problem","title":"Other Methods","text":"","category":"section"},{"location":"creating_problems.html#","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"You can extract the state and control trajectories separately with the following methods:","category":"page"},{"location":"creating_problems.html#","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"states(Z::Traj)\ncontrols(Z::Traj)","category":"page"},{"location":"creating_problems.html#","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"Note that these methods also work on Problem and AbstractSolver types.","category":"page"},{"location":"creating_problems.html#","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"The states, control, and time trajectories can be set independently with the following methods:","category":"page"},{"location":"creating_problems.html#","page":"4. Setting up a Problem","title":"4. Setting up a Problem","text":"set_states!(Z::Traj, X::Vector{<:AbstractVector})\nset_controls!(Z::Traj, U::Vector{<:AbstractVector})\nset_times!(Z::Traj, t::Vector)","category":"page"},{"location":"problem.html#","page":"Problem","title":"Problem","text":"CurrentModule = TrajectoryOptimization","category":"page"},{"location":"problem.html#Problem-1","page":"Problem","title":"Problem","text":"","category":"section"},{"location":"problem.html#","page":"Problem","title":"Problem","text":"Pages = [\"problem.md\"]","category":"page"},{"location":"problem.html#Definition-1","page":"Problem","title":"Definition","text":"","category":"section"},{"location":"problem.html#","page":"Problem","title":"Problem","text":"Problem","category":"page"},{"location":"problem.html#TrajectoryOptimization.Problem","page":"Problem","title":"TrajectoryOptimization.Problem","text":"struct Problem{Q<:QuadratureRule, T<:AbstractFloat}\n\nTrajectory Optimization Problem. Contains the full definition of a trajectory optimization problem, including:\n\ndynamics model (Model)\nobjective (Objective)\nconstraints (ConstraintSet)\ninitial and final states\nPrimal variables (state and control trajectories)\nDiscretization information: knot points (N), time step (dt), and total time (tf)\n\nConstructors:\n\nProblem(model, obj, constraints, x0, xf, Z, N, tf) # defaults to RK3 integration\nProblem{Q}(model, obj, constraints, x0, xf, Z, N, tf) where Q<:QuadratureRule\nProblem(model, obj, xf, tf; x0, constraints, N, X0, U0, dt, integration)\nProblem{Q}(prob::Problem)  # change integration\n\nwhere Z is a trajectory (Vector of KnotPoints)\n\nArguments\n\nmodel: Dynamics model. Can be either Discrete or Continuous\nobj: Objective\nX0: Initial state trajectory. If omitted it will be initialized with NaNs, to be later overwritten by the solver.\nU0: Initial control trajectory. If omitted it will be initialized with zeros.\nx0: Initial state. Defaults to zeros.\nxf: Final state. Defaults to zeros.\ndt: Time step\ntf: Final time. Set to zero to specify a time penalized problem.\nN: Number of knot points. Defaults to 51, unless specified by dt and tf.\nintegration: One of the defined integration types to discretize the continuous dynamics model.\n\nBoth X0 and U0 can be either a Matrix or a Vector{Vector}, but must be the same. At least 2 of dt, tf, and N need to be specified (or just 1 of dt and tf).\n\n\n\n\n\n","category":"type"},{"location":"problem.html#Methods-1","page":"Problem","title":"Methods","text":"","category":"section"},{"location":"problem.html#","page":"Problem","title":"Problem","text":"change_integration\ninitial_controls!(::Problem, X0::Vector{<:AbstractVector})\ninitial_states!(::Problem, U0::Vector{<:AbstractVector})\nBase.size(::Problem)\nBase.copy(::Problem)\nintegration(::Problem)\nstates(::Problem)\ncontrols(::Problem)","category":"page"},{"location":"problem.html#TrajectoryOptimization.change_integration","page":"Problem","title":"TrajectoryOptimization.change_integration","text":"change_integration(prob::Problem, Q<:QuadratureRule)\n\nChange dynamics integration for the problem\n\n\n\n\n\n","category":"function"},{"location":"problem.html#TrajectoryOptimization.initial_controls!-Tuple{Problem,Array{#s1,1} where #s1<:(AbstractArray{T,1} where T)}","page":"Problem","title":"TrajectoryOptimization.initial_controls!","text":"initial_controls!(::Union{Problem,AbstractSolver}, U0::Vector{<:AbstractVector})\ninitial_controls!(::Union{Problem,AbstractSolver}, U0::AbstractMatrx)\n\nCopy the control trajectory \n\n\n\n\n\n","category":"method"},{"location":"problem.html#TrajectoryOptimization.initial_states!-Tuple{Problem,Array{#s1,1} where #s1<:(AbstractArray{T,1} where T)}","page":"Problem","title":"TrajectoryOptimization.initial_states!","text":"initial_states!(::Union{Problem,AbstractSolver}, X0::Vector{<:AbstractVector})\ninitial_states!(::Union{Problem,AbstractSolver}, X0::AbstractMatrix)\n\nCopy the state trajectory \n\n\n\n\n\n","category":"method"},{"location":"problem.html#Base.size-Tuple{Problem}","page":"Problem","title":"Base.size","text":"size(prob::Problem) -> Tuple\n\n\nGet number of states, controls, and knot points\n\n\n\n\n\n","category":"method"},{"location":"problem.html#Base.copy-Tuple{Problem}","page":"Problem","title":"Base.copy","text":"Copy the problem\n\n\n\n\n\n","category":"method"},{"location":"problem.html#TrajectoryOptimization.integration-Tuple{Problem}","page":"Problem","title":"TrajectoryOptimization.integration","text":"integration(::Problem)\nintegration(::DynamicsConstraint)\n\nGet the integration rule\n\n\n\n\n\n","category":"method"},{"location":"problem.html#TrajectoryOptimization.states-Tuple{Problem}","page":"Problem","title":"TrajectoryOptimization.states","text":"states(::Problem)\nstates(::AbstractSolver)\nstates(::Traj)\n\nGet the state trajectory\n\n\n\n\n\n","category":"method"},{"location":"problem.html#TrajectoryOptimization.controls-Tuple{Problem}","page":"Problem","title":"TrajectoryOptimization.controls","text":"controls(::Problem)\ncontrols(::AbstractSolver)\ncontrols(::Traj)\n\nGet the control trajectory\n\n\n\n\n\n","category":"method"},{"location":"costfunction_interface.html#","page":"Cost Function Interface","title":"Cost Function Interface","text":"CurrentModule = TrajectoryOptimization","category":"page"},{"location":"costfunction_interface.html#Cost-Function-Interface-1","page":"Cost Function Interface","title":"Cost Function Interface","text":"","category":"section"},{"location":"costfunction_interface.html#","page":"Cost Function Interface","title":"Cost Function Interface","text":"All cost functions are required to define the following methods","category":"page"},{"location":"costfunction_interface.html#","page":"Cost Function Interface","title":"Cost Function Interface","text":"n = state_dim(cost)\nm = control_dim(cost)\nJ = stage_cost(cost, x, u)\nJ = stage_cost(cost, xN)\nQx,Qu = gradient(cost, x, u)\nQxx,Quu,Qux = hessian(cost, x, u)","category":"page"},{"location":"costfunction_interface.html#","page":"Cost Function Interface","title":"Cost Function Interface","text":"and inherit from CostFunction. They then inherit the following methods:","category":"page"},{"location":"costfunction_interface.html#","page":"Cost Function Interface","title":"Cost Function Interface","text":"stage_cost(::CostFunction, ::KnotPoint)\ncost_gradient(::CostFunction, ::KnotPoint)\ncost_hessian(::CostFunction, ::KnotPoint)","category":"page"},{"location":"costfunction_interface.html#TrajectoryOptimization.stage_cost-Tuple{CostFunction,KnotPoint}","page":"Cost Function Interface","title":"TrajectoryOptimization.stage_cost","text":"stage_cost(cost::CostFunction, z::KnotPoint) -> Any\n\n\nEvaluate the cost at a knot point, and automatically handle terminal knot point, multiplying by dt as necessary.\n\n\n\n\n\n","category":"method"},{"location":"costfunction_interface.html#Objective-Interface-1","page":"Cost Function Interface","title":"Objective Interface","text":"","category":"section"},{"location":"costfunction_interface.html#","page":"Cost Function Interface","title":"Cost Function Interface","text":"The objective interface is very simple. After inheriting from AbstractObjective, define the following methods:","category":"page"},{"location":"costfunction_interface.html#","page":"Cost Function Interface","title":"Cost Function Interface","text":"Base.length(::NewObjective)       # number of knot points\nget_J(::NewObjective)             # return vector of costs at each knot point\ncost!(::NewObjective, Z::Traj)    # calculate the cost at each knot point and store in get_J(::NewSolver)\ncost_expansion!(E::CostExpansion, obj::NewObjective, Z::Traj)","category":"page"},{"location":"costfunction_interface.html#","page":"Cost Function Interface","title":"Cost Function Interface","text":"And inherits the single method","category":"page"},{"location":"costfunction_interface.html#","page":"Cost Function Interface","title":"Cost Function Interface","text":"cost(::NewObjective, Z::Traj)","category":"page"},{"location":"costfunction_interface.html#","page":"Cost Function Interface","title":"Cost Function Interface","text":"that simply returns the summed cost.","category":"page"},{"location":"model_types.html#","page":"Model Types","title":"Model Types","text":"CurrentModule = TrajectoryOptimization","category":"page"},{"location":"model_types.html#Model-Types-1","page":"Model Types","title":"Model Types","text":"","category":"section"},{"location":"model_types.html#","page":"Model Types","title":"Model Types","text":"This page provides details on specific sub-types of AbstractModel that are curently implemented in TrajectoryOptimization.jl.","category":"page"},{"location":"model_types.html#Abstract-Model-1","page":"Model Types","title":"Abstract Model","text":"","category":"section"},{"location":"model_types.html#","page":"Model Types","title":"Model Types","text":"AbstractModel","category":"page"},{"location":"model_types.html#TrajectoryOptimization.AbstractModel","page":"Model Types","title":"TrajectoryOptimization.AbstractModel","text":"abstract type AbstractModel\n\nAbstraction of a model of a dynamical system of the form ẋ = f(x,u), where x is the n-dimensional state vector and u is the m-dimensional control vector.\n\nAny inherited type must define the following interface: ẋ = dynamics(model, x, u) n,m = size(model)\n\n\n\n\n\n","category":"type"},{"location":"model_types.html#Rigid-Body-Models-1","page":"Model Types","title":"Rigid Body Models","text":"","category":"section"},{"location":"model_types.html#","page":"Model Types","title":"Model Types","text":"RigidBody","category":"page"},{"location":"model_types.html#TrajectoryOptimization.RigidBody","page":"Model Types","title":"TrajectoryOptimization.RigidBody","text":"abstract type RigidBody <: AbstractModel\n\nAbstraction of a dynamical system with free-body dynamics, with a 12 or 13-dimensional state vector: [p; q; v; ω] where p is the 3D position, q is the 3 or 4-dimension attitude representation, v is the 3D linear velocity, and ω is the 3D angular velocity.\n\nInterface\n\nAny single-body system can leverage the RigidBody type by inheriting from it and defining the following interface:\n\nforces(::MyRigidBody, x, u)  # return the forces in the world frame\nmoments(::MyRigidBody, x, u) # return the moments in the body frame\ninertia(::MyRigidBody, x, u) # return the 3x3 inertia matrix\ninertia_inv(::MyRigidBody, x, u)  # return the 3x3 inverse of the inertia matrix\nmass_matrix(::MyRigidBody, x, u)  # return the 3x3 mass matrix\n\nRotation Parameterization\n\nA RigidBody model must specify the rotational representation being used. Any of the following can be used:\n\nUnitQuaternion: Unit Quaternion. Note that this representation needs to be further parameterized.\nMRP: Modified Rodrigues Parameters\nRPY: Roll-Pitch-Yaw Euler angles\n\n\n\n\n\n","category":"type"},{"location":"model_types.html#Infeasible-Models-1","page":"Model Types","title":"Infeasible Models","text":"","category":"section"},{"location":"model_types.html#","page":"Model Types","title":"Model Types","text":"InfeasibleModel","category":"page"},{"location":"model_types.html#TrajectoryOptimization.InfeasibleModel","page":"Model Types","title":"TrajectoryOptimization.InfeasibleModel","text":"struct InfeasibleModel{N, M, D<:AbstractModel} <: AbstractModel\n\nAn infeasible model is an augmented dynamics model that makes the system artifically fully actuated by augmenting the control vector with n additional controls. The dynamics are handled explicitly in discrete time:\n\nx_k+1 = f(x_ku_kdt) + w_k\n\nwhere w_k are the additional n-dimensional controls. In practice, these are constrained to be zero by the end of the solve.\n\nConstructors\n\nInfeasibleModel(model::AbstractModel)\n\n\n\n\n\n","category":"type"},{"location":"solving.html#","page":"5. Solving the Problem","title":"5. Solving the Problem","text":"CurrentModule = TrajectoryOptimization","category":"page"},{"location":"solving.html#solving_section-1","page":"5. Solving the Problem","title":"5. Solving the Problem","text":"","category":"section"},{"location":"solving.html#","page":"5. Solving the Problem","title":"5. Solving the Problem","text":"Solving a trajectory optimization is as simple as picking a solver and calling the solve! method. There are several solvers implemented in TrajectoryOptimization.jl, and each has its own limitations and solver options. See Solvers section for a list of the currently implemented solvers, their options, and their associated docstrings. See the Solver Interface section for more information on addition new solvers or leveraging the generic methods implemented by each solver.","category":"page"},{"location":"solving.html#Creating-a-Solver-1","page":"5. Solving the Problem","title":"Creating a Solver","text":"","category":"section"},{"location":"solving.html#","page":"5. Solving the Problem","title":"5. Solving the Problem","text":"Every solver is initialized with, at a minimum, a Problem and (optionally) the associated SolverOptions type. For example, let's say we want to solve our cartpole problem created in the previous section with AL-iLQR. Since iLQR is the default unconstrained solver for the Augmented Lagrangian solver, this is as easy as:","category":"page"},{"location":"solving.html#","page":"5. Solving the Problem","title":"5. Solving the Problem","text":"solver = AugmentedLagrangianSolver(prob)","category":"page"},{"location":"solving.html#Modifying-solver-options-1","page":"5. Solving the Problem","title":"Modifying solver options","text":"","category":"section"},{"location":"solving.html#","page":"5. Solving the Problem","title":"5. Solving the Problem","text":"We have a couple options for changing solver options. First, we can create the SolverOptions type, modify the desired fields, and then pass it into the constructor for the solver. For iLQR this looks like:","category":"page"},{"location":"solving.html#","page":"5. Solving the Problem","title":"5. Solving the Problem","text":"opts_ilqr = iLQRSolverOptions()                     # all fields default\nopts_ilqr = iLQRSolverOptions(cost_tolerance=1e-4)  # specify options by keyword\nopts_ilqr.iterations = 50                           # set fields manually\nsolver = iLQRSolver(prob, opts_ilqr)                # create the solver with the given options","category":"page"},{"location":"solving.html#","page":"5. Solving the Problem","title":"5. Solving the Problem","text":"Second, we can create the solver, and then modify it's options:","category":"page"},{"location":"solving.html#","page":"5. Solving the Problem","title":"5. Solving the Problem","text":"solver = iLQRSolver(prob)\nsolver.opts.iterations = 50","category":"page"},{"location":"solving.html#","page":"5. Solving the Problem","title":"5. Solving the Problem","text":"It should be noted that right now, the solver does NOT create a copy of the solver options when it's created. That is, changing opts_ilqr after creating the solver will change the options inside of solver, even after it's created, and vice versa.","category":"page"},{"location":"solving.html#Nested-Solver-Options-1","page":"5. Solving the Problem","title":"Nested Solver Options","text":"","category":"section"},{"location":"solving.html#","page":"5. Solving the Problem","title":"5. Solving the Problem","text":"Some solvers, such as AugmentedLagrangianSolver and ALTROSolver rely directly on other solvers. As such, their solver option types store the solver options of their dependent solvers explicitly:","category":"page"},{"location":"solving.html#","page":"5. Solving the Problem","title":"5. Solving the Problem","text":"opts_al = AugmentedLagrangianSolverOptions()\nopts_al.opts_uncon.iterations = 50  # set iLQR iterations\nopts_al.iterations = 20             # set outer loop iterations","category":"page"},{"location":"solving.html#Solving-the-Problem-1","page":"5. Solving the Problem","title":"Solving the Problem","text":"","category":"section"},{"location":"solving.html#","page":"5. Solving the Problem","title":"5. Solving the Problem","text":"Solving the problem is as simple as calling solve! on the solver:","category":"page"},{"location":"solving.html#","page":"5. Solving the Problem","title":"5. Solving the Problem","text":"solver = AugmentedLagrangianSolver(prob)\nsolve!(solver)","category":"page"},{"location":"solving.html#Analyzing-the-Solution-1","page":"5. Solving the Problem","title":"Analyzing the Solution","text":"","category":"section"},{"location":"solving.html#","page":"5. Solving the Problem","title":"5. Solving the Problem","text":"There a few different ways to analyze the solution after the solve, detailed in the following sections.","category":"page"},{"location":"solving.html#Getting-the-solution-1","page":"5. Solving the Problem","title":"Getting the solution","text":"","category":"section"},{"location":"solving.html#","page":"5. Solving the Problem","title":"5. Solving the Problem","text":"The state and control trajectories can be extracted using the following commands:","category":"page"},{"location":"solving.html#","page":"5. Solving the Problem","title":"5. Solving the Problem","text":"states(solver::AbstractSolver)\ncontrols(solver::AbstractSolver)","category":"page"},{"location":"solving.html#","page":"5. Solving the Problem","title":"5. Solving the Problem","text":"These can be converted to 2D arrays with simple horizontal concatenation: hcat(X...). Note that these methods work on Problem types as well.","category":"page"},{"location":"solving.html#Logging-1","page":"5. Solving the Problem","title":"Logging","text":"","category":"section"},{"location":"solving.html#","page":"5. Solving the Problem","title":"5. Solving the Problem","text":"All solvers support some type of output to stdout during the solve. This is controlled with the verbose solver option.","category":"page"},{"location":"solving.html#Statistics-1","page":"5. Solving the Problem","title":"Statistics","text":"","category":"section"},{"location":"solving.html#","page":"5. Solving the Problem","title":"5. Solving the Problem","text":"Each solver records a log of certain stats during the solve. They are located in solver.stats, and include things such as cost per iteration, constraint violation per iteration, cost decrease, etc.","category":"page"},{"location":"solving.html#Plotting-1","page":"5. Solving the Problem","title":"Plotting","text":"","category":"section"},{"location":"solving.html#","page":"5. Solving the Problem","title":"5. Solving the Problem","text":"TrajectoryOptimization.jl currently does not have any plotting recipes defined, although this is on the list of feature we are going to be adding.","category":"page"},{"location":"discretization.html#","page":"Discretization","title":"Discretization","text":"CurrentModule = TrajectoryOptimization","category":"page"},{"location":"discretization.html#Discretization-1","page":"Discretization","title":"Discretization","text":"","category":"section"},{"location":"discretization.html#","page":"Discretization","title":"Discretization","text":"This page gives details on the methods for evaluating discretized dynamics, as well as instructions on how to define a custom integration method.","category":"page"},{"location":"discretization.html#Model-Discretization-1","page":"Discretization","title":"Model Discretization","text":"","category":"section"},{"location":"discretization.html#","page":"Discretization","title":"Discretization","text":"With a model defined, we can compute the discrete dynamics and discrete dynamics Jacobians for an Implicit integration rule with the following methods","category":"page"},{"location":"discretization.html#","page":"Discretization","title":"Discretization","text":"discrete_dynamics\ndiscrete_jacobian","category":"page"},{"location":"discretization.html#TrajectoryOptimization.discrete_dynamics","page":"Discretization","title":"TrajectoryOptimization.discrete_dynamics","text":"Compute the discretized dynamics of model using implicit integration scheme Q<:QuadratureRule.\n\nMethods:\n\nx′ = discrete_dynamics(model, model, z)  # uses RK3 as the default integration scheme\nx′ = discrete_dynamics(Q, model, x, u, t, dt)\nx′ = discrete_dynamics(Q, model, z::KnotPoint)\n\nThe default integration scheme is stored in TrajectoryOptimization.DEFAULT_Q\n\n\n\n\n\n","category":"function"},{"location":"discretization.html#Integration-Schemes-1","page":"Discretization","title":"Integration Schemes","text":"","category":"section"},{"location":"discretization.html#","page":"Discretization","title":"Discretization","text":"TrajectoryOptimization.jl has already defined a handful of integration schemes for computing discrete dynamics. The integration schemes are specified as abstract types, so that methods can efficiently dispatch based on the integration scheme selected. Here is the current set of implemented types:","category":"page"},{"location":"discretization.html#","page":"Discretization","title":"Discretization","text":"QuadratureRule\nImplicit\nRK3\nExplicit\nHermiteSimpson","category":"page"},{"location":"discretization.html#","page":"Discretization","title":"Discretization","text":"QuadratureRule\nImplicit\nRK3\nExplicit\nHermiteSimpson","category":"page"},{"location":"discretization.html#TrajectoryOptimization.QuadratureRule","page":"Discretization","title":"TrajectoryOptimization.QuadratureRule","text":"Integration rule for approximating the continuous integrals for the equations of motion\n\n\n\n\n\n","category":"type"},{"location":"discretization.html#TrajectoryOptimization.Implicit","page":"Discretization","title":"TrajectoryOptimization.Implicit","text":"Integration rules of the form x′ = f(x,u), where x′ is the next state\n\n\n\n\n\n","category":"type"},{"location":"discretization.html#TrajectoryOptimization.RK3","page":"Discretization","title":"TrajectoryOptimization.RK3","text":"Second-order Runge-Kutta method with zero-order-old on the controls\n\n\n\n\n\n","category":"type"},{"location":"discretization.html#TrajectoryOptimization.Explicit","page":"Discretization","title":"TrajectoryOptimization.Explicit","text":"Integration rules of the form x′ = f(x,u,x′,u′), where x′,u′ are the states and controls at the next time step.\n\n\n\n\n\n","category":"type"},{"location":"discretization.html#TrajectoryOptimization.HermiteSimpson","page":"Discretization","title":"TrajectoryOptimization.HermiteSimpson","text":"Third-order Runge-Kutta method with first-order-hold on the controls\n\n\n\n\n\n","category":"type"},{"location":"discretization.html#Defining-a-New-Integration-Scheme-1","page":"Discretization","title":"Defining a New Integration Scheme","text":"","category":"section"},{"location":"discretization.html#Implicit-Methods-1","page":"Discretization","title":"Implicit Methods","text":"","category":"section"},{"location":"discretization.html#","page":"Discretization","title":"Discretization","text":"Implicit integration schemes are understandably simpler, since the output is not a function of itself, as is the case with explicit jschemes. As such, as a minimum, the user only needs to define the following method for a new rule MyQ:","category":"page"},{"location":"discretization.html#","page":"Discretization","title":"Discretization","text":"x′ = discrete_dynamics(::Type{MyQ}, model::AbstractModel, x, u, dt)","category":"page"},{"location":"discretization.html#Explicit-Methods-1","page":"Discretization","title":"Explicit Methods","text":"","category":"section"},{"location":"discretization.html#","page":"Discretization","title":"Discretization","text":"Explicit integration schemes are specified with a DynamicsConstraint. These methods are most efficiently computed when the entire trajectory is considered at once, thereby avoiding duplicate function evaluations. As a result, the user must define methods that deal with the entire trajectory at once:","category":"page"},{"location":"discretization.html#","page":"Discretization","title":"Discretization","text":"evaluate!(vals::Vector{<:AbstractVector}, con::DynamicsConstraint{MyQ},\n    Z::Traj, inds=1:length(Z)-1)","category":"page"},{"location":"discretization.html#","page":"Discretization","title":"Discretization","text":"Here vals is a Vector of Static Vectors, where the result of the calculation will be stored. con is a DynamicsConstraint that specifies the integration scheme, Z is the trajectory, and inds are the knotpoints where the constraint is applied (which should always be 1:N-1 if you have a single model for the entire trajectory). The method should compute","category":"page"},{"location":"discretization.html#","page":"Discretization","title":"Discretization","text":"vals[k] = x[k+1] - f(x[k],u[k],x[k+1],u[k+1])","category":"page"},{"location":"discretization.html#","page":"Discretization","title":"Discretization","text":"which is the amount of dynamic infeasibility between knotpoints. The method should obviously loop over the entire trajectory (see implementation for HermiteSimpson).","category":"page"},{"location":"discretization.html#Integrating-Cost-Functions-1","page":"Discretization","title":"Integrating Cost Functions","text":"","category":"section"},{"location":"discretization.html#","page":"Discretization","title":"Discretization","text":"Some methods, such as DIRCOL, apply the integration scheme to the cost function, as well. This can be done for a new integration rule by defining the following methods:","category":"page"},{"location":"discretization.html#","page":"Discretization","title":"Discretization","text":"cost(obj::Objective, dyn_con::DynamicsConstraint{MyQ}, Z::Traj)\ncost_gradient!(E::CostExpansion, obj::Objective, dyn_con::DynamicsConstraint{MyQ}, Z::Traj)","category":"page"},{"location":"cost_api.html#","page":"Cost Functions and Objectives","title":"Cost Functions and Objectives","text":"CurrentModule = TrajectoryOptimization","category":"page"},{"location":"cost_api.html#Cost-Functions-and-Objectives-1","page":"Cost Functions and Objectives","title":"Cost Functions and Objectives","text":"","category":"section"},{"location":"cost_api.html#","page":"Cost Functions and Objectives","title":"Cost Functions and Objectives","text":"This page details the functions related to building and evaluating cost functions and objectives.","category":"page"},{"location":"cost_api.html#Quadratic-Cost-Functions-1","page":"Cost Functions and Objectives","title":"Quadratic Cost Functions","text":"","category":"section"},{"location":"cost_api.html#","page":"Cost Functions and Objectives","title":"Cost Functions and Objectives","text":"QuadraticCost\nLQRCost\nLQRCostTerminal\nLQRObjective","category":"page"},{"location":"cost_api.html#TrajectoryOptimization.QuadraticCost","page":"Cost Functions and Objectives","title":"TrajectoryOptimization.QuadraticCost","text":"mutable struct QuadraticCost{TQ, TR, TH, Tq, Tr, T} <: CostFunction\n\nCost function of the form     1/2xₙᵀ Qf xₙ + qfᵀxₙ +  ∫ ( 1/2xᵀQx + 1/2uᵀRu + xᵀHu + q⁠ᵀx + rᵀu ) dt from 0 to tf R must be positive definite, Q and Qf must be positive semidefinite\n\nConstructor use any of the following constructors:\n\nQuadraticCost(Q, R, H, q, r, c)\nQuadraticCost(Q, R; H, q, r, c)\nQuadraticCost(Q, q, c)\n\nAny optional or omitted values will be set to zero(s).\n\n\n\n\n\n","category":"type"},{"location":"cost_api.html#TrajectoryOptimization.LQRCost","page":"Cost Functions and Objectives","title":"TrajectoryOptimization.LQRCost","text":"LQRCost(Q, R, xf)\nLQRCost(Q, R, xf, uf; checks)\n\n\nCost function of the form (x-x_f)^T Q (x_x_f) + u^T R u R must be positive definite, Q must be positive semidefinite\n\n\n\n\n\n","category":"function"},{"location":"cost_api.html#TrajectoryOptimization.LQRCostTerminal","page":"Cost Functions and Objectives","title":"TrajectoryOptimization.LQRCostTerminal","text":"LQRCostTerminal(Qf, xf)\n\n\nCost function of the form (x-x_f)^T Q (x-x_f) Q must be positive semidefinite\n\n\n\n\n\n","category":"function"},{"location":"cost_api.html#TrajectoryOptimization.LQRObjective","page":"Cost Functions and Objectives","title":"TrajectoryOptimization.LQRObjective","text":"LQRObjective(Q, R, Qf, xf, N)\n\nCreate an objective of the form (x_N - x_f)^T Q_f (x_N - x_f) + sum_k=0^N-1 (x_k-x_f)^T Q (x_k-x_f) + u_k^T R u_k\n\n\n\n\n\n","category":"function"},{"location":"cost_api.html#Indexed-Cost-Functions-1","page":"Cost Functions and Objectives","title":"Indexed Cost Functions","text":"","category":"section"},{"location":"cost_api.html#","page":"Cost Functions and Objectives","title":"Cost Functions and Objectives","text":"IndexedCost","category":"page"},{"location":"cost_api.html#Adding-Cost-Functions-1","page":"Cost Functions and Objectives","title":"Adding Cost Functions","text":"","category":"section"},{"location":"cost_api.html#","page":"Cost Functions and Objectives","title":"Cost Functions and Objectives","text":"Right now, TrajectoryOptimization supports addition of QuadraticCosts, but extensions to general cost function addition should be straightforward, as long as the cost function all have the same state and control dimensions.","category":"page"},{"location":"cost_api.html#","page":"Cost Functions and Objectives","title":"Cost Functions and Objectives","text":"Adding quadratic cost functions:","category":"page"},{"location":"cost_api.html#","page":"Cost Functions and Objectives","title":"Cost Functions and Objectives","text":"n,m = 4,5\nQ1 = Diagonal(@SVector [1.0, 1.0, 1.0, 1.0, 0.0])\nR1 = Diagonal(@SVector [1.0, 0.0, 0.0, 0.0, 0.0, 0.0])\nQ2 = Diagonal(@SVector [1.0, 1.0, 1.0, 1.0, 2.0])\nR2 = Diagonal(@SVector [0.0, 1.0, 1.0, 1.0, 1.0, 1.0])\ncost1 = QuadraticCost(Q1, R1)\ncost2 = QuadraticCost(Q2, R2)\ncost3 = cost1 + cost2\n# cost3 is equivalent to QuadraticCost(Q1+Q2, R1+R2)","category":"page"},{"location":"cost_api.html#CostExpansion-Type-1","page":"Cost Functions and Objectives","title":"CostExpansion Type","text":"","category":"section"},{"location":"cost_api.html#","page":"Cost Functions and Objectives","title":"Cost Functions and Objectives","text":"The CostExpansion type stores the pieces of the second order Taylor expansion of the cost for the entire trajectory, stored as vectors of Static Vectors or Static Matrices. e.g. to get the Hessian with respect to x at knotpoint 5 you would use E.xx[5].","category":"page"},{"location":"cost_api.html#","page":"Cost Functions and Objectives","title":"Cost Functions and Objectives","text":"CostExpansion","category":"page"},{"location":"cost_api.html#Objective-1","page":"Cost Functions and Objectives","title":"Objective","text":"","category":"section"},{"location":"cost_api.html#","page":"Cost Functions and Objectives","title":"Cost Functions and Objectives","text":"Objective\ncost(::Objective, Z::Traj)\nget_J\ncost_gradient\ncost_gradient!\ncost_hessian\ncost_hessian!","category":"page"},{"location":"cost_api.html#TrajectoryOptimization.Objective","page":"Cost Functions and Objectives","title":"TrajectoryOptimization.Objective","text":"struct Objective{C} <: TrajectoryOptimization.AbstractObjective\n\nObjective: stores stage cost(s) and terminal cost functions\n\nConstructors:\n\nObjective(cost, N)\nObjective(cost, cost_term, N)\nObjective(costs::Vector{<:CostFunction}, cost_term)\nObjective(costs::Vector{<:CostFunction})\n\n\n\n\n\n","category":"type"},{"location":"cost_api.html#TrajectoryOptimization.cost-Tuple{Objective,AbstractArray{#s63,1} where #s63<:KnotPoint}","page":"Cost Functions and Objectives","title":"TrajectoryOptimization.cost","text":"cost(obj::Objective, Z::Traj)::Float64\ncost(obj::Objective, dyn_con::DynamicsConstraint{Q}, Z::Traj)\n\nEvaluate the cost for a trajectory. Calculate the cost gradient for an entire trajectory. If a dynamics constraint is given,     use the appropriate integration rule, if defined.\n\n\n\n\n\n","category":"method"},{"location":"cost_api.html#TrajectoryOptimization.get_J","page":"Cost Functions and Objectives","title":"TrajectoryOptimization.get_J","text":"Get the vector of costs at each knot point. sum(get_J(obj)) is equal to the cost\n\n\n\n\n\n","category":"function"},{"location":"cost_api.html#TrajectoryOptimization.cost_gradient!","page":"Cost Functions and Objectives","title":"TrajectoryOptimization.cost_gradient!","text":"Qx,Qu = cost_gradient(cost::CostFunction, z::KnotPoint)\n\nGet Qx, Qu pieces of gradient of cost function, multiplied by dt\n\n\n\n\n\ncost_gradient!(E::CostExpansion, obj::Objective, Z::Traj)\ncost_gradient!(E::CostExpansion, obj::Objective, dyn_con::DynamicsConstraint{Q}, Z::Traj)\n\nCalculate the cost gradient for an entire trajectory. If a dynamics constraint is given,     use the appropriate integration rule, if defined.\n\n\n\n\n\n","category":"function"},{"location":"cost_api.html#TrajectoryOptimization.cost_hessian!","page":"Cost Functions and Objectives","title":"TrajectoryOptimization.cost_hessian!","text":"Qxx,Quu,Qux = cost_hessian(cost::CostFunction, z::KnotPoint)\n\nGet Qxx, Quu, Qux pieces of Hessian of cost function, multiplied by dt\n\n\n\n\n\ncost_hessian!(E::CostExpansion, obj::Objective, Z::Traj)\n\nCalculate the cost Hessian for an entire trajectory\n\n\n\n\n\n","category":"function"},{"location":"index.html#TrajectoryOptimization.jl-Documentation-1","page":"Introduction","title":"TrajectoryOptimization.jl Documentation","text":"","category":"section"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"CurrentModule = TrajectoryOptimization","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"Documentation for TrajectoryOptimization.jl","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"Pages = [\"index.md\"]","category":"page"},{"location":"index.html#Overview-1","page":"Introduction","title":"Overview","text":"","category":"section"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"This package is a testbed for state-of-the-art trajectory optimization algorithms. Trajectory optimization problems are of the form,","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"beginaligned\n  min_x_0Nu_0N-1 quad  ell_f(x_N) + sum_k=0^N-1 ell_k(x_k u_k dt) \n  textrmst            quad  x_k+1 = f(x_k u_k) \n                                  g_k(x_ku_k) leq 0 \n                                  h_k(x_ku_k) = 0\nendaligned","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"This package currently implements the following methods for solving trajectory optimization problems:","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"Iterative LQR (iLQR): indirect method based on Differential Dynamic Programming\nAL-iLQR: iLQR within an Augmented Lagrangian framework\nDirect Collocation: direct method that formulates the problem as an NLP and passes the problem off to a commercial NLP solver\nALTRO (Augmented Lagrangian Trajectory Optimizer): A novel algorithm developed by the Robotic Exploration Lab at Stanford University, which uses iLQR within an augmented Lagrangian framework combined with a \"Projected Newton\" direct method for solution polishing and enforcement of feasibility.","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"Key features include:","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"Support for general, per-timestep constraints\nForwardDiff for fast auto-differentiation of dynamics, cost functions, and constraints","category":"page"},{"location":"index.html#Getting-Started-1","page":"Introduction","title":"Getting Started","text":"","category":"section"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"To set up and solve a trajectory optimization problem with TrajectoryOptimization.jl, the user will go through the following steps:","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"Create a Model\nCreate an Objective\n(Optionally) Add constraints\nInstantiate a Problem\nSolve the problem","category":"page"},{"location":"costfunctions.html#objective_section-1","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"","category":"section"},{"location":"costfunctions.html#","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"CurrentModule = TrajectoryOptimization","category":"page"},{"location":"costfunctions.html#","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"Pages = [\"costfunctions.md\"]","category":"page"},{"location":"costfunctions.html#Overview-1","page":"2. Setting up an Objective","title":"Overview","text":"","category":"section"},{"location":"costfunctions.html#","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"All trajectory optimization problems require a cost function at each stage of the trajectory. Cost functions must be scalar-valued. We assume general cost functions of the form,","category":"page"},{"location":"costfunctions.html#","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"ell_f(x_N) + sum_k=1^N-1 ell_k(x_ku_k) dt","category":"page"},{"location":"costfunctions.html#","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"It is very important to note that ell_k(x_ku_k) is ONLY a function of x_k and u_k, i.e. no coupling across time-steps is permitted. This is a requirement for Differential Dynamic Programming methods such as iLQR, but could be relaxed for methods that parameterize both states and controls, such as DIRCOL. In general, any coupling between adjacent time-steps can be resolved by augmenting the state and defining the appropriate dynamics (this is the method we use to solve minimum time problems).","category":"page"},{"location":"costfunctions.html#","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"In general, trajectory optimization will take a second order Taylor series approximation of the cost function, resulting in a quadratic cost function of the form","category":"page"},{"location":"costfunctions.html#","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"x_N^T Q_f x_N + q_f^T x_N + sum_k=1^N-1 x_k^T Q_k x_k + q_k^T x_k + u_k^T R_k u_k + r_k^T u_k + u_k^T H_k x_k","category":"page"},{"location":"costfunctions.html#","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"This type of quadratic cost is typical for trajectory optimization problems, especially when Q is positive semi-definite and R is positive definite, which is strictly convex. These problem behave well and reduce the computational requirements of taking second-order Taylor series expansions of the cost at each iteration.","category":"page"},{"location":"costfunctions.html#","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"In TrajectoryOptimization.jl we differentiate between the entire objective and the cost functions at each time step. We use Objective to describe the function that is being minimized, which typically consists of a sum of cost functions, with potentially some additional terms (as is the case with augmented Lagrangian objectives). Describing the Objective as a sum of individual functions allows the solvers to more efficiently compute the gradient and Hessian of the entire cost, which is block-diagonal given the Markovianity of the problem.","category":"page"},{"location":"costfunctions.html#Cost-functions-1","page":"2. Setting up an Objective","title":"Cost functions","text":"","category":"section"},{"location":"costfunctions.html#","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"There are several different cost function types that all inherit from CostFunction. The following sections detail the various methods for instantiating these cost function types.","category":"page"},{"location":"costfunctions.html#Quadratic-Costs-1","page":"2. Setting up an Objective","title":"Quadratic Costs","text":"","category":"section"},{"location":"costfunctions.html#","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"Quadratic costs are the most standard cost function and excellent place to start. Let's assume we are creating an LQR tracking cost of the form","category":"page"},{"location":"costfunctions.html#","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"(x_N - x_f)^T Q_f (x_N - x_f) + sum_k=1^N-1 (x_k - x_f)^T Q (x_k - x_f) + u_k^T R u_k","category":"page"},{"location":"costfunctions.html#","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"for the simple pendulum with the goal of doing a swing-up. To do this we have very convenient constructors LQRCost and LQRCostTerminal:","category":"page"},{"location":"costfunctions.html#","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"using LinearAlgebra, StaticArrays\nn,m = 2,1\nQ = Diagonal(@SVector fill(0.1,n))\nR = Diagonal(@SVector fill(0.1,m))\nQf = Diagonal(@SVector fill(1000,n))\nxf = @SVector [π,0]\ncostfun = LQRCost(Q,R,Qf)\ncostfun_term = LQRCostTerminal(Qf,xf)","category":"page"},{"location":"costfunctions.html#","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"It is HIGHLY recommended to specify any special structure, such as Diagonal, especially since these matrices are almost always diagonal.","category":"page"},{"location":"costfunctions.html#","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"This constructor actually does a simple conversion to turn our cost function into a generic quadratic cost function. We could do this ourselves:","category":"page"},{"location":"costfunctions.html#","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"H = @SMatrix zeros(m,n)\nq = -Q*xf\nr = @SVector zeros(m)\nc = xf'Q*xf/2\nqf = -Qf*xf\ncf = xf'Qf*xf/2\ncostfun      = QuadraticCost(Q, R, H, q, r, c)\ncostfun_term = QuadraticCost(Qf, R*0, H, qf, r*0, cf)","category":"page"},{"location":"costfunctions.html#","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"The QuadraticCost constructor also supports keyword arguments and one that allows for only Q,q and c.:","category":"page"},{"location":"costfunctions.html#","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"costfun      = QuadraticCost(Q, R, q=q, c=c)\ncostfun_term = QuadraticCost(Q, q, c)","category":"page"},{"location":"costfunctions.html#","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"Once we have defined the cost function, we can create an objective for our problem by simply copying over all time steps (except for the terminal).","category":"page"},{"location":"costfunctions.html#","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"# Create an objective from a single cost function\nN = 51\nobj = Objective(costfun, costfun_term, N)","category":"page"},{"location":"costfunctions.html#","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"There's also a convenient constructor that builds an LQRObjective","category":"page"},{"location":"costfunctions.html#","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"obj = LQRObjective(Q, R, Qf, xf, N)","category":"page"},{"location":"costfunctions.html#Objectives-1","page":"2. Setting up an Objective","title":"Objectives","text":"","category":"section"},{"location":"costfunctions.html#","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"Objectives can be created by copying a single cost function over all time steps. See Objective API for more information.","category":"page"},{"location":"costfunctions.html#","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"Objective(cost::CostFunction, N::Int)","category":"page"},{"location":"costfunctions.html#","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"or uniquely specifying the terminal cost function","category":"page"},{"location":"costfunctions.html#","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"Objective(cost::CostFunction, cost_terminal::CostFunction, N::Int)","category":"page"},{"location":"costfunctions.html#","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"or by explicitly specifying a list of cost functions","category":"page"},{"location":"costfunctions.html#","page":"2. Setting up an Objective","title":"2. Setting up an Objective","text":"Objective(costfuns::Vector{<:CostFunction})","category":"page"},{"location":"constraint_interface.html#","page":"Constraint Interface","title":"Constraint Interface","text":"CurrentModule = TrajectoryOptimization","category":"page"},{"location":"constraint_interface.html#Constraint-Interface-1","page":"Constraint Interface","title":"Constraint Interface","text":"","category":"section"},{"location":"constraint_interface.html#Constraint-Type-1","page":"Constraint Interface","title":"Constraint Type","text":"","category":"section"},{"location":"constraint_interface.html#","page":"Constraint Interface","title":"Constraint Interface","text":"All constraints inherit from AbstractConstraint{S<:ConstraintSense,W<:ConstraintType,P}, where ConstraintSense specifies Inequality or Equality, ConstraintType specifies the \"bandedness\" of the constraint (will be discussed more later), and P is the dimension of the constraint. This allows the software to easily dispatch over the type of constraint. Each constraint type represents a vector-valued constraint. The intention is that each constraint type represent one line in the constraints of problem definition (where they may be vector or scalar-valued).","category":"page"},{"location":"constraint_interface.html#","page":"Constraint Interface","title":"Constraint Interface","text":"TrajectoryOptimization.jl assumes equality constraints are of the form g(x) = 0 and inequality constraints are of the form h(x) leq 0.","category":"page"},{"location":"constraint_interface.html#","page":"Constraint Interface","title":"Constraint Interface","text":"AbstractConstraint\nConstraintSense\nConstraintType","category":"page"},{"location":"constraint_interface.html#TrajectoryOptimization.AbstractConstraint","page":"Constraint Interface","title":"TrajectoryOptimization.AbstractConstraint","text":"abstract type AbstractConstraint <: TrajectoryOptimization.GeneralConstraint\n\nAbstract vector-valued constraint of size P for a trajectory optimization problem. May be either inequality or equality (specified by S<:ConstraintSense), and be function of single, adjacent, or all knotpoints (specified by W<:ConstraintType).\n\nInterface: Any constraint type must implement the following interface:\n\nn = state_dim(::MyCon)\nm = control_dim(::MyCon)\np = Base.length(::MyCon)\nc = evaluate(::MyCon, args...)   # args determined by W\n∇c = jacobian(::MyCon, args...)  # args determined by W\n\nThe evaluate and jacobian (identical signatures) methods should have the following signatures\n\nW <: State: evaluate(::MyCon, x::SVector)\nW <: Control: evaluate(::MyCon, u::SVector)\nW <: Stage: evaluate(::MyCon, x, u)\nW <: Dynamical: evaluate(::MyCon, x′, x, u)\nW <: Coupled: evaluate(::MyCon, x′, u′ x, u)\n\nOr alternatively,\n\nW <: Stage: evaluate(::MyCon, z::KnotPoint)\nW <: Coupled: evaluate(::MyCon, z′::KnotPoint, z::KnotPoint)\n\nThe Jacobian method for State or Control is optional, since it will \tbe automatically computed using ForwardDiff. Automatic differentiation \tfor other types of constraints is not yet supported.\n\nFor W <: State, control_dim(::MyCon) doesn't need to be defined. Equivalently, for \tW <: Control, state_dim(::MyCon) doesn't need to be defined.\n\nFor W <: General, the more general evaluate and jacobian methods must be used\n\nevaluate!(vals::Vector{<:AbstractVector}, ::MyCon, Z::Traj, inds=1:length(Z)-1)\njacobian!(∇c::Vector{<:AbstractMatrix}, ::MyCon, Z::Traj, inds=1:length(Z)-1)\n\nThese methods can be specified for any constraint, instead of the not-in-place functions \tabove.\n\n\n\n\n\n","category":"type"},{"location":"constraint_interface.html#TrajectoryOptimization.ConstraintSense","page":"Constraint Interface","title":"TrajectoryOptimization.ConstraintSense","text":"Specifies whether the constraint is an equality or inequality constraint. Valid subtypes are Equality, Inequality, and Null\n\n\n\n\n\n","category":"type"},{"location":"constraint_interface.html#TrajectoryOptimization.ConstraintType","page":"Constraint Interface","title":"TrajectoryOptimization.ConstraintType","text":"Specifies the ``bandedness'' of the constraint. This ends up being the width of the constraint Jacobian, or the total number of input variables. This is important to reduce the size of arrays needed to store the Jacobian, as well as special-case the block matrix algebra.\n\nCurrent subtypes:\n\nStage\nState <: Stage\nControl <: Stage\nCoupled\nDynamical <: Coupled\nCoupledState <: Coupled\nCoupledControl <: Coupled\nGeneral\nGeneralState <: General\nGeneralControl <: General\n\n\n\n\n\n","category":"type"},{"location":"constraint_interface.html#Methods-1","page":"Constraint Interface","title":"Methods","text":"","category":"section"},{"location":"constraint_interface.html#","page":"Constraint Interface","title":"Constraint Interface","text":"The following methods are defined for all AbstractConstraints","category":"page"},{"location":"constraint_interface.html#","page":"Constraint Interface","title":"Constraint Interface","text":"state_dims\ncontrol_dims\nevaluate!\njacobian!\ncontype\nsense\nwidth\nupper_bound\nlower_bound\nis_bound\ncheck_dims","category":"page"},{"location":"constraint_interface.html#TrajectoryOptimization.state_dims","page":"Constraint Interface","title":"TrajectoryOptimization.state_dims","text":"Size of control vector\n\n\n\n\n\n","category":"function"},{"location":"constraint_interface.html#TrajectoryOptimization.control_dims","page":"Constraint Interface","title":"TrajectoryOptimization.control_dims","text":"Size of state vector\n\n\n\n\n\n","category":"function"},{"location":"constraint_interface.html#TrajectoryOptimization.evaluate!","page":"Constraint Interface","title":"TrajectoryOptimization.evaluate!","text":"evaluate!(vals::Vector{<:AbstractVector}, con::AbstractConstraint{S,W,P},\n\tZ, inds=1:length(Z)-1)\n\nEvaluate constraints for entire trajectory. This is the most general method used to evaluate \tconstraints, and should be the one used in other functions.\n\nFor W<:Stage this will loop over calls to evaluate(con,Z[k])\n\nFor W<:Coupled this will loop over calls to evaluate(con,Z[k+1],Z[k])\n\nFor W<:General,this must function must be explicitly defined. Other types may define it \tif desired.\n\n\n\n\n\nevaluate!(conSet::ConstraintSet, Z::Traj)\n\nCompute constraint values for all constraints for the entire trajectory\n\n\n\n\n\n","category":"function"},{"location":"constraint_interface.html#TrajectoryOptimization.jacobian!","page":"Constraint Interface","title":"TrajectoryOptimization.jacobian!","text":"∇f = jacobian!(∇c, model, z::KnotPoint)\n∇f = jacobian!(∇c, model, z::SVector)\n\nCompute the Jacobian of the continuous-time dynamics using ForwardDiff. The input can be either a static vector of the concatenated state and control, or a KnotPoint. They must be concatenated to avoid unnecessary memory allocations.\n\n\n\n\n\njacobian!(vals::Vector{<:AbstractVector}, con::AbstractConstraint{S,W,P},\n\tZ, inds=1:length(Z)-1)\n\nEvaluate constraint Jacobians for entire trajectory. This is the most general method used to \tevaluate constraint Jacobians, and should be the one used in other functions.\n\nFor W<:Stage this will loop over calls to jacobian(con,Z[k])\n\nFor W<:Coupled this will loop over calls to jacobian(con,Z[k+1],Z[k])\n\nFor W<:General,this must function must be explicitly defined. Other types may define it \tif desired.\n\n\n\n\n\njacobian!(conSet::ConstraintSet, Z::Traj)\n\nCompute constraint Jacobians for all constraints for the entire trajectory\n\n\n\n\n\n","category":"function"},{"location":"constraint_interface.html#TrajectoryOptimization.contype","page":"Constraint Interface","title":"TrajectoryOptimization.contype","text":"Get type of constraint (bandedness)\n\n\n\n\n\n","category":"function"},{"location":"constraint_interface.html#TrajectoryOptimization.sense","page":"Constraint Interface","title":"TrajectoryOptimization.sense","text":"Get constraint sense (Inequality vs Equality)\n\n\n\n\n\n","category":"function"},{"location":"constraint_interface.html#TrajectoryOptimization.width","page":"Constraint Interface","title":"TrajectoryOptimization.width","text":"Returns the width of the constraint Jacobian, i.e. the total number of inputs to the constraint\n\n\n\n\n\n","category":"function"},{"location":"constraint_interface.html#TrajectoryOptimization.upper_bound","page":"Constraint Interface","title":"TrajectoryOptimization.upper_bound","text":"Upper bound of the constraint, as a vector, which is 0 for all constraints (except bound constraints)\n\n\n\n\n\n","category":"function"},{"location":"constraint_interface.html#TrajectoryOptimization.lower_bound","page":"Constraint Interface","title":"TrajectoryOptimization.lower_bound","text":"Upper bound of the constraint, as a vector, which is 0 equality and -Inf for inequality (except bound constraints)\n\n\n\n\n\n","category":"function"},{"location":"constraint_interface.html#TrajectoryOptimization.is_bound","page":"Constraint Interface","title":"TrajectoryOptimization.is_bound","text":"Is the constraint a bound constraint or not\n\n\n\n\n\n","category":"function"},{"location":"constraint_interface.html#TrajectoryOptimization.check_dims","page":"Constraint Interface","title":"TrajectoryOptimization.check_dims","text":"Check whether the constraint is consistent with the specified state and control dimensions\n\n\n\n\n\n","category":"function"},{"location":"constraint_interface.html#Adding-a-New-Constraint-1","page":"Constraint Interface","title":"Adding a New Constraint","text":"","category":"section"},{"location":"constraint_interface.html#","page":"Constraint Interface","title":"Constraint Interface","text":"See interface description in documentation for AbstractConstraint. The interface allows for a lot of flexibility, but let's do a simple example. Let's say we have a 2-norm constraint on the controls at each time step, e.g. u leq a. We can do this with just a few lines of code:","category":"page"},{"location":"constraint_interface.html#","page":"Constraint Interface","title":"Constraint Interface","text":"struct ControlNorm{T} <: AbstractConstraint{Inequality,Control,1}\n  m::Int\n  a::T\nend\ncontrol_dim(con::ControlNorm) = con.m\nevaluate(con::ControlNorm, u::SVector) = @SVector [norm(u) - con.a] # needs to be a vector output\njacobian(con::ControlNorm, u::SVector) = u'/norm(u)  # optional","category":"page"},{"location":"constraint_interface.html#","page":"Constraint Interface","title":"Constraint Interface","text":"Importantly, note that the inheritance specifies the constraint applies only to individual controls, the constraint in an inequality, and has dimension 1.","category":"page"},{"location":"constraint_interface.html#","page":"Constraint Interface","title":"Constraint Interface","text":"Let's say the bound a varied by time-step. We could handle this easily by instead defining the methods operating on the entire trajectory:","category":"page"},{"location":"constraint_interface.html#","page":"Constraint Interface","title":"Constraint Interface","text":"struct ControlNorm2{T} <: AbstractConstraint{Inequality,Control,1}\n  m::Int\n  a::Vector{T}\nend\ncontrol_dim(con::ControlNorm) = con.m\nfunction evaluate!(vals::Vector{<:AbstractVector}, con::ControlNorm,\n    Z, inds=1:length(Z)-1)\n  for (i,k) in enumerate(inds)\n    u = control(Z[k])\n    vals[i] = @SVector [norm(u) - con.a[k]]\n  end\nend\nfunction jacobian!(∇c::Vector{<:AbstractMatrix}, con::ControlNorm,\n    Z, inds=1:length(Z)-1)\n  for (i,k) in enumerate(inds)\n    u = control(Z[k])\n    ∇c[i] = u'/norm(u)\n  end\nend","category":"page"},{"location":"constraint_interface.html#Constraint-Types-1","page":"Constraint Interface","title":"Constraint Types","text":"","category":"section"},{"location":"constraint_interface.html#","page":"Constraint Interface","title":"Constraint Interface","text":"The ConstraintType defines the \"bandedness\" of the constraint, or the number of adjacent state or constraint values needed to calculate the constraint. ","category":"page"},{"location":"constraint_interface.html#","page":"Constraint Interface","title":"Constraint Interface","text":"Stage\nState\nControl\nCoupled\nDynamical\nCoupledState\nCoupledControl\nGeneral\nGeneralState\nGeneralControl","category":"page"},{"location":"constraint_interface.html#TrajectoryOptimization.Stage","page":"Constraint Interface","title":"TrajectoryOptimization.Stage","text":"Only a function of states and controls at a single knotpoint\n\n\n\n\n\n","category":"type"},{"location":"constraint_interface.html#TrajectoryOptimization.State","page":"Constraint Interface","title":"TrajectoryOptimization.State","text":"Only a function of states at a single knotpoint\n\n\n\n\n\n","category":"type"},{"location":"constraint_interface.html#TrajectoryOptimization.Control","page":"Constraint Interface","title":"TrajectoryOptimization.Control","text":"Only a function of controls at a single knotpoint\n\n\n\n\n\n","category":"type"},{"location":"constraint_interface.html#TrajectoryOptimization.Coupled","page":"Constraint Interface","title":"TrajectoryOptimization.Coupled","text":"Only a function of states and controls at two adjacent knotpoints\n\n\n\n\n\n","category":"type"},{"location":"constraint_interface.html#TrajectoryOptimization.Dynamical","page":"Constraint Interface","title":"TrajectoryOptimization.Dynamical","text":"Only a function of states and two adjacent knotpoints, and the control at the previous knotpoint, i.e. f(x,u) - x′\n\n\n\n\n\n","category":"type"},{"location":"constraint_interface.html#TrajectoryOptimization.CoupledState","page":"Constraint Interface","title":"TrajectoryOptimization.CoupledState","text":"Only a function of states at adjacent knotpoints\n\n\n\n\n\n","category":"type"},{"location":"constraint_interface.html#TrajectoryOptimization.CoupledControl","page":"Constraint Interface","title":"TrajectoryOptimization.CoupledControl","text":"Only a function of controls at adjacent knotpoints\n\n\n\n\n\n","category":"type"},{"location":"constraint_interface.html#TrajectoryOptimization.General","page":"Constraint Interface","title":"TrajectoryOptimization.General","text":"A function of all states and controls in the trajectory\n\n\n\n\n\n","category":"type"},{"location":"constraint_interface.html#TrajectoryOptimization.GeneralState","page":"Constraint Interface","title":"TrajectoryOptimization.GeneralState","text":"A function of all states in the trajectory\n\n\n\n\n\n","category":"type"},{"location":"constraint_interface.html#TrajectoryOptimization.GeneralControl","page":"Constraint Interface","title":"TrajectoryOptimization.GeneralControl","text":"A function of all controls in the trajectory\n\n\n\n\n\n","category":"type"}]
}
